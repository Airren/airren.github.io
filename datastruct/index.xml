<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DataStructs on ByteGopher</title>
    <link>https://airren.github.io/datastruct/</link>
    <description>Recent content in DataStructs on ByteGopher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Sep 2020 00:53:15 +0000</lastBuildDate><atom:link href="https://airren.github.io/datastruct/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据结构与算法动态规划</title>
      <link>https://airren.github.io/DataStruct/ds_dp/</link>
      <pubDate>Thu, 17 Sep 2020 00:53:15 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_dp/</guid>
      <description>动态规划：
子问题 状态定义 DP方程 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/02_complication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/02_complication/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/03_array_link_jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/03_array_link_jump/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/04_stack_queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/04_stack_queue/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/05_ds_hash_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/05_ds_hash_map/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/ds_heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_heap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「LeetCode」LeetCode</title>
      <link>https://airren.github.io/DataStruct/LeetCode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/LeetCode/</guid>
      <description>1 1 package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	fmt.Println(twoSum([]int{2, 7, 11, 15}, 9)) 7} 8 9func twoSum(nums []int, target int) []int { 10 11	maps := make(map[int]int) 12 13	for i, value := range nums { 14	mid := target - value 15 16	res, ok := maps[mid] 17	if ok { 18	return []int{res, i} 19	} else { 20	maps[value] = i 21	} 22	} 23	return []int{} 24} 120.</description>
    </item>
    
    <item>
      <title>「剑指offer」 Go语言版本</title>
      <link>https://airren.github.io/DataStruct/%E5%89%91%E6%8C%87offer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/%E5%89%91%E6%8C%87offer/</guid>
      <description>编码过程中首先要校验输入数据的合法性。
写代码之前首先想好有哪些测试用例，要提高代码的测试覆盖率。
3. 数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
2 &amp;lt;= n &amp;lt;= 100000
如果使用Map，则时间复杂度为O(n), 空间复杂度为O(n)。题目中的关键信息为长度为n的数组，且所有数字都在0~n-1的范围内，所以可以不用额外开辟空间。
1func findRepeatNumber(nums []int) int { 2	var tmp int 3	for i, v := range nums { 4	if v != i { 5	if nums[v] == v { 6	return v 7	} 8	tmp = nums[v] 9	nums[v] = v 10	nums[i] = tmp 11	} 12	} 13	return -1 14} 15 16// 时间复杂度为O(n),空间复杂读为O(1) 4.</description>
    </item>
    
    <item>
      <title>「算法」贪心算法</title>
      <link>https://airren.github.io/DataStruct/ds_greed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_greed/</guid>
      <description>例题 【简单】n个活动时间，选择可以参与最多的活动
优先选择结束最早的活动
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sort&amp;#34; 6) 7 8type node struct { 9	startAt int 10	endAt int 11} 12 13var ( 14	total int 15	now int 16	res int 17	nodeList = make([]node, 0) 18) 19 20func main() { 21	_, _ = fmt.Scanf(&amp;#34;%d&amp;#34;, &amp;amp;total) 22	nodeList = make([]node, total) 23	for i := 0; i &amp;lt; total; i++ { 24	_, _ = fmt.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」Tree</title>
      <link>https://airren.github.io/DataStruct/06_ds_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/06_ds_tree/</guid>
      <description>单链表的查询时间复杂度是O(n)
跳表
树
图
Linked List 是特殊化的Tree
Tree 是特殊化的图
斐波那契， 状态树，递归树
状态树空间
决策树空间
二叉树 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上。
完全二叉树:
存储结构:
链式存储
1// golang 2type Node struct { 3	Data int64 4	LeftNode *Node 5	RightNode *Node 6} // C++ struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(NULL), right(NULL){} }
1 23. ```java 3public class TreeNode{ 4 public int val; 5 public TreeNode left,right; 6 public TreeNode(int val){ 7	this.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」排列组合</title>
      <link>https://airren.github.io/DataStruct/ds_combine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_combine/</guid>
      <description>组合 1import java.util.*; 2 3public class Mains{ 4 public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resultss = new ArrayList&amp;lt;&amp;gt;(); 5 6 public void combinations(List&amp;lt;Integer&amp;gt; selected, List&amp;lt;Integer&amp;gt; data, int num){ 7 if(num == 0){ 8 resultss.add(new ArrayList&amp;lt;Integer&amp;gt;(selected)); 9 return; 10 } 11 if(data.size() == 0 ){ 12 System.out.print(&amp;#34;&amp;#34;); 13 return; 14 } 15 selected.add(data.get(0)); 16 combinations(selected, data.subList(1, data.size()), num -1); 17 selected.remove(data.get(0)); 18 combinations(selected, data.subList(1, data.size()), num ); 19 } 20 public static void main(String[] args) { 21 Mains combin = new Mains(); 22 int[] nums = new int[]{1,2,3,4,5}; 23 combin.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」排序算法</title>
      <link>https://airren.github.io/DataStruct/ds_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_sort/</guid>
      <description>排序算法 术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内部排序：待排序的数据可以全部放入内存中；
外部排序：待排序数据的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存(磁盘)进行访问；
时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小。
排序算法总结 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n^2^) O(n) O(n^2^) O(1) In-place 稳定 选择排序 O(n^2^) O(n^2^) O(n^2^) O(1) In-place 不稳定 插入排序 O(n^2^) O(n) O(n^2^) O(1) In-place 稳定 希尔排序 O(n logn) O(nlog^2^n) O(nlog^2^n) O(1) In-place 不稳定 归并排序 O(n logn) O(n logn) O(n logn) O(n) Out-place 稳定 快速排序 O(n logn) O(n logn) O(n^2^) O(n logn) In-place 不稳定 堆排序 O(n logn) O(n logn) O(n logn) O(1) In-place 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) Out-place 稳定 桶排序 O(n+k) O(n+k) O(n^2^) O(n+k) Out-place 稳定 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) Out-place 稳定 n:数据规模；k:&amp;ldquo;桶&amp;quot;的个数；n-place:占用常数内存，不占用额外内存；Out-place:占用额外内存</description>
    </item>
    
    <item>
      <title>「算法与数据结构」查找算法</title>
      <link>https://airren.github.io/DataStruct/ds_find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_find/</guid>
      <description>二分查找 1public class BinarySearch{ 2 public static void main(String[] args) { 3 int[] arr = {1,2,3,4,5,6,7,8}; 4 int k = 8; 5 System.out.println(binarySerach(arr, k)); 6 } 7 8 public static int binarySerach(int[] arr, int k){ 9 int a = 0; 10 int b = arr.length; 11 12 while(a &amp;lt; b){ 13 int mid = a+(b-a)/2; 14 if(k &amp;lt; arr[mid]){ 15 b = mid; 16 }else if(k &amp;gt; arr[mid]){ 17 a = mid + 1; 18 }else{ 19 return mid; 20 } 21 } 22 return -1; 23 24 } 25} </description>
    </item>
    
    <item>
      <title>「算法与数据结构」链表</title>
      <link>https://airren.github.io/DataStruct/ds_linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_linkedlist/</guid>
      <description>单向链表 1import java.util.*; 2class Node{ 3 private final int value; 4 private Node next; 5 6 public Node(int value){ 7 this.value = value; 8 this.next = null; 9 } 10 public int getValue(){ 11 return this.value; 12 } 13 public Node getNext(){ 14 return this.next; 15 } 16 public void setNext(Node next){ 17 this.next = next; 18 } 19 20 public static void printLinkedList(Node head){ 21 while(head != null){ 22 System.</description>
    </item>
    
    <item>
      <title>String 字符串</title>
      <link>https://airren.github.io/DataStruct/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/string/</guid>
      <description>计算生物学家的一项工作就是根据密码将DNA转换为由4个碱基组成的非常长的字符串。
Knuth、Morris、Pratt 子字符串查找算法，这些经典算法的基础是两个基本概念：形式语言和确定有限状态自动机。
JACA 安装配置</description>
    </item>
    
  </channel>
</rss>
