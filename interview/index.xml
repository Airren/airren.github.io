<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interviews on ByteGopher</title>
    <link>https://airren.github.io/interview/</link>
    <description>Recent content in Interviews on ByteGopher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 29 Dec 2018 11:02:05 +0800</lastBuildDate><atom:link href="https://airren.github.io/interview/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</guid>
      <description>项目架构 ES6 和TypeScript
And Design Pro
log 可以放在src/assets/images/klogo.svg。 然后在页面中通过以下方式使用
1 2// @ 表示在src 目录下面 3import logo from &amp;#39;@/assets/images/logo.svg&amp;#39; 4 5&amp;lt;LoginForm 6	logo={&amp;lt;image alt=&amp;#34;logo&amp;#34; src={logo}&amp;gt;} </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/2nd_React%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/2nd_React%E4%BB%8B%E7%BB%8D/</guid>
      <description>2. React介绍 2.1 React 基本介绍 FaceBook 开源的JavaScript库
React结合生态库构成一个MV*框架
React特点
Declarative 声明式编码
Component-Based 组件化编码
高效-高效的DOM Diff算法，最小化页面重绘
单项数据流
MV*框架代表- 只关注视图view层+数据层Model
生态介绍
Vue生态： Vue+Vue-Router+Vuex+Axios+Babel + Webpack React生态： React+React-Router+Redux+Axios+Babel + WebPack 编程式实现
需要以具体代码表达在哪里(where)做什么(what)，如何实现（how） 声明式实现
只需要声明在哪里（where）做什么（what），而无需关系如何实现（how） 2.2 React脚手架、yarn 如何安装和使用React脚手架 1npm install -g create-react-app 2creat-react-app my-app 3 4cd my-app 5npm start 什么是Yarn
yarn 是新一代的包管理工具 为什么使用Yarn
速度快 安装版本统一、更安全 更简洁的输出 更好的语义化 如何使用Yarn
1yarn init 2yarn add # npm install 3yarn remove # npm uninstall 4yarn/yarn install # npm install 或者 npm i http:// reactjs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/3rd_%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/3rd_%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>3. 主页面架构设计 课程目标介绍
第二章 项目主页工程搭建
基础插件安装，less文件加载配置 项目主页结构开发 菜单组件开发 头部组件开发 底部组件开发 3-1 基础插件安装（1） 基础插件安装，less文件加载配置 安装所需的插件
安装React-Router, Axios 安装antD界面框架 暴露webpack配置文件 安装less-loader 修改less-loader 1 yarn add react-router-dom axios less-loader # 3.0升级到 4.0 AntD 是基于less开发的
暴露webpack文件使用less 1yarn eject create-react-app添加less配置
修改完成配置后需要重启项目，从后向前使用， less的配置放在css，scss之后
可能需要删除node_module文件夹重新yarn install
yarn add less
需要修改的文件config/webpack.config.js
1// style files regexes 2const cssRegex = /\.css$/; 3const cssModuleRegex = /\.module\.css$/; 4const lessRegex = /\.less$/; 5const lessModuleRegex = /\.module\.less$/; 6const sassRegex = /\.(scss|sass)$/; 7const sassModuleRegex = /\.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/0_Category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/0_Category/</guid>
      <description>2nd_操作系统
3rd_网络
4th_数据库
5th_程序设计基础
6th_编码技巧
7th_面向对象
8th_设计模式
9th_高级知识点
10th_Google笔试题解
11th_面试技巧和总结</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/10th_Google%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/10th_Google%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/11th_%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%92%8C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/11th_%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%92%8C%E6%80%BB%E7%BB%93/</guid>
      <description>面试软技巧和总结 解决问题的能力 面对问题的态度 分析问题的方法 结构化分析问题 剔除干扰项 提问面试官 介绍一下所在的项目组 介绍一下所用的技术栈 对我的个人的意见和建议 后续学习 基础知识： 广度优先， 在兴趣点深入 编码能力： LeetCode， Google在线平台 面向对象和设计模式： 尝试重构自己写过的代码 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/2nd_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/2nd_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>操作系统 进程和线程 进程： 进程中的内存是逻辑内存， 所有进程的逻辑内存之和要远远大于物理内存。 文件/网络句柄是共享的 线程 TLS： Thread Local Storage 缓冲区溢出 协程 进程之间不可以共享内存， 线程之间可以共享内存 进程间的通信方式： 管道，TCP/IP 比较优劣 线程间的通信方式： 共享内存 存储和寻址 存储 寻址空间 每个进程有自己的独立寻址空间 进程独立
32位 -&amp;gt; 4G 64位 -&amp;gt; ~10^19Bytes 1wPB 64位JVM -&amp;gt; 可以使用更大的内存，32 -&amp;gt; 需要重新编译 寻址 int n= *p; -&amp;gt; MOV EAX,[EBX] 把EBX寄存器中的数据读出，放入EAX 寄存器。n -&amp;gt; EAX, p -&amp;gt; EBX.
逻辑内存的大小与物理内存没有关系，只有操作系统有关。 操作系统的位数决定逻辑内存的位数。 逻辑内存映射到物理内存，数据不一定在物理内存中，也可能存在虚拟内存中。 当数据在虚拟内存中时候，不是只把逻辑内存对应的数据加载到物理内存，而是把数据所在的分页加载到物理内存。如果物理内存放不下，就交换一部分数据到虚拟内存。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/3rd_%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/3rd_%E7%BD%91%E7%BB%9C/</guid>
      <description>网络 网络基础 不可靠 丢包，重复包 出错 乱序 不安全 中间人攻击 窃取 篡改 滑动窗口 TCP协议中使用
维持发送方/接收方缓冲区
流量控制+拥塞控制 在传输过程中会调整窗口的大小 窗口的大小为0是合法的，（如果消息来不及处理可以设置为0） 不使用滑动窗口的话吞吐量会非常低
滑动窗口的Ack是有序的 如果丢ACk 会启动超时重传机制 WireShark 抓包 wireShark 抓包
网络例题 一个来回的时间：1500km/(2*10^5km/s) *2 = 0.015s 来回的次数至多：100s/0.015 = 6666.67次
每次传输至少： 100GB/6666.67 = 15M
数据链路层 网络层 传输层 TCP/UDP 应用层</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/4th_%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/4th_%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>数据库 关系型数据库 基于关系代数理论 缺点： 表结构不直观，实现复杂速，速度慢 优点： 健壮性高，社区庞大 Product
product_id product_name category_id price 4 toyota 2 100000 3 prosche 2 1000000 2 addidas 2 500 1 nike 600 category
category_id category_name 2 automobile 1 shoes 1select * from product join category; -- 结果为笛卡尔积 8条记录 2 3select * from product p join category c on p.category_id=c.category_id; -- 按照id相等去连接， 忽略id 为空的记录 内连接 null的数据不会显示 4 5 6select * from product p left join category c on p.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/5th_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/5th_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</guid>
      <description>程序设计语言基础 程序设计语言 类型检查
编译时：C, C++, Java, Go 运行时： Python, Perl, JavaScript, Ruby 运行/编译
编译为机器代码运行：C, C++ 编译为中间代码，在虚拟机运行： Java, C# 解释执行： Python, Perl, JavaScript 编程范式 Programming Paradigm
面向过程: C, Visual Basic 面向对象: Java, C++, C#, Scala 函数式: Haskell, Erlang 数据类型和补码 数据类型
boolean, byte, char short, int, long, float, double String, Enum, Array Object&amp;hellip; 补码
32位int 范围 -2^31 ~ 2^31 -1 11000...0 -2^32 21111...1 -1 30000...0 0 40111...1 2^31-1 5 6-1 + 1 = 0 浮点数与定点数 浮点数 (+/-)1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/6th_%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/6th_%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</guid>
      <description>编码技巧 编码技巧概述 递归控制 循环控制 边界控制 数据结构 好的代码， 代码短，思路清晰
白板上写程序 先思考后写， 不要惧怕修改和重写
数学归纳法 用于证明断言对所有的自然数成立</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/7th_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/7th_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象 面向对象思想 类与对象 接口与实现 继承与封装 不可变对象 泛型 从用户(终端用户，使用你代码的用户)的角度思考问题 摒弃完全基于逻辑的思维 类与对象 类的成员变量 -&amp;gt; 对象状态
类的成员函数 -&amp;gt; 对象行为
类的静态变量
类的静态函数
逻辑结构 1class Employee{ 2 void getPaid(BankEndPont bank){ 3 bank.payment(name, salary); // this 4 } 5} 类的静态变量和静态函数
没有this引用， 金泰变量全局唯一一份 普通函数引用静态变量和静态函数？ OK 对象引用静态变量, 函数？ 编译器警告 静态函数引用普通成员变量、 函数 ？ 编译错误 对象的特殊函数 构造函数 equals Object 的equals方法默认判断是否为同一个对象 hashCode a.hashCode() == b.hashCode() &amp;laquo;&amp;ndash; a.equals(b) toString 接口与抽象类 为什么要有接口的概念
从用户(使用实现的代码)的角度看看问题 由编译器强制的一个模块间协作的合约(Contarct)， 强制协作双方无法犯错 无成员变量 成员函数只有声明不能有实现 接口的声明 Java : interface C++: 一个全部是纯虚函数的类 Python/ 大部分动态语言： 依靠注释申明 抽象类 至少有一个抽象方法， 抽象方法没有实现；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/8th_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/8th_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>第8讲 设计模式 1. 单例模式 Singleton 设计模式的提出：博士论文 设计 vs 语言限制 更多的模式： 并发模式、架构模式 从架构的思想上看
Singleton优缺点 确保全局至多只有一个对象 用于： 构造缓慢的对象，需要统一管理的资源 缺点： 很多全局状态， 线程安全性 Singleton的创建（创建非常慢的对象） 双重锁模式 Double checked locking 作为Java 类的静态变量（程序初始化的时候就要创建出来） 使用框架提供的能力 依赖注入的框架（DI框架 Spring, Google Juice）
2. State 模式 变继承关系为组合关系 继承关系 描述is-a关系 复用，增加修改 不用用继承关系来实现复用 使用设计模式实现复用 如果 Employee 升级成了 Manager ？ 新建成一个Manager, 原先的引用应该被回收。
或者使用state模式
3. Decorator模式 装饰者模式 1interface Runable{ 2 void run(); 3} 如何实现LoggingRunable, TransactionRunable, &amp;hellip;.
开始运行，运行结束，运行持续是时间
commit， roll back
4. 如何创建对象 编译时就要确定是创建哪一个对象 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/9th_%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/9th_%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>高级知识点 1. 并行计算 将数据拆分到每个节点上 -&amp;gt; 如何拆分 每个节点并行的给出计算结果 -&amp;gt; 中间结果 将结果汇总 -&amp;gt; 如何汇总 2. 外部排序分析 如何排序100G个元素？
只能有一部分数据放到内存
归并排序 将数据分为左右两半，分别归并排序，再把两个有序数据归并 如何归并 归并节点的排序&amp;ndash; K路归并 使用堆实现 Priority Queue **使用Iterable 接口 **
不断获取下一个元素 元素存储/获取方法被抽象, 与归并节点无关 Iterable merge(List&amp;lt; Iterable&amp;gt; sortData); 3. 死锁分析 多线程 线程安全 加锁， 锁的粒度，性能
死锁分析 1void transfer(Account form, Account to, int amount){ 2 synchronized(form){ 3 synchronized(to){ 4 from.setAmount(for.getAmount() - amount); 5 to.setAmount(to.getAmount() + amount) 6 } 7 } 8} synchronized(form) -&amp;gt; 别的线程在等待from
synchronized(to) -&amp;gt; 别的线程已经锁住了to</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/Imooc_react16.4%E5%8F%8A%E5%85%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/Imooc_react16.4%E5%8F%8A%E5%85%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>imooc_React16 快速上手 实现TodoList react简介以及语法基础 react Fiber // React 16 之后的版本对应的框架
redux
react 环境搭建
React 脚手架工具 create-react-app
1npx create-react-app todolist # create-react-app 2cd todolist 3yarn start # npm run start 什么是组件 component
简单的jsx语法 项目代码 1├── src 2│ ├── TodoItem.js 3│ ├── TodoList.js 4│ ├── index.js 5│ ├── serviceWorker.js 6│ └── style.css Index.js Index.js 是项目的入口
1import React from &amp;#39;react&amp;#39;; 2import ReactDOM from &amp;#39;react-dom&amp;#39;; 3import &amp;#39;./style.css&amp;#39;; 4// 组件，大写字母开头 s 5import TodoList from &amp;#39;./TodoList&amp;#39;; 6 7 8ReactDOM.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/0_Category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/0_Category/</guid>
      <description>3rd_数据库架构 5th_Linux </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/10th_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/10th_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/11th_Java%E6%A1%86%E6%9E%B6Spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/11th_Java%E6%A1%86%E6%9E%B6Spring/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/12th_%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/12th_%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/2nd_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/2nd_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</guid>
      <description>计算机网络面试核心 7. HTTP 简介 超文本传输协议的主要特点 是应用层的请求响应的无状态协议
支持客户/服务器模式 ： 浏览器通过url向服务端发送请求， 服务端返回响应信息 简单快速 ： 请求方法 get post delete 通讯速度快 灵活： 数据格式灵活，允许任意格式的数据类型 无连接： 每次连接只处理一个请求，收到应答之后就断开连接 ， 1.1 之后使用了长连接 下层实现对上层透明， keep alive 无状态： 对事务处理没有记忆能力，缺少状态， version 1.1 引入了 keep alive 持续连接机制 2.0 升级成本太大 HTTP 请求结构 HTTP请求报文结构
1GET /baidu/com HTTP1.1 2 Host: www.baidu.com 3 Connection:keep-alive # close 1.1之前 4 User-Agent： Mozilla/5.0 5 Accept-Encoding 6Cookie: XXX HTTP响应结构 1HTTP 1.1 200 OK 2	Server: 3	Accept-Ranges: 4	Content-Type: 5	Content-Languge: 6	Content-Length: 7	Date: 请求/响应步骤 客户端连接到WEB服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接： 服务器主动关闭TCP连接，浏览器被动释放TCP连接 客户端浏览器解析HTML内容 在浏览器地址键入http 开头的url，按下回车之后经历的流程 DNS解析 ：逐层查询路由器中的DNS缓存，浏览器-系统-路由器-IPS服务器-根域名服务器缓存-顶级域名服务器缓存，返回对应IP TCP连接：IP+80端口 三次握手 http协议版本 发送HTTP请求： 服务器处理并返回HTTP报文 浏览器解析渲染页面 连接结束 HTTP状态码 1XX：指示信息——表示请求已接收，继续处理</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/3rd_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/3rd_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</guid>
      <description>数据库 1. 数据库架构 关系型数据库的主要考点： 架构、 索引、锁、语法、理论范式
范式一： 列不可再分 范式二： 标准键 范式三： 去除传递依赖
如何设计一个关系型数据库 RDMBS
存储管理：尽可能的减少IO，使用块或者页实现 缓存机制：不宜过大，要有淘汰机制 LRU SQL解析：SQL解析 日志管理：记录操作记录 binlog 权限划分： 容灾机制：处理异常 索引管理： 锁管理：
1. 为什么要使用索引？ 避免全表扫描，快速查询数据
全表扫描 所有的数据分批次加载到内存 索引 - 对应字典的偏旁部首等
2. 什么样的信息能够成为索引 主键、唯一键、普通键等
3. 索引的数据结构 生成索引，建立二叉查找树今次那个二分查找 生成索引，建立B-Tree进行查找
生成索引，建立B+Tree结构进行查找
生成索引，建立Hash结构进行查找
2. 优化索引- 二叉查找树 二叉查找树 二叉查找树：左子节点小于 根节点， 右子节点大于根节点 平衡二叉树： 左右子树深度的差值不超过1
二叉查找树容易变为线性二叉树 即使使用数的旋转也会出现数的深度递增导致IO的次数增加 3. 优化索引- B-Tree 平衡多路查找树 每个节点有至多m个孩子， M阶B树 定义：
根节点至少包括两个孩子 树中每个节点最多含有有M个孩子(m&amp;gt;2) 除根节点和叶节点外，其他每个节点都至少有ceil(m/2)个孩子 所有的叶子节点都位于同一层 假设每个非终端节点中包含有n个关键字信息，其中 Ki(i=1,&amp;hellip;n) 为关键字，且关键字顺序按升序排序Ki-1&amp;lt; Ki 关键字的个数n必须满足：[ceil(m/2) -1]&amp;lt;= n &amp;lt;= m-1 非叶子节点的指针：P[1],P[2],&amp;hellip;P[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1]K[i])的子树。 让每一个节点尽可能存储更多的信息，尽可能的减少数的深度，从而减少IO的次数</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/4th_Redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/4th_Redis/</guid>
      <description>Redis 缓存知识考点 熔断机制： 数据库down掉，可以缓存顶上
缓存中间件-Memcache 和 Redis 的区别 Memcache: 代码层次类似Hash
支持简单数据类型 不支持数据持久化 不支持主从 不支持分片 shard Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快 100000+ QPS(QPS-&amp;gt; query per second, 每秒查询次数)
完全基于内存， 绝大部分请求是纯粹的内存操作， 执行效率高 数据结构简单， 对数据的操作简单 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例 使用多路I/O复用模型，非阻塞I/O 多路I/O 复用模型 FD： File Descriptor , 文件描述符 一个打开的文件通过唯一的描述符进行引用， 该描述符是打开文件的元数据到文件本身的映射。
传统的阻塞IO模型 多路IO复用模型 select 系统调用 Redis采用的IO多路复用函数： epoll【】/kqueue/evport/select &amp;hellip;
因地制宜 优先选用时间复杂度为O(1)的IO多路复用函数作为底层实现 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/5th_Linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/5th_Linux/</guid>
      <description>Linux Linux 的体系结构 体系结构主要分为 用户态(用户上层活动)和内核态 内核： 本质是一段管理计算机硬件设备的程序 系统调用：内核的访问接口，是一种不能再简化的操作。 原子性的操作。 公用函数库： 系统调用的组合拳 Shell:命令解释器， 可编程 windows - cigwin
查看系统调用 Linux - man 2 syscalls less / more / cat /tail
切换默认shell
查找特定的文件 find
语法： find path [options] params 作用： 在指定目录下查找文件 1find ./ -name &amp;#34;fileName&amp;#34; # 精确查找 2find ~ -name &amp;#34;target*&amp;#34; # 模糊查找文件 3find ~ -iname &amp;#34;target*&amp;#34; # 忽略大小写的查找 4man find # 查看find的使用说明 检索文件内容 grep
语法： grep [options] pattern file 全称 Global Regular Expression Print 作用： 用于查找文件里符合条件的字符串, 智慧筛选出目标字符串所在的行 1grep &amp;#34;moo&amp;#34; target* # 查找 target* 开头的文件中包含 &amp;#34;moo&amp;#34; 的行 管道操作符 | 可以将指令连接起来，前一个指令的输出作为后一个指令的输入 只处理前一个命令的正确输出， 不处理错误输出 右边命令必须接收标准输入流，否则传递过程中数据会被抛弃 sed, awk, grep, cut, head, top, less, more, wc, join, sort, split 等 1grep &amp;#39;partial\[true\]&amp;#39; test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/6th_JVM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/6th_JVM/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/7th_GC%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/7th_GC%E7%9B%B8%E5%85%B3/</guid>
      <description>1. 垃圾回收之标记算法 GC
对象被判定为垃圾的标准 没有被其他对象引用 判定对象是否为垃圾的算法 引用计数法 通过判断对象的引用数量决定对象是否可以被回收 每个对象实例都有一个引用计数器，被引用则+1， 完成引用则-1 任何引用计数为0的实例 可以当做垃圾被回收 优点： 执行效率高， 程序受影响比较小 缺点： 无法检测出循环引用的情况，导致内存泄露
可达性分析算法 通过判断对象的引用链是否可达到，来决定对象是否可以被回收
可以作为GC Root的对象：
虚拟机栈中引用的对象（栈帧中的本地变量表） 方法区中的常量引用的对象 方法区中类静态属性引用的对象 本地方法栈中JNI(Native 方法) 的引用对象 活跃线程的引用对象 2. 谈谈你了解的垃圾回收算法 标记-清除法 Mark and Sweep 标记： 从根集合进行扫描，对存活的对象进行标记 清除： 对堆内存从头到尾进行线性遍历，回收不可达对象内存
Mark 阶段 -&amp;gt; Sweep 阶段
存在问题： 碎片化严重，大对象无法找到连续的内存，容易触发下次垃圾回收，outofmemery
复制算法 Coping - 年轻代 适用于对象存活时间比较低的情况
分为对象面和空闲面 对象在对象面上创建 存活对象从对象面复制到空闲面 将对象面所有对象内存清除 有点： 解决了碎片化问题， 顺序分配内存，简单高效，适用于对象存活率低的场景&amp;ndash;年轻代
标记整理法 - 老年代 整理： 移动所有存活的对象，且按内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。
优点： 避免了内存不连续，不用设置两块内存互换，适用于存活率高的场景
分代收集算法 垃圾回收算法的组合拳
按照生命周期的不同划分区域， 以采用不同的垃圾回收算法 提高了JVM的垃圾回收效率 Survivor Partitiion 年轻代 复制算法</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/8th_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/8th_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</guid>
      <description>Java 多线程与并发 1. 进程与线程的区别 关于jdk版本的选择 JDK8,JDK11:Oracle 长期支持
Java线程知识考点 进程和线程的区别 用户态和内核态的转换
进程和线程的由来 串行 初期的计算机只能执行串行执行任务，并且需要长时间等待用户输入
批处理 预先将用户指令集中成清单，批量串行处理用户指令，仍然无法并发执行
进程 进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能
线程 共享进程的内存资源，相互间切换更快捷，支持更细粒度的任务控制，使进程内的子任务得以并发执行
进程和线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位
所有与进程相关的资源，都被记录在PCB中
进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
线程只由堆栈寄存器、程序计数器和TCB组成
总结
线程不能看做独立应用，而进程可以看做独立应用 线程有独立的地址空间， 相互不影响，线程只是进程的不同执行路径 线程没有独立的地址空间，多进程的程序比多线程程序健壮 进程的切换比线程的切换开销大 Java进程和线程的关系 - Java对操作系统提供的功能进行封装，包括进程和线程 - 运行一个程序会产生一个进程，进程包含至少一个线程 - 每个进程对应一个JVM实例，多个线程共享JVM里的堆 - Java采用单线程编程模型，程序会自动创建主线程 - 主线程可以创建子线程，原则上要后于子线程完成执行 2. Thread 中start和run方法的区别 start native 方法 openjdk.java.net
调用start() 方法会创建一个新的子线程并启动 run()方法只是一个Thread的一个普通方法的调用 3. Thread 和Runnable 的区别 Thread 实现了Runnable接口的类，使得run支持多线程 Runnable 只有一个抽象方法run 因为单一继承的原则，推荐多使用Runnable结构 4. 如何给run()方法传参 实现方式主要有三种
构造函数传参 成员变量传参 回调函数传参 如何实现处理线程的返回值 实现方式主要有三种
主线程等待法（有多个变量的时候比较难处理，循环等待的时间是不精确的） 使用Thread的join()方法阻塞当前线程以等待子线程处理完毕(粒度不够细) 通过Callable接口是实现： 通过FutureTask 或者 线程池获取 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/9th_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/9th_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/javabasic/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/javabasic/README/</guid>
      <description>javabasic 课程涉及到的Java代码，持续更新中&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8th_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8th_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/1st_md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/1st_md/</guid>
      <description>算法面试到底是什么鬼？ 1-1 算法面试不仅仅是正确的回答问题 算法面试的目的 展现思考问题的方式 算法面试过程 看做是和面试官一起探讨一个问题的解决方案。对于问题的细节和应用环境，可以和面试官沟通。 这种沟通本身很重要，它暗示着你思考问题的方式。
我们需要对一组数据进行排序。 快速排序算法 O(nlogn)
正确+更优 这组数据有什么样的特征？ 有没有可能包含有大量的重复元素？ 如果有这种可能的话，三路快排是更好的选择。 Java 默认是三路快排。
这组数据有什么样的特征？ 是否大部分数据距离它的正确位置很近？是否近乎有序？ 如果是这样的话插入排序更优
是否数据的取值范围非常有限？比如学生成绩排序。 计数排序更优
对排序有什么额外的要求 是否需要稳定排序 归并排序更优
数据的存储状况是怎样的 如果使用链表存储，归并排序更优
数据的大小是否可以装在内存里， 外部排序
什么是正确的回答一个算法问题
正确还包含对问题的独到见解，容错性，
1-2 算法面试只是面试的一部分 算法面试优秀不意味着技术面试优秀
算法面试只是技术面试的一部分
项目经历和项目中遇到的实际问题
你遇到印象最深的bug是什么？
面向对象
设计模式
网络相关：安全相关，内存相关，并发相关
系统设计： scalability
面试不仅仅是考察技术水平，以及对过去项目的思考
项目经历
通过过去了解你的思考行为方式
遇到的最大的挑战
犯过的错误
遇到的失败
最享受的工作内容
遇到冲突的处理方式
做的最与众不同的事儿
准备好合适的问题问面试官
1-3 如何准备算法面试 避免完美学习
使用时间片学习
远远不需要达到竞赛的水平
不要轻视基础算法和数据结构，而只关注有意思的题目
各种排序算法 技术数据结构和算法的实现： 如堆，二叉树，图 基础数据结构的使用： 如链表、栈、队列、哈希表、图、Tire、并查集 基础算法： 深度优先、广度优先、二分查找、递归 基本算法思想：递归、分治、回溯搜索、贪心、动态规划 选择合适的OJ online judge
leetcode： online portal for interview</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/7th_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%80%92%E5%BD%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/7th_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%80%92%E5%BD%92/</guid>
      <description>二叉树和递归 二叉树天然的递归结构 满二叉树
二叉树的前序遍历 递归实现 1void preOrder(TreeNode node){ 2 if(node==null){ 3 return; // 递归终止条件 4 } 5 System.out.print(node.val); 6 preOrder(node.left); // 递归过程 7 preOrder(node.right); 8} 二叉树的定义：空是一棵二叉树
二叉树总是否包含某个key 1boolean contain(TreeNode node, Key key){ 2 if(node == null){ 3 return false; 4 } 5 if(key == node.key){ 6 return true; 7 } 8 if(contain(node.left,key)|| contain(node.right, key)){ 9 return true; 10 } 11 return false; 12} 1// c++ 释放二叉树的内存 2void destory(TreeNode node){ 3 if(node == null){ 4 return; 5 } 6 destory(node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/9th_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/9th_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划基础 什么是动态规划 斐波那契数列 Fibonacci Sequence 1//时间复杂度 应该是指数级 2int fib(){ 3 if(n==0){ 4 return 0; 5 } 6 if(n==1){ 7 return 1; 8 } 9 return fib(n-1)+fib(n-2); 10} 递归会有很多的重复计算，重复的计算量会非常大。
所以想办法对重复的计算 只计算一次
记忆化搜索-自上而下的解决问题 改进的Fibonacci
1// 记忆化搜索 时间复杂度O(n) 2int memo[]; 3int fib(){ 4 if(n==0){ 5 return 0; 6 } 7 if(n==1){ 8 return 1; 9 } 10 if(memo[n]==-1){ 11 memo[n]=fib(n-1)+fib(n-2); 12 } 13 return memo[n]; 14} 动态规划-自下而上的解决问题 1// 动态规划 2int fib(int n){ 3 vector&amp;lt;int&amp;gt; memo(n+1, -1); 4 memo[0] = 0; 5 memo[1] = 1; 6 for(int i=2; i&amp;lt;n;i++){ 7 memo[i] = memo[i-1]+memo[i-2]; 8 } 9 return memo[n]; 10} 动态规划：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/7th_%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/7th_%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/</guid>
      <description>图 图的表示 邻接矩阵（Adjacent Matrix） 邻接表（Adjacent Matrix） 邻接表适合表示稀疏图（Sparse Graph）
邻接矩阵适合表示稠密图（Dense Graph）
稀疏图 稠密图和完全图 寻路 获得两点之间的一条路径
图的深度优先遍历-时间复杂度
稀疏图（邻接表）：O(V+E)
稠密图（邻接矩阵）：O(v^2^)
深度优先遍历算法-有向图
dfs 查看是否有环- 有向图 广度优先遍历和最短路径 借助队列实现
广度优先遍历求出了无权图的最短路径
图的广度优先遍历-时间复杂度
稀疏图（邻接表）：O(V+E)
稠密图（邻接矩阵）：O(v^2^)
无权图的应用- 迷宫生成，PS抠图 flood fill 魔棒抠图 连通分量
扫雷 走迷宫、 迷宫生成 迷宫的本质是一棵树 本质是一个生成树的过程
不能只用一种方式遍历， 随机队列遍历
欧拉路径 哈密尔顿路径 二分图 同学选课
地图着色 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/8th_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/8th_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>最小生成树 Minimum Span Tree 有权图 Weight Graph 邻接矩阵 Adjacent Matrix 邻接表 使用Edge 表示每一条连接边
最小生成树问题和切分定理 带权无向图、连通图
找V-1条边
切分定理 Cut Property 把图中的节点分成两部分，成为一个切分(Cut)
如果一个边的两个端点，属于切分不同的两边，这个边成为横切边(Crossing Edge);
切分定理：
给定任意切分，横切边中权值最小的边必然属于最小生成树
Prim算法 Lazy Prim Lazy Prim 最小堆中依然有不会是横切边的边。
Lazy Prim 的时间复杂度为O(ElogE)
Prim 算法优化 时间复杂度O(ElogV)
IndexMinHeap
Kruskal算法 使用并查集
使用Union Find 快速判断环
最小生成树问题 最小生成树问题思考
Lazy Prim O(ElogE)
Prim O(ElogV)
Kruskal O(ElogE)
如果横切边有相等的边
根据具体的算法实现，每次选择一个边
此时，图存在多个最小生成树
Vyssotsky’s Algorithm
将边逐渐添加到生成树中
一旦形成环，删除环中权值最大的边</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/9th_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/9th_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>最短路径 路径最短问题和松弛操作（Relaxation） 最短路径问题 Shortest Path 路径规划 城市，路由
工作任务规划
广度优先遍历 -&amp;gt; 最短路径树 Shortest Path Tree
单源最短路径 Single Source Shortest Path
无权图的最短路径
松弛操作是求最短路径的核心
Dijkstra 算法的思想 dijkstra 单源最短路径算法 前提： 图中不能有负权边
复杂度 O(ElogV)
负权边和Bellman-Ford算法 拥有负权环的图，没有最短路径
Bellman-Ford 单源最短路径算法 前提：图中不能有负权环
Bellman-Ford 判断图中是否有负权环
复杂度O(EV)
如果一个图没有负权环，从一个点到另一个点的最短路径，最多经过所有的V个顶线，有V-1条边。否则存在定点经过了两次，即存在负权环。
对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小。
如果一个图没有负权环，从一个点到另外一个点的最短路径，最多经过所有的V个顶线，有V-1条边。
对所有的点进行V-1次松弛操作。
对所有的点进程V-1次松弛操作，理论上就找到了从源点到其他所有点的最短路径。
如果还可以继续松弛，就说明原图中有负权环
##更多和最短路径相关的思考</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/category/</guid>
      <description>imooc_算法与数据结构综合提升篇 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</guid>
      <description>二叉树的序列化和反序列化 二叉树-&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/CAS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/CAS/</guid>
      <description>CAS 和 ABA 问题 在多并发程序设计中，我们不得不面对并发、互斥、竞争、死锁、资源抢占等问题，归根结底就是读写的问题，有了读写才有增删改查，才有一切。同样也有了谁读谁写、这样的顺序和主次问题，于是就有了上锁，乐观锁和悲观锁、同步和异步、睡眠和换入换出等问题，归根结底就是模拟了社会的分工协作与资源共享的抢占，要理解好这些现象的本质，我们需要更加深刻的进行类比和辨析。要知道这些内容的本质就是内存和CPU之间的故事，有时候还会有一些外存和其他缓存。
https://www.cnblogs.com/zyrblog/p/9864932.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/IO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/IO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</guid>
      <description>RandomAccessFile 不同于FileInputStream和FileOutputStream,不是他们的子类 当我们想对一个文件进行读写操作的时候，创建一个指向该文件的RandomAccessFile流就可以了 ； 但是对于OutputStream和DataOutputStream，我们在使用的时候都是通过他们的构造方法来附加或更新文件，即在构造方法中new FileOutputStream；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java-%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java-%E5%BC%82%E5%B8%B8/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>Java8 新特性 Java8 速度更快，代码更少，强大的Stream API，便于并行 最大化减少空指针异常 optional
Lambda表达式 Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java的语言表达能力得到了提升。
从匿名类到Lambda 的转换 1// 匿名内部类 2Runnable r1 = new Runnable(){ 3 @Override 4 public void run(){ 5 System.out.println(&amp;#34;Hello world&amp;#34;); 6 } 7} 8 9//Lambda 表达式 10Runnable r1 = () -&amp;gt; System.out.println(); 11 12//原来使用匿名内部类作为参数传递 13TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(new Comparator&amp;lt;String&amp;gt;(){ 14 @Override 15 public int compare(String o1, String o2){ 16 return Integer.compare(o1.length(), o2.length()); 17 } 18}); 19 20//Lambda 表达式作为参数传递 21TreeSet&amp;lt;String&amp;gt; ts2 = new TreeSet&amp;lt;&amp;gt;( 22	(o1, o2) -&amp;gt; Integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/JavaIO/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/JavaIO/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>Java 虚拟机 虚拟机调优 Java 虚拟机调优参数 -Xms 起始内存 JVM堆内存 -Xmx 最大内存 JVM堆内存 -Xmn 新生代内存 -Xss 栈大小。 就是创建线程后，分配给每一个线程的大小 -XX:NewRatio 设置年轻代和老年代的比值。默认为2:1。如果为3，表示年轻代与老年代的比值为1:3，年轻代占整个年轻代和老年代的1/4。 -XX:SurvivorRatio年轻代中Eden区和两个Survivor区的比值。如果为3，表示Eden:Survivor = 3:2, 因为有两个Survivor区域，所以一个Survivor区占整个年轻代的1/5. -XX:MaxPermSize设置持久代的大小。 收集器的设置
-XX:+UseSerialGC设置串行收集器 -XX:+UseParallelGC设置并行收集器 -XX:+UseParallelOld设置并行老年代收集器 -XX:+UseConcMarkSweepGC设置并发收集器 垃圾回收统计信息
-XX:PrintGC -XX:PrintGCDetails -XX:PrintGCTimeStamps -Xloggc:filename 并行收集器设置
-XX:ParallelGCThreads=n设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n设置并行收集最大暂停时间 -XX:GCTimeRatio=n设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置
XX:+CMSIncrementalMode设置为增量模式。适用于单CPU情况。 XX:ParallelGCThreads=n设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 -Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3
-Xms1G JVM初始内存1G 这一部分是不是应该是堆内存 -Xmx2G JVM最大内存 2G -Xmn500M 新生代内存 500M -XX:MaxPermSize 持久代内存 64M -XX:SurvivorRatio=3 新生代中Eden:Servivor = 3:2 JVM 调优 -Xms2G -Xmx2G 将JVM最大内存与初始内存设置相等，避免JVM垃圾回收后重新分配内存。 -Xmn1G 年轻代内存Sun官方推荐配置为整个堆的3/8,通常设置为1/3或1/4。 -Xss256K减小每条线程栈的大小，能生成更多的线程 -XX:NewRatio=4 调整年轻代与老年代的比例 年轻代:老年代=1:4 -XX:MaxTenuringThreshold=0 设置晋升到老年代的对象的年龄。 如果设置为0，则年轻代对象不经过Survivor区，直接进入老年代。如果设置一个较大的值，则年轻代对象会在Survivor区进行多次复制。 -XX:+UseConcMarkSweepGC JVM在server模式下默认使用PararrelScavenge＋SerialOld的收集器组合进行内存回收，不支持与用户线程并发执行。可使用ParNew+CMS+SerialOld的收集器组合进行内存回收（SerialOld收集器做为CMS收集器出现ConcurrentModeFailure失败后的后备收集器使用），减少stop-the-world时间。 -XX:CMSFullGCsBeforeCompaction 使用CMS时，设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java%E9%9B%86%E5%90%88%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java%E9%9B%86%E5%90%88%E7%B1%BB/</guid>
      <description>Java 集合类 线程安全与线程不安全 参考链接 https://www.cnblogs.com/williamjie/p/9099141.html
https://www.cnblogs.com/heyonggang/p/9112731.html
https://blog.csdn.net/andy_budd/article/details/81413464
https://blog.csdn.net/wufaliang003/article/details/80219296
https://blog.csdn.net/VIP_WangSai/article/details/70182933
https://blog.csdn.net/qq_41216743/article/details/101311040
https://blog.csdn.net/cn12306com/article/details/81318871
相关面试题 1. 举例说明List 、Set、HashMap是线程不安全的 List ​ 我们知道ArrayList 是线程不安全的，请编写一个不安全的案例并给出解决方案？对于List我们使用的大多数场景是在单线程下，如果在高并发的情况下，便会出现一些线程不安全的问题
1public class ContainerNotSafeDemo { 2 public static void main(String[] args) throws InterruptedException { 3 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 4 5// 3种解决方案 6// List&amp;lt;String&amp;gt; list = new Vector&amp;lt;&amp;gt;(); 7// List list = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;()); 8// List list = new CopyOnWriteArrayList(); 9 10 for (int i = 0; i &amp;lt; 30; i++) { // 30 个线程，每一个线程都有对list的写与读操作 11 new Thread(() -&amp;gt; { 12 list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程 ​
守护线程 Java的main是普通线程，并不是守护线程，
守护线程会等待所有的线程执行结束后再结束
线程同步 https://www.jianshu.com/p/2394317257ec
https://www.jianshu.com/p/988bfceadb62
https://www.jianshu.com/p/6f98f03430eb
https://www.cnblogs.com/williamjie/p/9099141.html
Java 主线程等待所有子线程执行完毕 Java 主线程等待所有子线程执行完毕再执行。
用sleep() 让主线程睡眠一段时间，但是这个睡眠时间是主观设置的，是有我们自己主观设定的，所以不推荐使用。
1public static void main(String[] args) throws InterrupteException{ 2 for(int i=0; i&amp;lt;5;i++){ 3 new Thread( 4 new Runnable(){ 5 public void run(){ 6 try{ 7 Thread.sleep(1000); 8 }catch(InterruptException e){ 9 e.preintStrackTrace(); 10 } 11 System.out.println(&amp;#34;子线程执行！&amp;#34;); 12 } 13 } 14 ).start(); 15 } 16 Thread.sleep(5000); 17 System.out.println(&amp;#34;主线程执行！&amp;#34;); 18} 使用Thread的jion()等待所有的子线程执行完毕，主线程再执行，thread.jion()把指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在B中调用了线程A的jion()方法，直到线程A执行完毕后，才会继续执行线程B。
1public static void main(String[] args) throws InterrupteException{ 2 Vector&amp;lt;Thread&amp;gt; threadVector = new Vector&amp;lt;&amp;gt;(); 3 for(int i=0; i&amp;lt;5;i++){ 4 Thread childThread = new Thread( 5 new Runnable(){ 6 public void run(){ 7 try{ 8 Thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式 单例模式 一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。
getInstance()的返回值是一个对象的引用，并不是一个新的实例。
双重校验锁 1public class Singleton{ 2 private volatile static Singleton singleton; 3 private Singleton(){} 4 public static Singleton getSingleton(){ 5 if(singleton == null){ 6 synchronized(Singleton.class){ 7 if(singleton==null){ 8 singleton = new singleton; 9 } 10 } 11 } 12 } 13} 观察者模式 对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
https://mp.weixin.qq.com/s/sdj9DcnZZNRiWssgygiTTw
装饰者模式 对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。
适配器模式 工厂模式 ##代理模式</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</guid>
      <description>字节跳动面试题总结 1. 进程创建的过程 进程的创建过程可分为以下步骤： （1）申请空白的PCB。 进程控制块 描述信息，控制信息，资源信息，CPU现场 （2）为新进程分配资源。 （3）初始化PCB。 （4）将进程插入就绪队列。
2. linux 文件管理系统 inode(发音：eye-node)译成中文就是索引节点，它用来存放档案及目录的基本信息，包含时间、档名、使用者及群组等。
node inode
inode（即index node，索引节点）是类Unix OS中保存文件系统中的对象元数据的数据结构。
https://www.jianshu.com/p/d60a2b44e78e
3.数据库事务 数据库事务
隔离级别
脏读
不可重复读
幻读
丢失修改</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%9D%A2%E8%AF%95/</guid>
      <description>小红书面试 如何判断单链表有环
1public boolean IsLoop(Node head){ 2 Node fast = head; 3 Node slow = head; 4 if(head = null){ 5 return false; 6 } 7 8 while(fast != null&amp;amp;&amp;amp; slow ！= null){ 9 fast = fast.next.next; 10 slow = slow.next; 11 if(fast = slow){ 12 return true; 13 } 14 } 15 16 return false; 17} 三次握手， 为什么要三次
A -&amp;gt; B SYN=1, seq = x;
A &amp;lt;- B SYN = 1, ACK=1, seq = y, ack = x+1;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/10th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/10th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>10 每日一面 java 中 throws Exception和 catch Exception的区别 AB转账问题，保持数据一致性 TreeMap如何保证有序 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/11th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/11th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>11 每日一面 Ucloud
rpc
sql优化，如何解决高并发
explain 慢查询，建索引
什么方式实现缓存，什么情况下需要用到token,token失效怎么办等
主从复制
数据库四种隔离级别，分别举例子，每种在上一种的基础上加了什么锁(很简单不说了)
Tcp，坚持计时器。keepalive计时器。
写了一个shell命令，列出重复数据。awk+unique+sort很简单也不说了。
网络协议 计算机网络五层协议：物理层、数据链路层、网络层、传输层、应用层
计算机网络的七层OSI协议： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
路由器属于网络层
网卡与交换机数据数据链路层
TCP和UDP TCP 是面向连接的字节流服务，对系统资源要求比较多。程序结构复杂，保证数据的正确性和顺序性。
UDP是无连接的，面向数据报，对系统的资源要求比较少，程序结构简单，不能保证数据的正确性和顺序性
网站安全与防护
sql 注入
使用例如PDO的预处理，使用或者编写类似mysql_real_escape_string的方法对sql的特殊字符进行转义
**XSS（cross site script）**跨站脚本攻击
将外部脚本植入到页面中
**CSRF(cross-site request forgey)**跨站请求伪造
伪造受信任的用户信息来请求网站
算法相关
冒泡排序
选择排序
​	快速排序
快速排序思想：通过一趟排序将序列分成两部分，一部分所有数据比另一部分所有数据小，然后在这两个序列的内部再分别进行快速排序操作，直到最后形成一个有序序列
二分插入排序思想(之前的序列为有序)：插入第i个元素时，对前面的0~i-1进行折半，当前元素与中间元素比较，如果小，前半部分再次折半，如果大，后半部分进行折半，直到最后left&amp;gt;right,然后把目标位置到i-1的所有元素整体后移，把当前元素放进去
基本查找算法：
顺序查找
二分法查找(折半查找)：将序列分为两部分，找到序列的中间值，如果查找值大于中间值，继续对右半部分进行折半，如果查找值小于中间值，对左半部分进行折半，直到找到或front&amp;gt;end结束，时间复杂度O(log2n)以2为底n的对数
设计模式
MVC是一种设计框架，而不是设计模式，框架是比模式更高的概念
model负责数据逻辑
controller负责用户交互
view负责数据显示流程：
用户对控制器的某个方法发出请求，控制器调用相应的模型返回数据，然后将数据渲染到视图中返回给用户
单例模式i. 私有化构造方法和__clone方法ii. 提供公有的静态的方法返回实例iii. 提供私有的静态属性保存实例
简单工厂模式(重点在创建不同对象，作用就是用来创建对象的) - 例如一个计算器的加减乘除求余取整i. 定义抽象基类让子类分别继承并实现相应方法ii. 定义Factory工厂类里面提供静态方法用于根据不同的参数实例化相应的子类对象
策略模式(重点在于实例化不同类的解决策略不同，作用是根据不同的情况调用相应的策略或算法) - 例如qq普通用户 vip svip购买皮肤的优惠策略i. 定义抽象基类让子类分别继承并实现相应的方法ii. 根据不同的场景实例化相应的类，然后调用其中的方法获取结果
观察者模式
i. 需要有一个抽象的主题接口和一个抽象的观察者接口
ii. 实现一个主题，实现多个观察者</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/1st_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/1st_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>1. 每日一面 蚂蚁金服一面
Java 容器有哪些，哪些是同步容器，哪些是并发容器 ArrayList 和LinkedList 的插入和访问的时间复杂度 java反射原理， 注解原理 新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？ HashMap在什么情况下回扩容，或者有哪些操作会导致扩容？ HashMap put方法的执行过程 HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？ 1.8 还采用了红黑树，讲讲红黑树的特性，为什么人家一定要用红黑是而不是AVL，B树之类的； https 和http 的区别，有没有用过其他安全传输手段？ 线程池的工作原理，几个重要参数，然后给了具体几个参数分析线程池会怎么做，最后问阻塞队列的作用是什么？ Linux怎么查看系统负载情况？ 请详细描述SpringMVN处理请求全流程 Spring 一个Bean 的装配过程 讲一讲AutomicInteger 为什么要用CAS而不是synchronized？ 线程会单独拷贝一份数据到自己的工作空间，只有sync代码块被执行完才会将数据从工作内存刷到主内存，所以，指令重排为什么会导致多线程数据不一致的问题，应该是volatile的内存可见性是解决数据不一致问题的原因</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/2nd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/2nd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>2 每日一面 美团一面
最近做的比较熟悉的项目是哪一个，画一下项目技术架构图 JVM老年代和新生代的比例 YGC和FGC发生的具体场景 jstack，jmap，jutil分别的意义？ 如何线上排查JVM的相关问题 线程池的构造类的方法的5个参数的具体意义？ 单机上一个线程池正在处理服务如果突然断电怎么办（正在处理和阻塞在队列里的请求怎么处理）？ 使用无界阻塞队列会出现什么问题？ 接口如何处理重复请求？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/3rd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/3rd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>3 每日一面 百度一面
介绍一下集合框架 HashMap 和hashtable 底层实现什么区别？ HashTable 和ConcurrentHashTable 区别？ HashMap 和TreeMap 什么区别？底层数据结构是什么？ Synchronized 和 Lock 什么区别？synchronized 什么情况是对象锁，什么时候是全局锁 ThreadLocal 是什么？底层是如何实现的？写一个例子 volitile的工作原理 cas 如何实现的 至少用四种方法实现一个单例模式 请介绍一个JVM的内存模型？用什么样的垃圾回收器 线上发送频繁full GC如何处理？CPU使用率过高怎么办 如何定位问题？如何解决，说一下解决思路和处理方法 知道字节码吗？字节码都有哪些？Integer x=5；int y=5；比较x=y都经过哪些步骤？ 讲讲类加载机制？有哪些类加载器，这些类加载器加载哪些文件？ 手写类加载Demo 知道osgi吗？他是如何实现的 请问你做过哪些JVM优化？使用什么方法达到什么效果？ Class.forName(&amp;ldquo;java.lang.String&amp;rdquo;) 和String.classGetClassLoader() LoadClass(&amp;ldquo;java.lang.String&amp;rdquo;) 什么区别 四种垃圾回收算法
七种垃圾回收器</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/4th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/4th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>4.每日一面 携程面试
问项目， 注意项目细节
Netty
BIO 同步阻塞IO，一个线程只有一个连接
NIO 同步非阻塞IO ，一个线程有多个连接，一个线程中有很多Channel，通过selector 选择线程
AIO 异步非阻塞IO
双重检验单例
1public class Singleton{ 2 private volatile static Singleton singleton; 3 private Singleton(){ 4 5 } 6 public Singleton getSingleton(){ 7 if(singleton == null){ 8 synchronized(Singleton.class){ 9 if(singleton == null){ 10 singleton = new Singleton(); 11 } 12 } 13 } 14 return singleton; 15 } 16} http1.1 长连接， 心跳包， http2 http3
HTTP 1.1 支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理,在一个TCP连接上可以传送多个HTTP请求，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP 1.0 每次请求都要创建连接的缺点。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/5th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/5th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>5 每日一面 今日头条
HashMap如果一直put元素会怎么样？hashCode全都相同如何？ 重写equals时候为什么要重写hash方法 ApplicationContext 的初始化过程？初始化过程发现循环依赖Spring 是如何处理 GC用什么收集器？收集过程如何？哪些部分可以作为GC Root？ Volatile关键字，指令重排序有什么意义？synchronize怎么用？ 并发包里的原子类有哪些，怎么实现？cas在cpu级别是怎么实现的 Redis数据结构有哪些？如何实现Sorted set？这种数据结构在极端情况下 系统设计题：一个推送场景。50条内容，定时推送，先推5%用户，……设计相关库表，系统模块 MySQL索引是什么数据结构？B-Tree有什么特点？有点是什么 慢查询怎么优化 项目 cache 各部分职责，有哪些优点 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/6th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/6th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>6 每日一面 Dubbo超时重试？Dubbo超时时间设置 如何保障请求顺序执行 分布式事务与分布式锁（扣款不要出现负数） 分布式session设置 执行某操作，前50次成功，第51次失败，a全部回滚，b前50次提交第51次抛异常，a b场景分别如何设置Spring？（传播特性） Zookeeper有哪些作用 JVM内存模型 数据库垂直和水平拆分 MyBatis如何分页；如何设置缓存;MySql分页 熟悉IO吗？与NIO的区别，阻塞和非阻塞 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/7th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/7th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>7 每日一面 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/8th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/8th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>8 每日一面 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/9th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/9th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>9 每一日面 字节跳动
很荣幸字节跳动一路走到了四面，不管是运气还是实力，都好好准备接下来的面试吧，加油
编程 判断字符串B是否是字符串A的子串 数据结构中的桶排序、平衡二叉树 .手撕代码：机器人跳跃(牛客原题） 手撕代码：逆时针打印矩阵（剑指offer改） 合并两个有序链表，空间复杂度O(1)； DP最长回文串； 给两个1T的文件在2g ram的内存中找出相同项。 给一个有向图，判断有向图中是否有环，如果有环，环的数量是多少？ 给一个大小为n的数组，寻找比k小的最大数的位置。 1.最长回文子串 地图上有若干个点，怎样得到某个点到达某个点的所有的换乘路线 ？ 是否是联通，如果不连通怎么处理 给你一个字符串，字符串当中是一段c语言的代码和注释，注释只有/** /这样的可以嵌套，不包含// 请返回去除所有注释的代码 如果代码当中的/*和/*可以不完全匹配如何告知出现错误 写了一个程序，有个小球，球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10 次落地时，共经过多少米？第 10 次反弹多高？ 写代码：火车售票系统是早7点-晚23点进行网上售票，写一个程序判断是否可以进行网上买票 讲一下二叉搜索树，写节点的删除代码 最大连续子序列和 代码：实现lru，不会哦临时想了一种lgn的实现，面试官不满意 写一个最小堆建堆，分析复杂度 多个串，将含有相同字母的串放到同一个集合，返回集合向量 讲思路 编程：36进制加法（忘记处理最高位的进位，面试官提醒了一下） 在一亿个数中找出最大的10个数，在一亿个数中找出中间的10个数 编程：将0-n的整数放到一个长度为n的数组中，找出缺失的那个数 编程：36进制加法（又来？） 题目：n条直线可以将空间划分为多少个区域 面试题 TCP 和UDP
进程和线程
设计模式
MySQL索引的数据结构
进程间的通信方式
设计一个存储海量评论的结构，要求大量数据的写入，可以随意翻页？
熟悉计算机和网络原理，熟悉操作系统原理，对存储、队列、计算、集群管理中的一项或多项有深入的理解和认识；
常用的排序算法的复杂度，写快排；
Java的JVM的内存布局，垃圾回收的实现，回收器分几部分，都有什么作用；
项目大体阐述下，用了哪些技术、设计模式，最大的感受是什么；十分钟实现用过的观察者模式、工厂模式；
TCP四次挥手讲下？为什么有TIME_WAIT？ TCP比UDP多消耗哪些系统资源？
A(FIN_WAIT_1) -&amp;gt; B(CLOSE_WAIT) FIN=1,seq = u
A(FIN_WAIT_2)&amp;lt;-B ACK=1, seq=v,ack=u+1;
A &amp;lt;-B(LAST_ACK) FIN=1,seq = w,ack=u+1;
A(TIME_WAIT) ACK=1 ,seq=u+1,ack=w+1;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>#计算机操作系统
基本特征 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
操作系统通过引入进程和线程，使得程序能够并发运行。
共享 共享是指系统中的资源可以被多个并发进程共同使用。
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。
基本功能 进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。
内存管理 内存分配、地址映射、内存保护与共享、虚拟内存等。
文件管理 文件存储空间的管理、目录管理、文件读写管理和保护等。
设备管理 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。
Linux 的系统调用主要有以下这些：
Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 大内核和微内核 大内核 大内核是将操作系统功能作为一个紧密结合的整体放到内核。
由于各模块共享信息，因此有很高的性能。
微内核 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。
在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。
因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。
中断分类 外中断 由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid>
      <description>线程同步 线程同步的概念 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。
在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
线程有可能和其他线程共享一些资源，比如，内存，文件，数据库等。
当多个线程同时读写同一份共享资源的时候，可能会引起冲突。这时候，我们需要引入线程“同步”机制，即各位线程之间要有个先来后到，不能一窝蜂挤上去抢作一团。
线程同步的真实意思和字面意思恰好相反。线程同步的真实意思，其实是“排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。
线程同步的方式和机制 临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。
信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制。
临界区 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。
1）关键段共有初始化、销毁、进入和离开关键区域四个函数。
2）关键段可以解决线程的互斥问题，但因为具有“线程所有权”，所以无法解决同步问题。
3）推荐关键段与旋转锁配合使用。
互斥量 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。
1）互斥量是内核对象，它与关键段都有“线程所有权”所以不能用于线程的同步。
2）互斥量能够用于多个进程之间线程互斥问题，并且能解决某进程意外终止所造成的“遗弃”问题。 3、信号量：信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目
信号量 在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。
事件对象 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作
1）事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。
2）事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。
3）事件可以解决线程间同步问题，因此也能解决互斥问题。
线程同步的方法 (1)wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
(2)sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException异常。
(3)notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的 唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
(4)notityAll ():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁， 而是让它们竞争。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「Java」</title>
      <link>https://airren.github.io/interview/JavaNote/Automic-%E5%8E%9F%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Automic-%E5%8E%9F%E5%AD%90%E7%B1%BB/</guid>
      <description>Automic 原子类 1 Atomic 原子类介绍 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所以，所谓原子类说简单点就是具有原子/原子操作特征的类。
并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。
根据操作的数据类型，可以将JUC包中的原子类分为4类
基本类型
使用原子的方式更新基本类型
AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类 数组类型
使用原子的方式更新数组里的某个元素
AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray ：引用类型数组原子类 引用类型
AtomicReference：引用类型原子类 AtomicReferenceFieldUpdater：原子更新引用类型里的字段 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型
AtomicIntegerFieldUpdater:原子更新整型字段的更新器 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 CAS ABA 问题
描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。 例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！ 代码例子（以AtomicInteger为例） 1import java.</description>
    </item>
    
    <item>
      <title>「NIO」网络IO</title>
      <link>https://airren.github.io/interview/cs_basic/net_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/cs_basic/net_io/</guid>
      <description>NIO
epoll linux
mac
windows</description>
    </item>
    
    <item>
      <title>「计算机网络」 计算机网络串讲</title>
      <link>https://airren.github.io/interview/cs_basic/network_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/cs_basic/network_basic/</guid>
      <description>网络硬件 双绞线 类型 五类线CAT5 超五类线CAT5e 六类线CAT6 超六类线CATT6e 七类线CAT7 频率带宽 100MHz 100MHz 200MHz 500MHz 600MHz 传输速率 100Mbps 1000Mbps 1000Mbps 1Gbps 10Gbps 最大长度 100m 100m 100m 55m 屏蔽类型 屏蔽/非屏蔽 屏蔽/非屏蔽 屏蔽/非屏蔽 屏蔽/非屏蔽 双层屏蔽 双绞线线序 直通，交叉(主要用于对等设备的通信)
标准 1 2 3 4 5 6 7 8 EIA/TIA 568A 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕 EIA/TIA 568B 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕 </description>
    </item>
    
  </channel>
</rss>
