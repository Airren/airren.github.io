<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daily on ByteGopher</title>
    <link>https://airren.github.io/interview/daily/</link>
    <description>Recent content in Daily on ByteGopher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 29 Dec 2018 11:02:05 +0800</lastBuildDate><atom:link href="https://airren.github.io/interview/daily/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://airren.github.io/interview/daily/2021-04-21-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-04-21-/</guid>
      <description>package main
import &amp;ldquo;fmt&amp;rdquo;
var testMap = map[string]map[string]struct { Name string }{ &amp;ldquo;first&amp;rdquo;: {&amp;ldquo;second&amp;rdquo;: {Name: &amp;ldquo;12312&amp;rdquo;}}, &amp;ldquo;second&amp;rdquo;: {&amp;ldquo;second&amp;rdquo;: {&amp;ldquo;12312&amp;rdquo;}}, }
func main() { d := testMap[&amp;ldquo;first&amp;rdquo;][&amp;ldquo;second&amp;rdquo;].Name fmt.Printf(&amp;quot;++-%v-++\n&amp;quot;, d)
c := testMap[&amp;quot;first22&amp;quot;][&amp;quot;second&amp;quot;].Name fmt.Printf(&amp;quot;++-%v-++\n&amp;quot;, c) }title: 2021-04-21 Socket
https://www.cnblogs.com/wmx-learn/p/5312259.html</description>
    </item>
    
    <item>
      <title>「Daily」TaskList</title>
      <link>https://airren.github.io/interview/daily/TaskList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/TaskList/</guid>
      <description>TaskList 最短路径算法
最小生成树
深度优先遍历、广度优先遍历
KMP算法
LRU
哈弗曼树
go知识学习 参考这个文档，完整的学习一边go
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/
context 春招目标
依图
PDD
字节跳动
浦发</description>
    </item>
    
    <item>
      <title>2021-03-12</title>
      <link>https://airren.github.io/interview/daily/2021-03-12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-12/</guid>
      <description>Golang
以下代码的输出内容 1package main 2import ( 3	&amp;#34;fmt&amp;#34; 4) 5 6func main() { 7	deferCall() 8} 9func deferCall() { 10	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; before&amp;#34;) }() 11	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; in process&amp;#34;) }() 12	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; done&amp;#34;) }() 13	panic(&amp;#34;&amp;lt;&amp;lt;&amp;lt; panic here&amp;#34;) 14} 输出结果如下
1&amp;gt;&amp;gt;&amp;gt; done 2&amp;gt;&amp;gt;&amp;gt; in process 3&amp;gt;&amp;gt;&amp;gt; before 4panic: &amp;lt;&amp;lt;&amp;lt; panic here defer执行的顺序是后进先出, 压栈。当出现panic的时候，会按照defer的后进先出的顺序执行，最后才会执行panic。
defer是一个压栈过程。
这段代码的输出，以及原因 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	slice := []int{0, 1, 2, 3} 7	m := make(map[int]*int) 8 9	for key, val := range slice { 10	m[key] = &amp;amp;val 11	} 12 13	for k, v := range m { 14	fmt.</description>
    </item>
    
    <item>
      <title>2021-03-13</title>
      <link>https://airren.github.io/interview/daily/2021-03-13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-13/</guid>
      <description>Golang
下面两段代码输出什么 1// 1. 2 func main() { 3 s := make([]int, 5) 4 s = append(s, 1, 2, 3) 5 fmt.Println(s) 6 } 7 8// 2. 9 func main() { 10 s := make([]int,0) 11 s = append(s,1,2,3,4) 12 fmt.Println(s) 13} 输出结果如下
1[0 0 0 0 0 1 2 3] 2[1 2 3 4] 使用make 新建 slice 会根据初始化的容量补0
这段代码的问题 1 func funcMui(x,y int)(sum int,error){ 2 return x+y,nil 3 } 有多个返回值的时候，返回值的名字要么全部省略，要么全部写上</description>
    </item>
    
    <item>
      <title>2021-03-14</title>
      <link>https://airren.github.io/interview/daily/2021-03-14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-14/</guid>
      <description>Golang
使用channel实现简单并发，注意执行顺序
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sync&amp;#34; 6	&amp;#34;time&amp;#34; 7) 8 9var wg sync.WaitGroup 10 11func printer(ch chan int) { 12	for i := range ch { 13	fmt.Printf(&amp;#34;Received %d \n&amp;#34;, i) 14	&amp;lt;-time.After(time.Second / 5) 15	fmt.Printf(&amp;#34;Job %v done \n&amp;#34;, i) 16	} 17	println(&amp;#34;All Jobs done&amp;#34;) 18	wg.Done() 19	println(&amp;#34;Finished&amp;#34;) 20} 21 22// main is the entry point for the program. 23func main() { 24	c := make(chan int) 25	go printer(c) 26	wg.</description>
    </item>
    
    <item>
      <title>2021-03-15</title>
      <link>https://airren.github.io/interview/daily/2021-03-15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-15/</guid>
      <description>Golang
获取变量的数据类型
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;reflect&amp;#34; 6) 7 8func main() { 9 10	// string type : string 11	var1 := &amp;#34;hello world&amp;#34; 12 13	// integer : int 14	var2 := 10 15 16	// float : float64 17	var3 := 1.55 18 19	// boolean : bool 20	var4 := true 21 22	// shorthand string array declaration : []string 23	var5 := []string{&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;} 24 25	// map is reference datatype : map[string]string 26	var6 := map[int]string{100: &amp;#34;Ana&amp;#34;, 101: &amp;#34;Lisa&amp;#34;, 102: &amp;#34;Rob&amp;#34;} 27 28	// complex64 and complex128 29	// is basic datatype : complex128 30	var7 := complex(9, 15) 31 32	// using %T format specifier to 33	// determine the datatype of the variables 34 35	fmt.</description>
    </item>
    
    <item>
      <title>2021-03-16</title>
      <link>https://airren.github.io/interview/daily/2021-03-16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-16/</guid>
      <description>Golang
同时定义多个相关的struct, 这样写可读性更好一些
1type ( 2	// item defines the fields associated with the item tag 3	// in the rss document. 4	item struct { 5	XMLName xml.Name `xml:&amp;#34;item&amp;#34;` 6	PubDate string `xml:&amp;#34;pubDate&amp;#34;` 7	Title string `xml:&amp;#34;title&amp;#34;` 8	Description string `xml:&amp;#34;description&amp;#34;` 9	Link string `xml:&amp;#34;link&amp;#34;` 10	GUID string `xml:&amp;#34;guid&amp;#34;` 11	GeoRssPoint string `xml:&amp;#34;georss:point&amp;#34;` 12	} 13 14	// image defines the fields associated with the image tag 15	// in the rss document.</description>
    </item>
    
    <item>
      <title>2021-03-17</title>
      <link>https://airren.github.io/interview/daily/2021-03-17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-17/</guid>
      <description>Golang
1// A map of registered matchers for searching. 2var matchers = make(map[string]Matcher) 3 4// Run performs the search logic. 5func Run(searchTerm string) { 6	// Retrieve the list of feeds to search through. 7	feeds, err := RetrieveFeeds() 8	if err != nil { 9	log.Fatal(err) 10	} 11 12	// Create an unbuffered channel to receive match results to display. 13	results := make(chan *Result) 14 15	// Setup a wait group so we can process all the feeds.</description>
    </item>
    
    <item>
      <title>2021-03-xx</title>
      <link>https://airren.github.io/interview/daily/2021-03-xxxx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-xxxx/</guid>
      <description>Golang</description>
    </item>
    
    <item>
      <title>2021-04-20</title>
      <link>https://airren.github.io/interview/daily/2021-04-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-04-20/</guid>
      <description>Flush
清空缓冲区
首先，咱们设想要给鱼缸换水，所以需要一个水泵，水泵是连接鱼缸和下水道的，咱们的任务就是将鱼缸里面水全抽干，这时，我们就可以把水管当做缓冲区。如果咱们一见鱼缸里面水抽干了就立马关了水泵，这时会发现水管里还有来不及通过水泵流向下水道的残留水，我们可以把抽水当做读数据，排水当做写数据，水管当做缓冲区，这样就容易明白了。
那么这样一来我们如果中途调用close()方法，输出区也还是有数据的，就像水缸里有水，只是在缓冲区遗留了一部分，这时如果我们先调用flush()方法，就会强制把数据输出，缓存区就清空了，最后再关闭读写流调用close()就完成了。
缓冲区可以简单地理解为一段内存区域。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。
https://blog.csdn.net/qq_38129062/article/details/87115620</description>
    </item>
    
    <item>
      <title>2021-04-21</title>
      <link>https://airren.github.io/interview/daily/2021-03-21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-21/</guid>
      <description>Flush
清空缓冲区
首先，咱们设想要给鱼缸换水，所以需要一个水泵，水泵是连接鱼缸和下水道的，咱们的任务就是将鱼缸里面水全抽干，这时，我们就可以把水管当做缓冲区。如果咱们一见鱼缸里面水抽干了就立马关了水泵，这时会发现水管里还有来不及通过水泵流向下水道的残留水，我们可以把抽水当做读数据，排水当做写数据，水管当做缓冲区，这样就容易明白了。
那么这样一来我们如果中途调用close()方法，输出区也还是有数据的，就像水缸里有水，只是在缓冲区遗留了一部分，这时如果我们先调用flush()方法，就会强制把数据输出，缓存区就清空了，最后再关闭读写流调用close()就完成了。
缓冲区可以简单地理解为一段内存区域。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。
https://blog.csdn.net/qq_38129062/article/details/87115620</description>
    </item>
    
    <item>
      <title>2021-05-20</title>
      <link>https://airren.github.io/interview/daily/2021-05-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-20/</guid>
      <description> 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5var testMap = map[string]map[string]struct { 6	Name string 7}{ 8	&amp;#34;first&amp;#34;: {&amp;#34;second&amp;#34;: {Name: &amp;#34;12312&amp;#34;}}, 9	&amp;#34;second&amp;#34;: {&amp;#34;second&amp;#34;: {&amp;#34;12312&amp;#34;}}, 10} 11 12func main() { 13	d := testMap[&amp;#34;first&amp;#34;][&amp;#34;second&amp;#34;].Name 14	fmt.Printf(&amp;#34;++-%v-++\n&amp;#34;, d) 15 16 17 // map 不会报 nil 18	c := testMap[&amp;#34;first22&amp;#34;][&amp;#34;second&amp;#34;].Name 19	fmt.Printf(&amp;#34;++-%v-++\n&amp;#34;, c) 20} 结果
1++-12312-++ 2++--++ </description>
    </item>
    
    <item>
      <title>2021-05-26</title>
      <link>https://airren.github.io/interview/daily/2021-05-26/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-26/</guid>
      <description>rwarestse ewartawe
-gcflags=-l
1. 线上的配置文件写在了哪里 1GOMAXPROCS = 8 2TSDB_HOST = bytetsd-query-server-prod-ppe-va.byted.org 3 4 5# influxdb 配置 本地如何调试 一些特殊的token的解析 NaNAsZero, not_sliteral_or, nullAsZero 是否还可以rebase bosun开源版本 ui fenbu cs Trace bytetrace
expr （context） trace 对齐其他语言的框架， 例如ginex context
state &amp;ndash;&amp;gt; context
inf.bytesd.bosun
Log slog
Error errors 业务状态码
err
静态
非200
5001 执行失败，动态参数解析失败， duration， 计算错误
5002 runtime panic
5003 panic string
对齐trace
新加的一些函数 funcs.go
pprof 8071</description>
    </item>
    
    <item>
      <title>2021-05-26</title>
      <link>https://airren.github.io/interview/daily/2021-05-27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-27/</guid>
      <description>rwarestse ewartawe
-gcflags=-l
1. 线上的配置文件写在了哪里 1GOMAXPROCS = 8 2TSDB_HOST = bytetsd-query-server-prod-ppe-va.byted.org 3 4 5# influxdb 配置 本地如何调试 一些特殊的token的解析 NaNAsZero, not_sliteral_or, nullAsZero 是否还可以rebase bosun开源版本 ui fenbu ssssTrace bytetrace
expr （context） trace 对齐其他语言的框架， 例如ginex context
state &amp;ndash;&amp;gt; context
inf.bytesd.bosun
Log slog
Error errors 业务状态码
err
静态
非200
5001 执行失败，动态参数解析失败， duration， 计算错误
5002 runtime panic
5003 panic string
对齐trace
新加的一些函数 funcs.go
pprof 8071</description>
    </item>
    
    <item>
      <title>2021-06-01</title>
      <link>https://airren.github.io/interview/daily/2021-06-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-06-01/</guid>
      <description>sync.pool</description>
    </item>
    
  </channel>
</rss>
