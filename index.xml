<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ByteGopher</title>
    <link>https://airren.github.io/</link>
    <description>Recent content on ByteGopher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://airren.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「Gin」Gin入门</title>
      <link>https://airren.github.io/tech/web/gin/gin_overview/</link>
      <pubDate>Fri, 21 Aug 2020 00:43:48 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/gin/gin_overview/</guid>
      <description>学好一个框架或者一门语言，最好的方法就是要学会看官方的Document。几乎所有的博客只是把自己对官方文档的理解重新加工整理出来而已，增加了自己的主管想法。
刚入门的时候面对英文文档可能一头雾水，但是当你坚持下来，你会发现，这些官方文档写的要比那些博客好的多，表述精确的多。
以后我的文章会主要参考官方文档展开介绍，顺带加一点自己的理解
GitHub
Official Document
1. Gin 简介 The fastest full-featured web freamwork for Go. Crystal clear.
快 支持中间件 Crash还原 JSON验证 路由分组 错误日志收集 模板渲染 可扩展 2. 快速用Gin搭建一个Web服务 1go get -u github.com/gin-gonic/gin # install Gin 2 3mkdir gin_demo &amp;amp;&amp;amp; cd gin_demo 4 5vi main.go main.go的内容如下
1package main 2 3import ( 4	&amp;#34;net/http&amp;#34; 5	&amp;#34;github.com/gin-gonic/gin&amp;#34; 6 7) 8 9func main(){ 10	r := gin.Default() 11 12	r.GET(&amp;#34;/ping&amp;#34;, func(c *gin.Context){ 13	c.</description>
    </item>
    
    <item>
      <title>「Go」依赖管理 Go Modues/ GOPATH</title>
      <link>https://airren.github.io/note_go/1_go_modules/</link>
      <pubDate>Tue, 04 Aug 2020 23:53:48 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_go_modules/</guid>
      <description>不要吝啬你的批评与感悟，敬请留言，我们一起进步。
如果你有过以下问题，欢迎阅读文章，提出意见与建议
go mod 怎么使用？ GOPATH是什么？ GO111MODULE=&amp;quot;&amp;quot; 这个参数决定了什么？ go get、go download 有什么区别？ import到底import的什么东西？ 依赖管理工具 用过Java 的同学都知道，对依赖的管理经历了从原始的手动引入jar包，到使用maven等自动化管理工具去引入第三方依赖的过程，从而可以使用别人已经开发好的优秀工具。如果使用过Python的同学可能会熟练的使用pip install 第三方的工具包。Java 和Python的第三方工具包都是集中式管理的，使用maven 或者是pip 都是从对应的管理中心下载更新依赖。当然还有 npm、yarn、gradle等其他语言的依赖版本工具。
在go语言中，第三方依赖的管理工具经过了一个漫长的发展过程。在GO1.11 发布之前govendor、dep等工具百花齐放。直到go mod 出现，开始一统天下。go 的依赖非常简单粗暴，只要依赖源码就可以了。例如：
1import &amp;#34;github.com/jinzhu/gorm&amp;#34; github.com/jinzhu/gorm 就是gorm的GitHub项目路径。
GOPATH时期 Go 在1.11 之前使用GOPATH模式进行依赖的管理。安装部署go环境，使用go 进行开发的时候强制被要求要设置GOPATH（当然安装过程中也会默认指定$GOPATH=~/go）。 要在GOPATH路径下新建 /src /bin /pkg文件夹。
1➜ ~/go 2├── bin # 存储go编译生成的二进制可执行文件，一般会把该路径配置到PATH中,PATH=$PATH:$GOPATH/bin 3├── pkg # 存储预编译的目标文件，以加快后续的编译速度 4└── src # 存储Go的源代码，一般以$GOPATH/src/github.com/foo/bar的路径存放 1➜ ~ go env |grep GOPATH 2GOPATH=&amp;#34;/Users/bytedance/go&amp;#34; 在这种模式下，如果使用go get 拉取外部依赖会自动下载并安装到$GOPATH/src 目录下。
这种模式下，go get没有版本管理的概念，无法处理依赖不同版本的问题，因为同一个依赖都存在同一个路径下面。
在Go官方还没有推出Go Modules 的时候，go的依赖管理工具可谓是百花齐放，例如 govendor， dep，但是最终Go Modules发布，平息了诸侯割据的局面。</description>
    </item>
    
    <item>
      <title>「Gin」Gin Http 请求处理</title>
      <link>https://airren.github.io/tech/web/gin/gin_http/</link>
      <pubDate>Tue, 08 Sep 2020 00:01:52 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/gin/gin_http/</guid>
      <description>https://www.yoytang.com/go-gin-doc.html#%e8%b7%af%e7%94%b1(Router)
1. Gin的HTTP请求 1.1 Gin支持的各种HTTP请求 1func main() { 2	// Creates a gin router with default middleware: 3	// logger and recovery (crash-free) middleware 4	router := gin.Default() 5 6	router.GET(&amp;#34;/someGet&amp;#34;, getting) 7	router.POST(&amp;#34;/somePost&amp;#34;, posting) 8	router.PUT(&amp;#34;/somePut&amp;#34;, putting) 9	router.DELETE(&amp;#34;/someDelete&amp;#34;, deleting) 10	router.PATCH(&amp;#34;/somePatch&amp;#34;, patching) // 11	router.HEAD(&amp;#34;/someHead&amp;#34;, head) // 12	router.OPTIONS(&amp;#34;/someOptions&amp;#34;, options) 13 14	// By default it serves on :8080 unless a 15	// PORT environment variable was defined. 16	router.</description>
    </item>
    
    <item>
      <title>「Gin」 项目目录</title>
      <link>https://airren.github.io/tech/web/gin/project_category/</link>
      <pubDate>Wed, 23 Sep 2020 00:07:14 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/gin/project_category/</guid>
      <description>Gin 项目目录 1├─ Project Name 2│ ├─ config //配置文件 3│ ├── ... 4│ ├─ controller //控制器层，验证提交的数据，将验证完成的数据提交给service 5│ ├── ... 6│ ├─ service //业务层， 只完成业务逻辑得开发，不进行数据库的操作 7│ ├── ... 8│ ├─ repository //数据库操作层 dal/ dao; 数据库操作层，写，多表插入，多表查询，不写业务代码 9│ ├── ... 10│ ├─ model //数据库ORM 11│ ├── ... 12│ ├─ entity //实体 写返回数据的结构体。写controller层方法参数验证的结构体 13│ ├── ... 14│ ├─ proto //proto文件 写 gRPC 的 *.pb.go 文件。 15│ ├── ... 16│ ├─ router //路由 17│ ├── middleware //路由中间件 （鉴权，日志，异常捕获） 18│ ├── .</description>
    </item>
    
    <item>
      <title>「Go」并发实现</title>
      <link>https://airren.github.io/note_go/8_go_concurrency/</link>
      <pubDate>Wed, 05 Aug 2020 00:14:06 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/8_go_concurrency/</guid>
      <description>如何用go实现一个简单的并行任务
Golang并发 1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sync&amp;#34; 6) 7 8var wg sync.WaitGroup 9 10func printer(ch chan int) { 11	for i := range ch { 12	fmt.Printf(&amp;#34;Received %d &amp;#34;, i) 13	} 14	wg.Done() // 15} 16 17// main is the entry point for the program. 18func main() { 19	c := make(chan int) 20	go printer(c) 21	wg.Add(1) 22 23	// Send 10 integers on the channel.</description>
    </item>
    
    <item>
      <title>「Go」context</title>
      <link>https://airren.github.io/note_go/7_go_context/</link>
      <pubDate>Tue, 11 Aug 2020 23:53:48 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/7_go_context/</guid>
      <description>context.Context用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与Goroutine有非常密切的关系。
1type Context interface{ 2 Deadline()(deadline time.Time, ok bool) 3 Done() &amp;lt;-chan struct{} 4 Err() error 5 Value(key interface{}) interface{} 6} context.Context有四个方法：
Deadline() 返回context.Context被取消时间，也就是完成工作的截止日期；
Done() 返回一个channel，这个channel 会在当前工作完成或者上下文被取消后关闭，多次调用Done方法返回的是同一个channel；
Err() 返回context.Context 结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值
如果 context.Context 被取消，会返回Canceled错误；
如果 context.Context 超时，会返回DeadlineExceeded错误；
Value 从context.Context 中获取键对应的值。对同一个上下文来说，多次调用value并传入相同的key会返回相同的结果，该方法用来传递请求特定的数据。
1func main() { 2	ctx := context.Background() // new empty context 3 4	ctx = context.WithValue(ctx, &amp;#34;org&amp;#34;, &amp;#34;ali&amp;#34;) 5	ctx, _ = context.WithCancel(ctx) 6	ctx, _ = context.WithDeadline(ctx, time.Now().Add(10*time.Second)) 7	ctx, _ = context.</description>
    </item>
    
    <item>
      <title>Resultados de Búsqueda</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description>
    </item>
    
    <item>
      <title>Resultados de Búsqueda</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>Este archivo existe únicamente para responder a la URL /search con la plantilla de diseño search relacionada.
No se muestra ningún contenido aquí, todo el contenido se basa en la plantilla layouts/page/search.html
Establecer una prioridad muy baja en el mapa del sitio le dirá a los motores de búsqueda que éste no es un contenido importante.
Esta implementación utiliza Fusejs, jquery y mark.js
Configuración inicial La búsqueda depende del tipo de contenido de salida adicional de JSON en config.</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>অনুসন্ধানের ফলাফল</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>অনুসন্ধানের ফলাফল</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Tue, 08 Jun 2010 08:06:25 +0600</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>「Raft」 The Raft Consensus Algorithm</title>
      <link>https://airren.github.io/blog/raft/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/raft/</guid>
      <description>12 123 https://raft.github.io/
https://www.infoq.com/presentations/raft-consensus-algorithm/
https://www.geeksforgeeks.org/raft-consensus-algorithm/
https://www.hashicorp.com/resources/raft-consul-consensus-protocol-explained</description>
    </item>
    
    <item>
      <title>「Bosun」 Bosun入门简介</title>
      <link>https://airren.github.io/component/TimeSeries/Bosun/bosun_intro/</link>
      <pubDate>Wed, 25 Nov 2020 00:29:08 +0800</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/Bosun/bosun_intro/</guid>
      <description>Bosun, Time Series, and OpenTSDB&amp;rsquo;s DataModel An introduction to the data model of Bosun&amp;rsquo;s Primary time series backend OpenTSDB. Time Series, Metircs and Tags, Aggregation, Rate Calculation, and Downsampling are covered. These features are demoed using Bosun&amp;rsquo;s graphing interface.
Time Series A Series of observations , each recorded as a Time and Date with an associated Value.
1Observation on 08-22-2015 10:20:01 of 10 2Observation on 08-22-2015 10:20:15 of 20 3Observation on .</description>
    </item>
    
    <item>
      <title>数据结构与算法动态规划</title>
      <link>https://airren.github.io/DataStruct/ds_dp/</link>
      <pubDate>Thu, 17 Sep 2020 00:53:15 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_dp/</guid>
      <description>动态规划：
子问题 状态定义 DP方程 </description>
    </item>
    
    <item>
      <title>post</title>
      <link>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_aggregation/</link>
      <pubDate>Wed, 09 Sep 2020 01:14:54 +0000</pubDate>
      
      <guid>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_aggregation/</guid>
      <description>https://www.cnblogs.com/-flq/p/9519276.html https://www.cnblogs.com/xuwujing/archive/2020/02/29/12385903.html
https://www.elastic.co/guide/en/elasticsearch/client/go-api/current/index.html https://www.jianshu.com/p/6e28c967d872</description>
    </item>
    
    <item>
      <title>「ElasticSearch」 ElasticSearch 简单查询</title>
      <link>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_query/</link>
      <pubDate>Mon, 07 Sep 2020 20:23:25 +0000</pubDate>
      
      <guid>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_query/</guid>
      <description>查询语句
query bool must exist &amp;ldquo;exists&amp;rdquo;: { &amp;ldquo;field&amp;rdquo;: &amp;ldquo;name&amp;rdquo; } 判断字段是否存在 must_not match &amp;ldquo;match&amp;rdquo;: { &amp;ldquo;tweet&amp;rdquo;: &amp;ldquo;elasticsearch&amp;rdquo; } 匹配字符串中是否包含 should Filter 简单查询 查询某个字段是否存在或者是否为null 1curl -H &amp;#39;Content-type: application/json&amp;#39; -XPOST &amp;#39;http://ip:9200/alert_group/_search&amp;#39; -d 1{ 2 &amp;#34;query&amp;#34;: { 3 &amp;#34;bool&amp;#34;: { 4 &amp;#34;must&amp;#34;: { // must_not 5 &amp;#34;exists&amp;#34;: { 6 &amp;#34;field&amp;#34;: &amp;#34;name&amp;#34; // 必须存在该字段，且该字段不为null 7 } 8 } 9 } 10 } 11} 空查询（empty search） {}在功能上等价于使用 match_all 查询， 正如其名字一样，匹配所有文档：
1curl -X GET &amp;#34;localhost:9200/_search?pretty&amp;#34; -H &amp;#39;Content-Type: application/json&amp;#39; -d&amp;#39; 2{ 3 &amp;#34;query&amp;#34;: { 4 &amp;#34;match_all&amp;#34;: {} 5 } 6} 7&amp;#39; Match 1GET /_search 2{ 3 &amp;#34;query&amp;#34;: { 4 &amp;#34;match&amp;#34;: { 5 &amp;#34;tweet&amp;#34;: &amp;#34;elasticsearch&amp;#34; 6 } 7 } 8} 复合查询 组合多条件查询。elasticsearch提供bool来实现这种需求；</description>
    </item>
    
    <item>
      <title>【微服务】有状态服务和无状态服务</title>
      <link>https://airren.github.io/tech/web/micro_service/stateless_service/</link>
      <pubDate>Wed, 02 Sep 2020 21:11:24 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/micro_service/stateless_service/</guid>
      <description>什么是有状态服务？
什么是无状态服务？
有状态服务和无状态服务分别适用的场景
参考资料
https://www.iteye.com/blog/kyfxbl-1831869
https://www.cnblogs.com/xiangkejin/p/9010516.html
https://www.zhihu.com/question/54437341</description>
    </item>
    
    <item>
      <title>「Go」slice</title>
      <link>https://airren.github.io/note_go/5.3_go_slice/</link>
      <pubDate>Wed, 02 Sep 2020 11:40:22 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.3_go_slice/</guid>
      <description>Slice的坑 1numList := make([]int, 10) 2// 产生的numList会存入10个0， 如果继续append 数据会导致numList的数据超过10 Slice 扩容
1func TestSliceExtend(t *testing.T) { 2	capacity := 0 3	list := make([]int, 0) 4	for i := 0; i &amp;lt; 4096; i++ { 5	list = append(list, i) 6	if capacity != cap(list) { 7	times := float64(cap(list)) / float64(capacity) 8	differ := cap(list) - capacity 9	capacity = cap(list) 10	if times == 2.0 { 11	fmt.Printf(&amp;#34;capacity is: %d \t times: %.</description>
    </item>
    
    <item>
      <title>「Production」提高生产力的常用软件</title>
      <link>https://airren.github.io/tools/software/software_production_list/</link>
      <pubDate>Fri, 28 Aug 2020 00:11:32 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/software/software_production_list/</guid>
      <description>绘图工具 OmniGraffle 说明 好用的绘图工具 下载 教程 https://sspai.com/post/41950 https://www.jianshu.com/p/cca7ce55aee1 系统工具 iStat Menus 说明 优秀的系统监控工具 下载 https://www.macwk.com/soft/istat-menus 教程 https://sspai.com/post/41950 https://www.jianshu.com/p/cca7ce55aee1 </description>
    </item>
    
    <item>
      <title>「Git」 Git 工作区&amp;暂存区&amp;本地仓库&amp;远程仓库以及基本操作</title>
      <link>https://airren.github.io/tools/git/git_stage_repo/</link>
      <pubDate>Wed, 26 Aug 2020 01:12:13 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/git/git_stage_repo/</guid>
      <description>Git 数据存储的基本概念 WorkSpace: 工作区，编辑修改文件的区域
Index/Stage: 暂存区， 未提交修改
Repository： 本地仓库
Remote： 远程仓库
我们使用编辑器写代码的区域就是WorkSpace, 执行git add fileName之后，就将修改的文件提交到了暂存区，执行git commmit -m &amp;quot;update fineName&amp;quot; 之后就将修改提交到了本地版本库。最后使用 git push 将修改提交到远程仓库。
Git 常用操作 配置用户名以及邮箱 设置
1git config --global user.Name &amp;#34;name&amp;#34; 2git config --global user.email &amp;#34;xxx@outlook.com&amp;#34; 查看
1git config user.name 2git config user.email 初始化Git仓库 git init 1git init fileName 2# or 不指定路径，默认为当前路径 3git init 初始化仓库后，会生成一.git的隐藏文件夹
建立裸仓库
1git init --bare bare_repo 对比正常git仓库normal_repo与bare_repo的目录结构发现，在normal_repo/.git 文件夹中的文件直接出现在了bare_repo 中
切换分支。
在一个裸仓库中执行git命令会提示this operation must be run in a work tree。因为裸仓库是没有工作区的，只会记录git提交的历史信息，git log可以查看提交历史，但是没有办法进行版本回退或者切分分支的操作。</description>
    </item>
    
    <item>
      <title>「HTTP」HTTP 9 种请求方式</title>
      <link>https://airren.github.io/tech/web/RPC/http/http_request_method/</link>
      <pubDate>Fri, 21 Aug 2020 01:37:37 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/RPC/http/http_request_method/</guid>
      <description>HTTP简介 HTTP协议（HyperText Transfer Protocol， 超文本传输协议），是一个基于TCP/IP通信协议来传输数据。是用于从服务器传输超文本到本地浏览器的协议。HTTP使用同一资源标识符（Uniform Resource Identifiers, URL）来传输数据和建立连接。
HTTP协议工作于客户端-服务端（C-S）架构上。浏览器作为HTTP客户端通过URL向服务端发送请求，并获得返回数据。
HTTP特点：
HTTP是无连接的： 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。
HTTP是无状态的： HTTP是无状态协议。无状态是指协议对于事务处理灭有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次传输的数据量增大。
HTTP是媒体独立的： 任何数据类型都可以通过HTTP发送，客户端以及服务器要指定相同的MIME-type类型。媒体类型通常通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的。例如：Content-Type：text/HTML。通常只有广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。
Web-Browser &amp;lt;===&amp;gt; HTTP Server &amp;lt;===&amp;gt; CGI(Common GateWay Interface) Program &amp;lt;==&amp;gt;Database
客户端请求消息 请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成
服务器响应消息 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
不带Body 的请求 1# 请求消息 2GET /health HTTP/1.1 3Host: 127.0.0.1:8080 4User-Agent: curl/7.65.3 5Accept: */* 6 7# 返回消息 8HTTP/1.1 200 OK 9Content-Type: text/plain; charset=utf-8 10Date: Sat, 22 Aug 2020 17:56:22 GMT 11Content-Length: 2 12 13ok 带Body的请求 1# 请求消息 2GET /health?</description>
    </item>
    
    <item>
      <title>「Mongo」Bson vs Json</title>
      <link>https://airren.github.io/component/DataBase/mongo/bson/</link>
      <pubDate>Thu, 20 Aug 2020 10:36:54 +0000</pubDate>
      
      <guid>https://airren.github.io/component/DataBase/mongo/bson/</guid>
      <description>https://docs.mongodb.com/manual/reference/bson-types/
http://bsonspec.org/
https://www.mongodb.com/json-and-bson
https://www.educba.com/json-vs-bson/\
https://www.geeksforgeeks.org/difference-between-json-and-bson/</description>
    </item>
    
    <item>
      <title>「Go」Go的安装以及介绍</title>
      <link>https://airren.github.io/note_go/1_go_basic_cmd/</link>
      <pubDate>Thu, 20 Aug 2020 01:40:04 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_go_basic_cmd/</guid>
      <description>1. Go语言介绍 1.1 Go 语言特点 静态类型、编译型的开源语言
静态类型是指要明确变量的类型，或者编译器可以推导出变量的类型。要么在变量类型旁边指定变量的那个类型，要么是可以推导出变量类型。
编译型是指要编译成机器语言。
1package main 2func main(){ 3 // Declare the type of the variable 4 var num1 int = 1; 5 // Deduce the type of the variable 6 num2 :=2 7} 脚本化的语法，支持多种范式编程
函数式&amp;amp;面向对象
原生、给力的并发编程支持
注意： 原生支持和函数库支持的区别
1.2 Go语言的优势和劣势 优势
脚本化的语法 静态类型+编译型，程序运行速度有保障 原生的支持并发编程 - 降低开发、维护成本；程序可以更好的执行 劣势
语法糖并没有Python和Ruby那么多- 1成是开发时间，9成维护时间 目前的程序运行速度还不及c，但是目前已经赶超了C++和Java 第三方库函数暂时不像绝对主流的编程语言那样多 1.3 Go开发环境 Linux 下的安装 FreeBSD Linux Windows 32bit - 64bit
Linux 下的设置方法
有四个环境变量需要设置： GOROOT、GOPATH、GOBIN以及PATH</description>
    </item>
    
    <item>
      <title>「Bosun」开源报警系统</title>
      <link>https://airren.github.io/component/TimeSeries/Bosun/bosun/</link>
      <pubDate>Tue, 18 Aug 2020 00:43:44 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/Bosun/bosun/</guid>
      <description>使用bosun之前首先要了解什么是时序数据，时序数据的组成部分以及时序数据的常用查询
Bosun安装
1docker run -d --name bosun -p 4242:4242 -p 8070:8070 stackexchange/bosun:latest 123123
时序数据的类型 counter
guage(store)
Bosun的数据类型 Scalar NumberSet： Group+Scalar Bosun 查询语法 简单查询 查询过去10分钟到过去1分钟之间的时序数据
avg是时序数据库的的运算，对不同的tag set的数据求平均
最外面的avg 是对这段时间内的时序数据做一个平均，得到一个数值
宏替换 ![
](./bosun/image-20200831202225643.png)
运算的时候会对变量进行宏替换
OpenTSDB
如果没有数据的时候会导致bosun查询失败，可以采取不上
1avg(100*q(&amp;#34;avg:1m-avg-zero:store:toutiao.tce.sysprobe.aweme.recommend.predict.cpu.usage.pod{sidecar_psm=ad.qa.java_sidecar,pod_name=dp-cb2f23ec64-6987c9d65d-ds7j5}&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;&amp;#34;)/q(&amp;#34;avg:1m-avg:store:toutiao.tce.sysprobe.aweme.recommend.predict.cpu.limit.pod{sidecar_psm=ad.qa.java_sidecar,pod_name=dp-cb2f23ec64-6987c9d65d-ds7j5}&amp;#34;,&amp;#34;1h&amp;#34;,&amp;#34;&amp;#34;)) Streak 连续非0 数据的最大长度
https://blog.csdn.net/lslxdx/article/details/79454916
转置
http://bosun-alarm-cn.byted.org/expr?expr=Cgoka2V5PSJzdW06ZGF0YS51bmlvbl9hZC51bmlvbl9wcmVkaWN0LnBheXRpbWVzXzdkYXlzLmZpbmFsLmNvdW50ZXJ7cGFja2FnZT0qfSIKCiMgJGNvdW50ID0gY291bnQoJGtleSwiNm0iLCIxbSIpCiMgJGNvdW50IAojICR2YWx1ZT0gc3VtKHQoYXZnKHEoJGtleSwiNm0iLCIxbSIpKSwgIiIpKQojJHZhbHVlCiMgJHJlcz0gJHZhbHVlLyRjb3VudAojICRyZXMKdChhdmcocSgka2V5LCI2bSIsIjFtIikpLCAiY2x1c3RlciIpCgo%3D
InfluxDB 1influx(&amp;#34;iaas_metrics&amp;#34;, &amp;#39;&amp;#39;&amp;#39;SELECT sum(value) FROM &amp;#34;host_CpuSystem&amp;#34; group by &amp;#34;resource_id&amp;#34; &amp;#39;&amp;#39;&amp;#39;, &amp;#34;7d&amp;#34;, &amp;#34;2m&amp;#34;, &amp;#34;1m&amp;#34;) 参考文档 https://blog.csdn.net/lslxdx/article/details/79454916</description>
    </item>
    
    <item>
      <title>「ElasticSearch」ElasticSearch安装</title>
      <link>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_install/</link>
      <pubDate>Tue, 18 Aug 2020 00:35:51 +0000</pubDate>
      
      <guid>https://airren.github.io/component/NoSQL/ElasticSearch/elasticsearch_install/</guid>
      <description>1. Docker 安装ElasticSearch 1docker search elasticsearch 1docker pull elasticsearch # 默认会拉取 latest 版本 2docker pull elasticsearch:6.8.11 # https://hub.docker.com/ 版本查找 3docker images # 查看本地images 1 docker run -d --name elasticserarch_1 -p 9200:9200 -p 9300:9300 elasticsearch:6.8.11 1docker ps 1curl http://devbox:9200/ 2. docker 安装Cerebro 1docker search cerebro # test 1docker pull lmenezes/cerebro 1docker run -d -p 9002:9000 \ 2--restart=unless-stopped \ 3--name cerebro \ 4-v /etc/localtime:/etc/localtime \ 5-v cerebro:/opt/cerebro \ 6-h cerebro \ 7lmenezes/cerebro 86f036de7c87672903c88f6590d40d052e8c7b79767e410e35b1f2162c268b63f docker run 参数说明</description>
    </item>
    
    <item>
      <title>「Alfred」Tips</title>
      <link>https://airren.github.io/tools/software/Alfred/</link>
      <pubDate>Mon, 17 Aug 2020 10:42:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/software/Alfred/</guid>
      <description>Alfred下载链接 Download: https://www.macwk.com/soft/alfred-4
JetBrains工作流配置 Jetbrains workflow: https://github.com/bchatard/jetbrains-alfred-workflow</description>
    </item>
    
    <item>
      <title>「Kafka」Kafka安装</title>
      <link>https://airren.github.io/component/MessageQueue/kafka_install/</link>
      <pubDate>Mon, 17 Aug 2020 10:42:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/MessageQueue/kafka_install/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「LogStash」LogStash安装</title>
      <link>https://airren.github.io/component/NoSQL/ElasticSearch/logstash_install/</link>
      <pubDate>Mon, 17 Aug 2020 10:42:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/NoSQL/ElasticSearch/logstash_install/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「Mongo」Mongo golang sdk</title>
      <link>https://airren.github.io/component/DataBase/mongo/mongo_go_sdk/</link>
      <pubDate>Mon, 17 Aug 2020 10:42:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/DataBase/mongo/mongo_go_sdk/</guid>
      <description>mongo 基本数据类型 Type bosun.E type E struct { Key string Value interface{} } E represents a BSON element for a D. It is usually used inside a D. bosun.D type D []E D is an ordered representation of a BSON document. This type should be used when the order of the elements matters, // such as MongoDB command documents. If the order of the elements does not matter, an M should be used instead.</description>
    </item>
    
    <item>
      <title>「TSDB」术语</title>
      <link>https://airren.github.io/component/TimeSeries/OpenTSDB/tsdb_argot/</link>
      <pubDate>Mon, 10 Aug 2020 00:24:13 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/OpenTSDB/tsdb_argot/</guid>
      <description>RRD(Round Robin Database) RRD 数据库在创建的时候就已经定义好了大小，当存储空间满了之后，又从头开始覆盖旧的数据，适用于存储和时间序列相关的数据。RRD的大小可控，且不用维护。
A specialized storage system known as a Round Robin Database allows one to store large amounts of series information such as temperatures, network bandwidth, and stock prices with a constant disk footprint. It does this by taking advantage of changing needs for precision. As we will see later, the &amp;ldquo;round-robin &amp;quot; part comes from the basic data structure used to store data points: circular lists.</description>
    </item>
    
    <item>
      <title>「坚持」 做好每一件事</title>
      <link>https://airren.github.io/life/nice_day/</link>
      <pubDate>Sun, 09 Aug 2020 02:05:38 +0000</pubDate>
      
      <guid>https://airren.github.io/life/nice_day/</guid>
      <description>思想和身体至少有一个在路上
不要做一个行尸走肉
如果一件事做不到100分，那和没做有什么分别
抬头看路，低头做事</description>
    </item>
    
    <item>
      <title>「Linux」 user</title>
      <link>https://airren.github.io/tools/linux/user/</link>
      <pubDate>Sun, 09 Aug 2020 01:40:02 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/user/</guid>
      <description>用户和用户组 groups 1groups &amp;lt;user1&amp;gt; &amp;lt;user2&amp;gt; &amp;lt;user3&amp;gt; # 查看当前用户所属的用户组 </description>
    </item>
    
    <item>
      <title>「Hexo」 搭建部署</title>
      <link>https://airren.github.io/tools/hexo/hexo_create/</link>
      <pubDate>Fri, 07 Aug 2020 01:11:55 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/hexo/hexo_create/</guid>
      <description>Hexo 安装 https://hexo.io/zh-cn/docs/
安装Node.js
安装Git
安装Hexo
1sudo npm install -g hexo-cli 如果在mac中安装报/usr/lib/node_modules/的操作权限问题，执行以下命令。
1sudo chown -R `whoami` /usr/local/lib/node_modules 初始化项目
1hexo init blog 创建完成后，当前目录下会有一个xx_blog的文件夹，具体的文件夹查询官网hexo.io
Hexo 部署到Nginx &amp;amp; Github.io 开发机 在自己写Blog的Pc上安装插件
1yarn add hexo-deployer-git 服务器 在即将部署的服务器上执行以下操作
1yum install git 2 3useradd -m git # 创建一个git用户，用来运行git服务 4 # 新建git用户并非必要，但是为了安全起见，还是用git用户单独来运行git服务 5 6passwd git 设置PC到服务器的git用户免密登录
1# 生成ssh密钥 2ssh-keygen 3# 将公钥添加到server 4ssh-copy-id git@serverIp 在服务器上初始化一个Git仓库
1mkdir -p /var/repo 2ca /var/repo 3git init --bare blog.git # --bare 初始化一个裸仓库，裸仓库没有工作区，只为共享而存在 4chown -R git:git blog.</description>
    </item>
    
    <item>
      <title>「HBase」 简介</title>
      <link>https://airren.github.io/component/TimeSeries/OpenTSDB/hbase_introduction/</link>
      <pubDate>Fri, 07 Aug 2020 01:03:42 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/OpenTSDB/hbase_introduction/</guid>
      <description>HBase 简介 OpensTSDB支持多种底层存储，例如HBase、Cassandra。
HBase是分布式列存储系统，其底层依赖HDFS分布式文件系统。HBase是参考Google BigTable模型开发的，本质上是一个典型的KV存储，适用于海量结构化数据的存储。
HBase的优点：
集群部署，横向扩展方便 容错性高，相同的数据会复制多份，放到不同的节点上 同等硬件，相比传统数据库支持的数量级高 吞吐能力强，写入量高 不足：
只支持单行的事务 查询方式： 只能通过RowKey进行查询或者扫描 HBase 和HDFS的关系？ 全面事务 </description>
    </item>
    
    <item>
      <title>「Go」pprof</title>
      <link>https://airren.github.io/note_go/11_go_testprofile/</link>
      <pubDate>Thu, 06 Aug 2020 00:54:12 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/11_go_testprofile/</guid>
      <description>Test Test 1go test --bench ./ 5s Code coverage 1go test -cover Profile 引发性能问题的原因，=执行时间过长、内存占用过多，以及意外堵塞。
在测试时保存并输出相关数据，进行初次评估 在运行阶段通过web接口获得实时数据，分析一段时间内的健康状况 1go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net/http 服务开启debug 端口
1go tool pprof http://10.152.50.69:9452/debug/pprof/profile\?second\=60 -alloc_space
pprof 常用指令
Web</description>
    </item>
    
    <item>
      <title>「Go」时间</title>
      <link>https://airren.github.io/note_go/5.3go_time/</link>
      <pubDate>Thu, 06 Aug 2020 00:54:12 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.3go_time/</guid>
      <description>UNIX 时间戳 Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
类型 位数 Timestamp Time 秒级 10 1596646807 2020-08-06 01:00:07 毫秒级 13 1596646807000 2020-08-06 01:00:07 Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）
是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。</description>
    </item>
    
    <item>
      <title>「Dash」Tips</title>
      <link>https://airren.github.io/tools/software/Dash/</link>
      <pubDate>Wed, 05 Aug 2020 01:35:26 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/software/Dash/</guid>
      <description>Dash is an API Documentation Browser and Code Snippet Manager. Dash instantly searches offline documentation sets for 200+ APIs, 100+ cheat sheets and more. You can even generate your own docsets or request docsets to be included.
Dash V4 license</description>
    </item>
    
    <item>
      <title>「HTTPS」 Tips</title>
      <link>https://airren.github.io/tech/web/RPC/http/https_tips/</link>
      <pubDate>Fri, 31 Jul 2020 00:37:24 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/RPC/http/https_tips/</guid>
      <description>什么是HTTPS 申请免费SSL 七牛云免费SSL申请 Nginx 部署设置https vi /etc/nginx/nginx.conf
1 server { 2 listen 443 ssl http2 default_server; 3 listen [::]:443 ssl http2 default_server; 4 server_name www.bytegopher.com; # bind the domain name 5 root /var/www/hexo; 6 index index.html index.htm; 7 8 ssl_certificate /etc/nginx/bytegopher.com/bytegopher.com.crt; # absolute path of certificate 9 ssl_certificate_key /etc/nginx/bytegopher.com/bytegopher.com.key; # absolute path of certificate 10 ssl_session_timeout 5m; 11 ssl_protocols TLSv1.1 TLSv1.2; 12 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE; 13 ssl_prefer_server_ciphers on; 14 15 # Load configuration files for the default server block.</description>
    </item>
    
    <item>
      <title>「Nginx」 Tips</title>
      <link>https://airren.github.io/tech/web/RPC/http/nginx_tips/</link>
      <pubDate>Fri, 31 Jul 2020 00:36:14 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/RPC/http/nginx_tips/</guid>
      <description>搭建静态资源服务器 静态资源文件夹
1/root/file Nginx 配置
vi /etc/nginx/nginx.conf
1location /file { # 这个file 跟资源路径的名字没有半毛钱关系，可以不同 2	alias /root/file; # 静态资源的绝对路径 3	autoindex on; # 自动创建目录 4} 为了提高文件的传输效率，降低带宽浪费，可以开启gzip压缩
1gzip on; 2gzip_minPlength 1; # 小于1字节不压缩， 3gzip_comp_level 2; # 压缩级别为2 4gzip_types taxt/plain applicaton/x-javascripts txt/css application/xml image/jpeg image/gif image/png; # 压缩文件类型 重启nginx服务
1nginx -s reload 2# or 3systemctl restart nginx.service 通过浏览器访问资源
此时还有很多小伙伴大概率会遇到403 Forbidden， 试过将资源文件夹设置为777 -R 权限或者chown -R nginx:nginx file。But, still doesn&amp;rsquo;r work。
目前的解决方法是将/etc/nginx/nginx.conf 中的user 设置为root 。</description>
    </item>
    
    <item>
      <title>「Vim」 Tips</title>
      <link>https://airren.github.io/tools/tips/vim_tips/</link>
      <pubDate>Fri, 31 Jul 2020 00:31:02 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/vim_tips/</guid>
      <description>常用配置 vi ~/vimrc
1set nu 2syntax on 3inoremap jj &amp;lt;ESC&amp;gt; # ues &amp;lt;jj&amp;gt; instead of &amp;lt;ESC&amp;gt; Vim 相关配置以及快捷键设置 .vimrc 1&amp;#34; Vim 的默认寄存器和系统剪贴板共享 2set clipboard+=unnamed 3&amp;#34; select模式下复制，文本选中时，按下Ctrl+C，即可复制 4if has(&amp;#34;clipboard&amp;#34;) 5 vnoremap &amp;lt;C-C&amp;gt; &amp;#34;+y 6endif 7 8set nu 9 10syntax on 11inoremap jj &amp;lt;ESC&amp;gt; vim模式 normal &amp;mdash;按v进入&amp;mdash;&amp;gt; visual
normal &amp;ndash;&amp;gt; instert
insert
command
快捷键 (normal) 移动 命令 功能 shift + 6 切换行首 shift + 4 切换到行尾 gg 跳转到首行行首 shift+g 跳转到末行行首 w 下一个单词 b 上一个单词 e 移动到词尾 删除 命令 功能 x 向后删除一个字符 X 向前删除一个字符 nx 连续向后删除n个字符 dd 删除当前行 ndd 删除光标所在的连续向下n行 d1G 删除光标所在到第一行所有的数据 dG 删除光标所在到最后一行的所有数据 dw 删除光标之后的单词剩余部分。 d$ 删除光标之后的该行剩余部分。 删除包含特定字符的行</description>
    </item>
    
    <item>
      <title>「Hexo」Write Tips</title>
      <link>https://airren.github.io/tools/hexo/hexo_write_tips/</link>
      <pubDate>Wed, 29 Jul 2020 01:09:53 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/hexo/hexo_write_tips/</guid>
      <description>Config md conf 1title: Hello Hexo！ 2layout: post 3subtitle: &amp;#34;hello word, welcome&amp;#34; 4date: 2020-07-26 01:09:53 5author: &amp;#34;Airren&amp;#34; 6catalog: true 7header-img: &amp;#34;post-bg-js-module.jpg&amp;#34; 8tags: 9 - Life _config.yml 1# Hexo Configuration 2## Docs: https://hexo.io/docs/configuration.html 3## Source: https://github.com/hexojs/hexo/ 4 5# Site 6title: ByteGopher 7subtitle: To Be A Lean Developer! 8author: Airren 9language: en 10timezone: Asia/Shanghai 11 12# URL 13## If your site is put in a subdirectory, set url as &amp;#39;http://yoursite.com/child&amp;#39; and root as &amp;#39;/child/&amp;#39; 14url: https://www.</description>
    </item>
    
    <item>
      <title>「毕业旅行」青甘自驾</title>
      <link>https://airren.github.io/life/graduated-travel/</link>
      <pubDate>Tue, 28 Jul 2020 01:57:20 +0000</pubDate>
      
      <guid>https://airren.github.io/life/graduated-travel/</guid>
      <description>2020.06.21 上海 - 兰州 早上上海出发，下午16点到达兰州，然后到神州租车取上我们的战车——7座的科帕奇。虽然是七座，但是最后一排的空间小的可怜🤕。其实本来是想租一个霸道/路虎之类的，奈何第一次使用一嗨租车不让租高端车型。或许因为我们出游的时间是是个淡季，又或许是因为疫情的影响，这几天租车特别便宜。科帕奇只有360左右每天（含全险），现在看了一眼都600+每天了。同期的霸道只要600左右每天，现在1000+（没租上霸道感觉错过了一个亿）。
开上战车，寻了个离机场最近的美食街吃个拉面，必须是地道的牛肉拉面，便奔向曹家堡机场去与小伙伴回合。200+ 公里伴随着晴雨莫测的天气开了大约两个半小时。
夜宿西宁，吃肉去~
2020.06.22 西宁-青海湖 青海湖，最大的盐水湖。门票太贵了，没有进景区，好像景区内也没啥可看的(滑稽)。在附近转了转，风景也不错，湖边的游客也很多，还和白牦牛拍了合照。
有点阴天，云特别的低，但不像南方的阴雨天那样沉闷。空气中夹杂着山顶融化的雪水的气息。草地上点缀着些许的小黄花。
2020.06.25 门源-达坂山 既当金山之后第二段难开的山路，九曲十八弯。
达坂山观景台，收费5元/车。可以听停车休息一会。山顶的风甚是凛冽。</description>
    </item>
    
    <item>
      <title>「Hexo」Hello!</title>
      <link>https://airren.github.io/tools/hexo/hello_hexo/</link>
      <pubDate>Sun, 26 Jul 2020 01:09:53 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/hexo/hello_hexo/</guid>
      <description>开心的一天呀 😊
h1 h2 h3 h4 h5 h6 </description>
    </item>
    
    <item>
      <title>「Love」我们结婚了</title>
      <link>https://airren.github.io/life/married/</link>
      <pubDate>Sat, 29 Dec 2018 11:02:05 +0600</pubDate>
      
      <guid>https://airren.github.io/life/married/</guid>
      <description>遇见你是最美好的开始 未来的我们会过的更好 世间美好 与你我环环相扣 https://themify.me/themify-icons https://themes.gohugo.io/dot-hugo-documentation-theme/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/6.824/CAP%E5%AE%9A%E5%BE%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/6.824/CAP%E5%AE%9A%E5%BE%8B/</guid>
      <description>CAP定律 CAP 按照美国著名科学家 Eric Brewer 在 2000 年提出的理论，当技术架构从集中式架构向分布式架构演进，会遇到 “CAP 定律”的瓶颈。 CAP 说明一个数据处理系统不能同时满足一致性，可用性和分区容错性这三个需求。
CAP永远不可能同时满足，最多只能同时满足两个，提高其中任意两者的同时，必然要牺牲第三者。 所以，好的系统是根据具体应用，来决定如何在三者之间进行取舍。
####Consistency 一致性—— 读操作是否总能读到前一个写操作的结果，即是说在分布式环境中，多点读出的数据内容是否相容。 ####Partition Tolerance* 分区容错性——数据的分区特性，对系统性能的影响程度 ####Availiability 可用性——访问数据的性能
https://www.cnblogs.com/frank2015/p/9554180.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/1_cryptography/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/1_cryptography/</guid>
      <description>对称加密 非对称加密 RSA 由于计算非常复杂，只适用于小数据加密。
HTTPS 非对称加密+对称加密
mTLS 数字证书 数字证书的颁发过程一般为： 用户首先产生自己的密钥对，并将公共密钥以及部分个人身份信息传送给认证中心。认证中心在核实身份后，执行一些必要的步骤，以确认请求确实是由用户发送来的。然后，认证中心将发给用户一个数字证书。该证书内包含用户的个信息和他的公钥信息。同时还附有认证中心的签名信息。
加密通信 Alice [Decode message by Alice&amp;rsquo;s private key] &amp;lt;&amp;mdash;- send message &amp;mdash; [message encrypted with Alice&amp;rsquo;s public key] Bob
公钥加密，私钥解密
数字签名 Bob 给Alice发送的文件需要携带数字签名。
Bob使用自己的私钥 以及文件的哈希值， 通过签名算法 计算出 数字签名
Alice 收到文件后， 通过文件哈希值，Bob的数字签名，以及Bob的公钥 进行签名验证
数字签名主要有以下三个作用：认证，确认收到的数据的身份信息；防止抵赖，文件一旦签名后不能反悔；防止篡改，保证文件在传输过程中的完整性。
比特币其实就是数字签名
X.509 数字证书 证书版本信息
证书的序列号，每个证书都有一个唯一的证书序列号
证书所使用的签名算法；
证书的发行机构名称，命名规则一般采用X.500格式；
证书的有效期，现在通用的证书一般采用UTC时间格式，它的计时范围1950-2049；
证书所有人的名称，命名规则一般采用X.500格式；
证书所有人的公开密钥；
证书发行者对证书的签名；
Openssl 创建一个 root certificates 和 private key 用来为服务签署 certificates
1openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj &amp;#39;/O=example Inc.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/3_intel_sgx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/3_intel_sgx/</guid>
      <description>SGX
概述 https://www.intel.com/content/www/us/en/developer/tools/software-guard-extensions/overview.html
https://blog.quarkslab.com/overview-of-intel-sgx-part-1-sgx-internals.html
Intel Software Guard Extensions(Intel SGX) 保护选定的代码和数据不被泄露的和修改。开发者可以把应用程序划分到CPU强化的enclave中或者内存中可执行的保护区域，即使在受攻击的平台中也可以提高安全性。使用这种新的应用层可信执行环境，开发者能够启用身份和记录隐私，安全浏览和数据保护(DRM)或者任何需要安全存储机密或者保护数据的高保障安全应用场景中。
机密性和完整性， 即使在OS、BIOS、VMM或者SMM层存在特权恶意软件的情况下也可以保证安全。 低学习曲线，和父应用程序类似的OS编程模型，并且在主CPU上执行 远程认证 远程部分能够认证一个应用程序的enclave的身份，并且安全的将密钥、凭据和敏感数据提供为enclave 最小的可能攻击面， CPU边界成为攻击面外围，所有的数据、内存、外围之外的IO都是加密的。 最小攻击面的硬件辅助可信执行环境。
intel SGX保护的应用程序 Intel SGX应用程序由两个部分组成： 不可信代码和可信Enclave. 开发者可以创建一对多的可信enclave用来支持分布式体系结构。
常用应用有密钥，专有算法，生物识别数据和CSR生成等。
程序运行时， Intel SGX指令在一个特定的保护内存区域中创建和执行enclave，该区域有由开发者定义的受限入口和出口函数。能够防止数据泄露。在CPU范围中的enclave和数据运行在一个clean的环境中， enclave数据写入到磁盘会被加密，并且校验其完整性。
上图中的流程
Application由可信和不可信部分构成 App运行和创建evclave， enclave放入到可信内存中 可信函数被调用，执行会转换到enclave中 enclave可以访问所有进程数据，外部要访问enclave数据被禁止 可信函数返回enclave数据 对enclave有未授权的访问和内存侦听是有可能的
认证Enclave和加密数据 当前，ODM(原始设备制造上)和ISV(独立软件提供商) 通常在制造时或通过无法以机密方式证明XXX。
Intel SGX使用enclave之间本地认证或者第三方远程认证的方式来保证应用程序没有受到破坏。
应用程序受保护的部分会加载到一个Enclave，它的代码和数据都会收到监测。会发送一个请求到远端服务器，用来验证这个Enclave是否是可靠的Intel 处理器生成的。 如果认证了Enclave的身份，远端就会信任Enclave并安全的提供密钥，凭证和数据.
Intel SGX 包括一个生成CPU和Enclave特定“密封密钥”的指令。密钥能够用来安全的存储和取回可鞥你需要保存在磁盘中的敏感信息。
Intel SGX 实现新的安全模型 Intel SGX 是在很多公司、大学的安全研究人员以及政府安全机构的支持下创建的，上百家ISV与Intel合作，使用Intel SGX来保护关键任务应用程序。
Set up SGX develop environment Install SGX driver
Install SGX SDK
Install SGX PSW
直接按照官方文档依次安装上述3个组件</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/crypto_openvpn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/crypto_openvpn/</guid>
      <description>Reference https://www.cyberciti.biz/faq/ubuntu-20-04-lts-set-up-openvpn-server-in-5-minutes/
https://github.com/Nyr/openvpn-install/blob/master/openvpn-install.sh</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/k8s_1_pod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_1_pod/</guid>
      <description>从底层技术角度看，Pod内不同容器之间共享存储和一些namespace。
PID namespace: Pod中不同应用程序看拿到的其他进程的ID。Sidecar 模式下只能看到一个进程？
Network Namespace: Pod 中的多个容器具有相同的网络配置，共享一个端口范围。
IPC Namespace： Pod中的多个容器能够使用SystemV IPC 或 POSIX消息队列进行通信。
UTS Namespace: Pod中的多个容器共享一个主机名。
在Kubernetes的网络模型中，每台服务器上的容器有自己独立的IP段。
为了实现这一目标，重点解决一下两点：
各台服务器上的容器IP段不能重叠，所以需要某种IP段分配机制，为各台机器分配独立的IP段。 从某个Pod发出的流量到达所在的机器的Host上时，机器网络层应当根据目标IP地址，将流量转发到目标机器的能力。 综上，两个能力： IP地址分配和Route.
容器之间直接通信，不需要额外的NAT。
Pod to Pod 所有的Pod之间要保证3层网络的联通性
Pod to Service Servcie 总共有4种类型，其中组常用的就是Cluster IP. 这种类型的Service会分配一个仅集群内可以访问的虚拟IP。
Kubernetes通过kube-proxy组件实现Service Cluster IP的功能。kube-proxy 是一个daemonset，通过复杂的iptables/IPVS 规则在Pod和Service之间进行各种过滤和NAT.
Pod到集群外 从Pod内部到集群外的流量，Kubernetes会通过SNAT来处理。
Kubernets 默认的组网方案是bridge，CNI主要是用来解决容器的跨机通信。典型的跨机通信方案有bridge和overlay。
创建Pod时候，首先会创建一个pause容器。占用一个 linux的network namespace。Pod内的其他容器共享这个network namespace。此时，只有一个lo设备。 CNI负责初始化pause container 中的网络设备。
kubernetes主机内组网&amp;amp;跨节点组网 kubernetes 经典的主机内组网模型是veth pair+bridge。
跨机通信一般是bridge + overlay。 vxlan
downward API 通过HostAlias修改pod中的/etc/host(Pod在host network下不支持)
Pod的隔离中 network namspce 是最先创建的，如果ns使用了host模式，则uts也会使用host模式。
Pause扮演PID 1的角色，并在子进程成为“孤儿进程”时，通过wait() 收割这些僵尸子进程。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/linux_zero_copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux_zero_copy/</guid>
      <description>https://www.jianshu.com/p/a6c6f47a5ef7
https://blog.csdn.net/weixin_42096901/article/details/103017044
https://blog.csdn.net/weixin_39406430/article/details/123715072
http://t.zoukankan.com/yangyongjie-p-14576216.html
https://zhuanlan.zhihu.com/p/430848775
https://blog.csdn.net/weixin_42340926/article/details/126211173</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/multipass_network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/multipass_network/</guid>
      <description>LXC Set proxy
1sudo lxc config set core.proxy_https http://username:password@&amp;lt;IP&amp;gt;:&amp;lt;port&amp;gt;/ LXC
https://www.linode.com/docs/guides/beginners-guide-to-lxd-reverse-proxy/
https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-lxd-on-ubuntu-20-04
SDEWAN - direct connect Edge-1
1# PREROUTTING 2sudo iptables -I PREROUTING -d 10.10.70.49/32 -p tcp -m tcp --dport 6443 -j DNAT --to-destination 10.96.0.1:443 -t nat Hub
1# PREROUTTING 2 3sudo iptables -I PREROUTING --destination 10.95.62.68/32 -p esp -j DNAT --to-destination 10.233.108.10 -t nat 4sudo iptables -I PREROUTING --destination 10.95.62.68/32 -p udp --dport 4500 -j DNAT --to-destination 10.233.108.10:4500 -t nat 5sudo iptables -I PREROUTING --destination 10.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/blog/network_virtualization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_virtualization/</guid>
      <description>1title: Linux Network Virtualization Network Namespace In order to provide the isolation, Linux has 6 namespaces to split the different resources, shown as follows:
Namespace Description Mount Namespace File system mount point CLONE_NEWNET UTS Namespace Hostname CLONE_NETUTS IPC Namespace POSIX process messaging queue CLONE_NEWIPC PID Namespace Process PID number namespace CLONE_NEWPID Network Namespace IP address/Port/Router/IPtables CLONE_NEWNS User Namespace User isolation CLONE_NEWUSER For the process, if they want to use the resources of the Namespace, they should enter the namespace first.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Istio/1-Istio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Istio/1-Istio/</guid>
      <description>Service Mesh 浅析
Istio的自我救赎
https://github.com/cloudnativebooks/cloud-native-istio/tree/master/chapter-files/security
云原生架构的三驾马车
Kubenetes， Service Mesh , Serverless
Servcie Mesh 超时重试
16年概念提出。
技术选型？
ServiceMesh 的相关概念
Service Mesh的起源
微服务架构的特性
围绕业务构建团队 康威定律-&amp;gt; 团队结构决定了产品结构
去中心化的数据管理
团队层面： 内聚，独立业务开发，没有依赖
产品层面： 服务彼此独立，独立部署，没有依赖
访问量决定部署实例的数量
银弹理论-&amp;gt; 人月神话 没有任何一种技术可以完美的解决软件开发中的问题。
空间换时间 or 时间换空间
微服务架构带来的缺点
服务间网络通信问题
分布式计算的8个谬论
网络是可靠的 网络延时是0 很难会把网络相关的需求考虑到我们的设计中。分布式系统中，网络问题是一个重要问题。
如何管理和控制网络通信
辅助注册、发现
路由，流量转移
弹性能力 熔断超时重试
安全
可观测性
Patten： Service Mesh
阶段一： 控制逻辑与业务逻辑耦合
阶段二： 公共库：流控，重试 （人力，时间学习，语言蚌绑定，平台相关，代码侵入）
阶段三：代理模式， 功能简陋Nginx
阶段四： Sidecar 模式 2013-2105
阶段五： Service Mesh 2016-2017
​ Service MeshV2 2018</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Kubernates/k8s-Istio-Envoy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/k8s-Istio-Envoy/</guid>
      <description>What is Service Mesh(服务网格) https://jimmysong.io/blog/why-do-you-need-istio-when-you-already-have-kubernetes/
UPF
2 次链接
1 控制面 ip register step 1-4
hub 公有网络直连接， 给edge pod分配全局IP，cluster api server CRD controller 监视CRs &amp;ndash;&amp;gt; kube cofig
2 数据面
hub-device connection
hub 桥接
IPSec configuration -&amp;gt; 2 次分发
SNAT-&amp;gt; DNAT IP 地址可能重合
测试环境部署 4 cluster
物理机 4 nuc
10.239.241.255 &amp;ndash; hub
switch 交换机
kubectl get iphost
kubectl describe iphost hubdevice1
kubectl get
spce:
pubkry
conn_type
proposal 加解密
mark route base VPN</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/curl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/curl/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/iptables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/iptables/</guid>
      <description>TCP 的有限状态机
CLOSED CLOSED
SYN_SENT LISTENING
​ SYN_RECEIVED
ESTABLISHED ESTABLISHED
netfilter: Frame
iptables: 数据报文过滤
防火墙： 硬件/软件
规则： 匹配标准和处理办法
默认规则：
​ 关闭
匹配标准：
IP:源IP， 目标IP
TCP: SPORT, DPORT SYN=1,FIN=0,RST=0,ACK=0
UDP:SPORT, DPORT
ICMP: icmp-type
规则在内核空间
内核空间的TCPIP的协议栈上，开放给用户空间中的iptables API。
内核空间的工作框架：
用户空间的管理工具： system call
参考 openBSD
Linux 2.0：ipfw/firewall
Linux 2.2： ipchain/firewall Linux 2.4 ： iptables/netfilter
1：07
1/proc/sys/net/ipv4/ip_forward 路由决策发生在数据包到达网卡， 送到TCPIP协议栈上的那一刻。 然后先发生路由决策
netfilter 补充在tcp ip协议上的3个hook function。
多个规则，自上而下，逐个检查，
不做拒绝或者放行策略
4： 刚刚进入本机网卡，还没有到达路由表。（地址转换k&amp;rsquo;k）
5： 即将离开本机的时候，路由决策做出之后。
规则链
PREROUTING
INPUT
FORWARD
OUTPUT</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/jq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/jq/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/port/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/port/</guid>
      <description>查看端口的占用情况
1netstat -atunlp 2 3# 用来查看系统当前网络状态信息， 包括端口、连接情况等 4# -t: TCP端口 5# -u: UDP端口 6# -l: 仅显示监听Socket LISTEN状态的Socket 7# -p: 显示进程标识符和程序名称，每一个socket都属于一个程序 8# -n: 不进行DNS解析 9# -a: 显示所有连接的端口 10 11 12 13 14lsof 15# 列出当前系统打开文件(list open files) 16# -i:[num] 指定端口 1nslookup # 域名解析 2host 3dig </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/route/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/route/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/wan3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/wan3/</guid>
      <description>mwan3
单线多拨</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/%E8%BF%9B%E7%A8%8B%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/%E8%BF%9B%E7%A8%8B%E6%97%A5%E5%BF%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/CloudNative/Linux/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/component/DataBase/mongo/mongo_install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/DataBase/mongo/mongo_install/</guid>
      <description>1 docker run -d -p 27017:27017 --name mongo_4_4_2 mongo:4.4.2 mongosh 命令行client https://docs.mongodb.com/mongodb-shell/install
1If you need to have node@14 first in your PATH run: 2 echo &amp;#39;export PATH=&amp;#34;/usr/local/opt/node@14/bin:$PATH&amp;#34;&amp;#39; &amp;gt;&amp;gt; ~/.zshrc 3 4For compilers to find node@14 you may need to set: 5 export LDFLAGS=&amp;#34;-L/usr/local/opt/node@14/lib&amp;#34; 6 export CPPFLAGS=&amp;#34;-I/usr/local/opt/node@14/include&amp;#34; mongo doc
https://mongoing.com/docs/tutorial/query-documents.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/02_complication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/02_complication/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/03_array_link_jump/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/03_array_link_jump/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/04_stack_queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/04_stack_queue/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/05_ds_hash_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/05_ds_hash_map/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/DataStruct/ds_heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_heap/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/English-learning/2022-05-13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/English-learning/2022-05-13/</guid>
      <description>13th May 2022 Hi, June, this class, I hope you could help me to correct the typo and grammar and make the sentence I have made much more like a native speaker. I would appreciate it if you could help me. The sentences here are the answer about the first class. The first phase is about my hometown, the second is about my name, the third is about my job, and last but not least is about my electronic devices.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/English-learning/2022-05-17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/English-learning/2022-05-17/</guid>
      <description>Thanks, Anj. I love your class, you are full of passion and patience. You are an excellent and professional teacher. , I think you have magic in the class. When I take your class, you can take all of my attention. I think you are very popular on this platform, your class is very hard to reserve.
I have worked from home since two months ago.
engoo.com/en/materials</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/English-learning/2022-05-18/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/English-learning/2022-05-18/</guid>
      <description>18th May 2022 Yesterday, I am sorry heard you External Solid State Drive is corrupted. Is name correct, or Mobile Solid State Storage, or external hard driver, which one is usual. SSD, the short name is often used in China, so do Philippine? I remember that you bought it from Shopee. It&amp;rsquo;s may be a China brand.
The electronic device in Chinese brand I only suggest HUAWEI, XIAOMI, VIVO, HONOR, and Lenovo.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/English-learning/2022-05-19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/English-learning/2022-05-19/</guid>
      <description>Today，Let&amp;rsquo;s talk something about computer
All the computers that are developed are not the same, they have different designs and features. Some computers have a very high capacity as well as working speed; however, some are slow. Depending on the requirements, computers are being developed.
Depending upon the internal structure, and applicability, the computer system is categorized as follows −
Mainframe Computer It is high capacity and costly computer. It is largely used by big organizations where many people can use it simultaneously.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/English/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/English/</guid>
      <description>If someone says thanks to you, how to turn back?
Don&amp;rsquo;t mention it. It&amp;rsquo;s my pleasure. No worries. No problem. Any time. </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/Insight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/Insight/</guid>
      <description>Q1 2022 Insight The SDEWAN E2E demo installs and verifies process is simplified, shortened to about 40 minutes, and improved efficiency by optimizing the automatic deployment and test scripts. Help the Smart Edge team integrate SDEWAN with DEK, prepare guides, answer questions, and do hands-on debugging.
Verified the POC in Ubuntu that StrongsWAN integrates with CTK through PKCS#11, which put the private key in -the SGX enclave to protect it. And propose ubuntu-SGX container as a sidecar work with CNF to provide the security IPsec Tunnel connection.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/daily/2021-04-21-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-04-21-/</guid>
      <description>package main
import &amp;ldquo;fmt&amp;rdquo;
var testMap = map[string]map[string]struct { Name string }{ &amp;ldquo;first&amp;rdquo;: {&amp;ldquo;second&amp;rdquo;: {Name: &amp;ldquo;12312&amp;rdquo;}}, &amp;ldquo;second&amp;rdquo;: {&amp;ldquo;second&amp;rdquo;: {&amp;ldquo;12312&amp;rdquo;}}, }
func main() { d := testMap[&amp;ldquo;first&amp;rdquo;][&amp;ldquo;second&amp;rdquo;].Name fmt.Printf(&amp;quot;++-%v-++\n&amp;quot;, d)
c := testMap[&amp;quot;first22&amp;quot;][&amp;quot;second&amp;quot;].Name fmt.Printf(&amp;quot;++-%v-++\n&amp;quot;, c) }title: 2021-04-21 Socket
https://www.cnblogs.com/wmx-learn/p/5312259.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</guid>
      <description>项目架构 ES6 和TypeScript
And Design Pro
log 可以放在src/assets/images/klogo.svg。 然后在页面中通过以下方式使用
1 2// @ 表示在src 目录下面 3import logo from &amp;#39;@/assets/images/logo.svg&amp;#39; 4 5&amp;lt;LoginForm 6	logo={&amp;lt;image alt=&amp;#34;logo&amp;#34; src={logo}&amp;gt;} </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/2nd_React%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/2nd_React%E4%BB%8B%E7%BB%8D/</guid>
      <description>2. React介绍 2.1 React 基本介绍 FaceBook 开源的JavaScript库
React结合生态库构成一个MV*框架
React特点
Declarative 声明式编码
Component-Based 组件化编码
高效-高效的DOM Diff算法，最小化页面重绘
单项数据流
MV*框架代表- 只关注视图view层+数据层Model
生态介绍
Vue生态： Vue+Vue-Router+Vuex+Axios+Babel + Webpack React生态： React+React-Router+Redux+Axios+Babel + WebPack 编程式实现
需要以具体代码表达在哪里(where)做什么(what)，如何实现（how） 声明式实现
只需要声明在哪里（where）做什么（what），而无需关系如何实现（how） 2.2 React脚手架、yarn 如何安装和使用React脚手架 1npm install -g create-react-app 2creat-react-app my-app 3 4cd my-app 5npm start 什么是Yarn
yarn 是新一代的包管理工具 为什么使用Yarn
速度快 安装版本统一、更安全 更简洁的输出 更好的语义化 如何使用Yarn
1yarn init 2yarn add # npm install 3yarn remove # npm uninstall 4yarn/yarn install # npm install 或者 npm i http:// reactjs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/3rd_%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_antd%E6%95%99%E7%A8%8B/3rd_%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>3. 主页面架构设计 课程目标介绍
第二章 项目主页工程搭建
基础插件安装，less文件加载配置 项目主页结构开发 菜单组件开发 头部组件开发 底部组件开发 3-1 基础插件安装（1） 基础插件安装，less文件加载配置 安装所需的插件
安装React-Router, Axios 安装antD界面框架 暴露webpack配置文件 安装less-loader 修改less-loader 1 yarn add react-router-dom axios less-loader # 3.0升级到 4.0 AntD 是基于less开发的
暴露webpack文件使用less 1yarn eject create-react-app添加less配置
修改完成配置后需要重启项目，从后向前使用， less的配置放在css，scss之后
可能需要删除node_module文件夹重新yarn install
yarn add less
需要修改的文件config/webpack.config.js
1// style files regexes 2const cssRegex = /\.css$/; 3const cssModuleRegex = /\.module\.css$/; 4const lessRegex = /\.less$/; 5const lessModuleRegex = /\.module\.less$/; 6const sassRegex = /\.(scss|sass)$/; 7const sassModuleRegex = /\.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/0_Category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/0_Category/</guid>
      <description>2nd_操作系统
3rd_网络
4th_数据库
5th_程序设计基础
6th_编码技巧
7th_面向对象
8th_设计模式
9th_高级知识点
10th_Google笔试题解
11th_面试技巧和总结</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/10th_Google%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/10th_Google%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E9%A2%98%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/11th_%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%92%8C%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/11th_%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E5%B7%A7%E5%92%8C%E6%80%BB%E7%BB%93/</guid>
      <description>面试软技巧和总结 解决问题的能力 面对问题的态度 分析问题的方法 结构化分析问题 剔除干扰项 提问面试官 介绍一下所在的项目组 介绍一下所用的技术栈 对我的个人的意见和建议 后续学习 基础知识： 广度优先， 在兴趣点深入 编码能力： LeetCode， Google在线平台 面向对象和设计模式： 尝试重构自己写过的代码 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/2nd_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/2nd_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>操作系统 进程和线程 进程： 进程中的内存是逻辑内存， 所有进程的逻辑内存之和要远远大于物理内存。 文件/网络句柄是共享的 线程 TLS： Thread Local Storage 缓冲区溢出 协程 进程之间不可以共享内存， 线程之间可以共享内存 进程间的通信方式： 管道，TCP/IP 比较优劣 线程间的通信方式： 共享内存 存储和寻址 存储 寻址空间 每个进程有自己的独立寻址空间 进程独立
32位 -&amp;gt; 4G 64位 -&amp;gt; ~10^19Bytes 1wPB 64位JVM -&amp;gt; 可以使用更大的内存，32 -&amp;gt; 需要重新编译 寻址 int n= *p; -&amp;gt; MOV EAX,[EBX] 把EBX寄存器中的数据读出，放入EAX 寄存器。n -&amp;gt; EAX, p -&amp;gt; EBX.
逻辑内存的大小与物理内存没有关系，只有操作系统有关。 操作系统的位数决定逻辑内存的位数。 逻辑内存映射到物理内存，数据不一定在物理内存中，也可能存在虚拟内存中。 当数据在虚拟内存中时候，不是只把逻辑内存对应的数据加载到物理内存，而是把数据所在的分页加载到物理内存。如果物理内存放不下，就交换一部分数据到虚拟内存。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/3rd_%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/3rd_%E7%BD%91%E7%BB%9C/</guid>
      <description>网络 网络基础 不可靠 丢包，重复包 出错 乱序 不安全 中间人攻击 窃取 篡改 滑动窗口 TCP协议中使用
维持发送方/接收方缓冲区
流量控制+拥塞控制 在传输过程中会调整窗口的大小 窗口的大小为0是合法的，（如果消息来不及处理可以设置为0） 不使用滑动窗口的话吞吐量会非常低
滑动窗口的Ack是有序的 如果丢ACk 会启动超时重传机制 WireShark 抓包 wireShark 抓包
网络例题 一个来回的时间：1500km/(2*10^5km/s) *2 = 0.015s 来回的次数至多：100s/0.015 = 6666.67次
每次传输至少： 100GB/6666.67 = 15M
数据链路层 网络层 传输层 TCP/UDP 应用层</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/4th_%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/4th_%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>数据库 关系型数据库 基于关系代数理论 缺点： 表结构不直观，实现复杂速，速度慢 优点： 健壮性高，社区庞大 Product
product_id product_name category_id price 4 toyota 2 100000 3 prosche 2 1000000 2 addidas 2 500 1 nike 600 category
category_id category_name 2 automobile 1 shoes 1select * from product join category; -- 结果为笛卡尔积 8条记录 2 3select * from product p join category c on p.category_id=c.category_id; -- 按照id相等去连接， 忽略id 为空的记录 内连接 null的数据不会显示 4 5 6select * from product p left join category c on p.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/5th_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/5th_%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</guid>
      <description>程序设计语言基础 程序设计语言 类型检查
编译时：C, C++, Java, Go 运行时： Python, Perl, JavaScript, Ruby 运行/编译
编译为机器代码运行：C, C++ 编译为中间代码，在虚拟机运行： Java, C# 解释执行： Python, Perl, JavaScript 编程范式 Programming Paradigm
面向过程: C, Visual Basic 面向对象: Java, C++, C#, Scala 函数式: Haskell, Erlang 数据类型和补码 数据类型
boolean, byte, char short, int, long, float, double String, Enum, Array Object&amp;hellip; 补码
32位int 范围 -2^31 ~ 2^31 -1 11000...0 -2^32 21111...1 -1 30000...0 0 40111...1 2^31-1 5 6-1 + 1 = 0 浮点数与定点数 浮点数 (+/-)1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/6th_%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/6th_%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</guid>
      <description>编码技巧 编码技巧概述 递归控制 循环控制 边界控制 数据结构 好的代码， 代码短，思路清晰
白板上写程序 先思考后写， 不要惧怕修改和重写
数学归纳法 用于证明断言对所有的自然数成立</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/7th_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/7th_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象 面向对象思想 类与对象 接口与实现 继承与封装 不可变对象 泛型 从用户(终端用户，使用你代码的用户)的角度思考问题 摒弃完全基于逻辑的思维 类与对象 类的成员变量 -&amp;gt; 对象状态
类的成员函数 -&amp;gt; 对象行为
类的静态变量
类的静态函数
逻辑结构 1class Employee{ 2 void getPaid(BankEndPont bank){ 3 bank.payment(name, salary); // this 4 } 5} 类的静态变量和静态函数
没有this引用， 金泰变量全局唯一一份 普通函数引用静态变量和静态函数？ OK 对象引用静态变量, 函数？ 编译器警告 静态函数引用普通成员变量、 函数 ？ 编译错误 对象的特殊函数 构造函数 equals Object 的equals方法默认判断是否为同一个对象 hashCode a.hashCode() == b.hashCode() &amp;laquo;&amp;ndash; a.equals(b) toString 接口与抽象类 为什么要有接口的概念
从用户(使用实现的代码)的角度看看问题 由编译器强制的一个模块间协作的合约(Contarct)， 强制协作双方无法犯错 无成员变量 成员函数只有声明不能有实现 接口的声明 Java : interface C++: 一个全部是纯虚函数的类 Python/ 大部分动态语言： 依靠注释申明 抽象类 至少有一个抽象方法， 抽象方法没有实现；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/8th_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/8th_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>第8讲 设计模式 1. 单例模式 Singleton 设计模式的提出：博士论文 设计 vs 语言限制 更多的模式： 并发模式、架构模式 从架构的思想上看
Singleton优缺点 确保全局至多只有一个对象 用于： 构造缓慢的对象，需要统一管理的资源 缺点： 很多全局状态， 线程安全性 Singleton的创建（创建非常慢的对象） 双重锁模式 Double checked locking 作为Java 类的静态变量（程序初始化的时候就要创建出来） 使用框架提供的能力 依赖注入的框架（DI框架 Spring, Google Juice）
2. State 模式 变继承关系为组合关系 继承关系 描述is-a关系 复用，增加修改 不用用继承关系来实现复用 使用设计模式实现复用 如果 Employee 升级成了 Manager ？ 新建成一个Manager, 原先的引用应该被回收。
或者使用state模式
3. Decorator模式 装饰者模式 1interface Runable{ 2 void run(); 3} 如何实现LoggingRunable, TransactionRunable, &amp;hellip;.
开始运行，运行结束，运行持续是时间
commit， roll back
4. 如何创建对象 编译时就要确定是创建哪一个对象 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/9th_%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_Google%E8%AE%B2Java/9th_%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>高级知识点 1. 并行计算 将数据拆分到每个节点上 -&amp;gt; 如何拆分 每个节点并行的给出计算结果 -&amp;gt; 中间结果 将结果汇总 -&amp;gt; 如何汇总 2. 外部排序分析 如何排序100G个元素？
只能有一部分数据放到内存
归并排序 将数据分为左右两半，分别归并排序，再把两个有序数据归并 如何归并 归并节点的排序&amp;ndash; K路归并 使用堆实现 Priority Queue **使用Iterable 接口 **
不断获取下一个元素 元素存储/获取方法被抽象, 与归并节点无关 Iterable merge(List&amp;lt; Iterable&amp;gt; sortData); 3. 死锁分析 多线程 线程安全 加锁， 锁的粒度，性能
死锁分析 1void transfer(Account form, Account to, int amount){ 2 synchronized(form){ 3 synchronized(to){ 4 from.setAmount(for.getAmount() - amount); 5 to.setAmount(to.getAmount() + amount) 6 } 7 } 8} synchronized(form) -&amp;gt; 别的线程在等待from
synchronized(to) -&amp;gt; 别的线程已经锁住了to</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/Imooc_react16.4%E5%8F%8A%E5%85%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/Imooc_react16.4%E5%8F%8A%E5%85%B6%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</guid>
      <description>imooc_React16 快速上手 实现TodoList react简介以及语法基础 react Fiber // React 16 之后的版本对应的框架
redux
react 环境搭建
React 脚手架工具 create-react-app
1npx create-react-app todolist # create-react-app 2cd todolist 3yarn start # npm run start 什么是组件 component
简单的jsx语法 项目代码 1├── src 2│ ├── TodoItem.js 3│ ├── TodoList.js 4│ ├── index.js 5│ ├── serviceWorker.js 6│ └── style.css Index.js Index.js 是项目的入口
1import React from &amp;#39;react&amp;#39;; 2import ReactDOM from &amp;#39;react-dom&amp;#39;; 3import &amp;#39;./style.css&amp;#39;; 4// 组件，大写字母开头 s 5import TodoList from &amp;#39;./TodoList&amp;#39;; 6 7 8ReactDOM.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/0_Category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/0_Category/</guid>
      <description>3rd_数据库架构 5th_Linux </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/10th_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/10th_Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E4%B8%8E%E6%8A%80%E5%B7%A7/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/11th_Java%E6%A1%86%E6%9E%B6Spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/11th_Java%E6%A1%86%E6%9E%B6Spring/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/12th_%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/12th_%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/1st_%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/2nd_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/2nd_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E6%A0%B8%E5%BF%83/</guid>
      <description>计算机网络面试核心 7. HTTP 简介 超文本传输协议的主要特点 是应用层的请求响应的无状态协议
支持客户/服务器模式 ： 浏览器通过url向服务端发送请求， 服务端返回响应信息 简单快速 ： 请求方法 get post delete 通讯速度快 灵活： 数据格式灵活，允许任意格式的数据类型 无连接： 每次连接只处理一个请求，收到应答之后就断开连接 ， 1.1 之后使用了长连接 下层实现对上层透明， keep alive 无状态： 对事务处理没有记忆能力，缺少状态， version 1.1 引入了 keep alive 持续连接机制 2.0 升级成本太大 HTTP 请求结构 HTTP请求报文结构
1GET /baidu/com HTTP1.1 2 Host: www.baidu.com 3 Connection:keep-alive # close 1.1之前 4 User-Agent： Mozilla/5.0 5 Accept-Encoding 6Cookie: XXX HTTP响应结构 1HTTP 1.1 200 OK 2	Server: 3	Accept-Ranges: 4	Content-Type: 5	Content-Languge: 6	Content-Length: 7	Date: 请求/响应步骤 客户端连接到WEB服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接： 服务器主动关闭TCP连接，浏览器被动释放TCP连接 客户端浏览器解析HTML内容 在浏览器地址键入http 开头的url，按下回车之后经历的流程 DNS解析 ：逐层查询路由器中的DNS缓存，浏览器-系统-路由器-IPS服务器-根域名服务器缓存-顶级域名服务器缓存，返回对应IP TCP连接：IP+80端口 三次握手 http协议版本 发送HTTP请求： 服务器处理并返回HTTP报文 浏览器解析渲染页面 连接结束 HTTP状态码 1XX：指示信息——表示请求已接收，继续处理</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/3rd_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/3rd_%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84/</guid>
      <description>数据库 1. 数据库架构 关系型数据库的主要考点： 架构、 索引、锁、语法、理论范式
范式一： 列不可再分 范式二： 标准键 范式三： 去除传递依赖
如何设计一个关系型数据库 RDMBS
存储管理：尽可能的减少IO，使用块或者页实现 缓存机制：不宜过大，要有淘汰机制 LRU SQL解析：SQL解析 日志管理：记录操作记录 binlog 权限划分： 容灾机制：处理异常 索引管理： 锁管理：
1. 为什么要使用索引？ 避免全表扫描，快速查询数据
全表扫描 所有的数据分批次加载到内存 索引 - 对应字典的偏旁部首等
2. 什么样的信息能够成为索引 主键、唯一键、普通键等
3. 索引的数据结构 生成索引，建立二叉查找树今次那个二分查找 生成索引，建立B-Tree进行查找
生成索引，建立B+Tree结构进行查找
生成索引，建立Hash结构进行查找
2. 优化索引- 二叉查找树 二叉查找树 二叉查找树：左子节点小于 根节点， 右子节点大于根节点 平衡二叉树： 左右子树深度的差值不超过1
二叉查找树容易变为线性二叉树 即使使用数的旋转也会出现数的深度递增导致IO的次数增加 3. 优化索引- B-Tree 平衡多路查找树 每个节点有至多m个孩子， M阶B树 定义：
根节点至少包括两个孩子 树中每个节点最多含有有M个孩子(m&amp;gt;2) 除根节点和叶节点外，其他每个节点都至少有ceil(m/2)个孩子 所有的叶子节点都位于同一层 假设每个非终端节点中包含有n个关键字信息，其中 Ki(i=1,&amp;hellip;n) 为关键字，且关键字顺序按升序排序Ki-1&amp;lt; Ki 关键字的个数n必须满足：[ceil(m/2) -1]&amp;lt;= n &amp;lt;= m-1 非叶子节点的指针：P[1],P[2],&amp;hellip;P[M];其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1]K[i])的子树。 让每一个节点尽可能存储更多的信息，尽可能的减少数的深度，从而减少IO的次数</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/4th_Redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/4th_Redis/</guid>
      <description>Redis 缓存知识考点 熔断机制： 数据库down掉，可以缓存顶上
缓存中间件-Memcache 和 Redis 的区别 Memcache: 代码层次类似Hash
支持简单数据类型 不支持数据持久化 不支持主从 不支持分片 shard Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快 100000+ QPS(QPS-&amp;gt; query per second, 每秒查询次数)
完全基于内存， 绝大部分请求是纯粹的内存操作， 执行效率高 数据结构简单， 对数据的操作简单 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例 使用多路I/O复用模型，非阻塞I/O 多路I/O 复用模型 FD： File Descriptor , 文件描述符 一个打开的文件通过唯一的描述符进行引用， 该描述符是打开文件的元数据到文件本身的映射。
传统的阻塞IO模型 多路IO复用模型 select 系统调用 Redis采用的IO多路复用函数： epoll【】/kqueue/evport/select &amp;hellip;
因地制宜 优先选用时间复杂度为O(1)的IO多路复用函数作为底层实现 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/5th_Linux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/5th_Linux/</guid>
      <description>Linux Linux 的体系结构 体系结构主要分为 用户态(用户上层活动)和内核态 内核： 本质是一段管理计算机硬件设备的程序 系统调用：内核的访问接口，是一种不能再简化的操作。 原子性的操作。 公用函数库： 系统调用的组合拳 Shell:命令解释器， 可编程 windows - cigwin
查看系统调用 Linux - man 2 syscalls less / more / cat /tail
切换默认shell
查找特定的文件 find
语法： find path [options] params 作用： 在指定目录下查找文件 1find ./ -name &amp;#34;fileName&amp;#34; # 精确查找 2find ~ -name &amp;#34;target*&amp;#34; # 模糊查找文件 3find ~ -iname &amp;#34;target*&amp;#34; # 忽略大小写的查找 4man find # 查看find的使用说明 检索文件内容 grep
语法： grep [options] pattern file 全称 Global Regular Expression Print 作用： 用于查找文件里符合条件的字符串, 智慧筛选出目标字符串所在的行 1grep &amp;#34;moo&amp;#34; target* # 查找 target* 开头的文件中包含 &amp;#34;moo&amp;#34; 的行 管道操作符 | 可以将指令连接起来，前一个指令的输出作为后一个指令的输入 只处理前一个命令的正确输出， 不处理错误输出 右边命令必须接收标准输入流，否则传递过程中数据会被抛弃 sed, awk, grep, cut, head, top, less, more, wc, join, sort, split 等 1grep &amp;#39;partial\[true\]&amp;#39; test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/6th_JVM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/6th_JVM/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/7th_GC%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/7th_GC%E7%9B%B8%E5%85%B3/</guid>
      <description>1. 垃圾回收之标记算法 GC
对象被判定为垃圾的标准 没有被其他对象引用 判定对象是否为垃圾的算法 引用计数法 通过判断对象的引用数量决定对象是否可以被回收 每个对象实例都有一个引用计数器，被引用则+1， 完成引用则-1 任何引用计数为0的实例 可以当做垃圾被回收 优点： 执行效率高， 程序受影响比较小 缺点： 无法检测出循环引用的情况，导致内存泄露
可达性分析算法 通过判断对象的引用链是否可达到，来决定对象是否可以被回收
可以作为GC Root的对象：
虚拟机栈中引用的对象（栈帧中的本地变量表） 方法区中的常量引用的对象 方法区中类静态属性引用的对象 本地方法栈中JNI(Native 方法) 的引用对象 活跃线程的引用对象 2. 谈谈你了解的垃圾回收算法 标记-清除法 Mark and Sweep 标记： 从根集合进行扫描，对存活的对象进行标记 清除： 对堆内存从头到尾进行线性遍历，回收不可达对象内存
Mark 阶段 -&amp;gt; Sweep 阶段
存在问题： 碎片化严重，大对象无法找到连续的内存，容易触发下次垃圾回收，outofmemery
复制算法 Coping - 年轻代 适用于对象存活时间比较低的情况
分为对象面和空闲面 对象在对象面上创建 存活对象从对象面复制到空闲面 将对象面所有对象内存清除 有点： 解决了碎片化问题， 顺序分配内存，简单高效，适用于对象存活率低的场景&amp;ndash;年轻代
标记整理法 - 老年代 整理： 移动所有存活的对象，且按内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。
优点： 避免了内存不连续，不用设置两块内存互换，适用于存活率高的场景
分代收集算法 垃圾回收算法的组合拳
按照生命周期的不同划分区域， 以采用不同的垃圾回收算法 提高了JVM的垃圾回收效率 Survivor Partitiion 年轻代 复制算法</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/8th_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/8th_java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</guid>
      <description>Java 多线程与并发 1. 进程与线程的区别 关于jdk版本的选择 JDK8,JDK11:Oracle 长期支持
Java线程知识考点 进程和线程的区别 用户态和内核态的转换
进程和线程的由来 串行 初期的计算机只能执行串行执行任务，并且需要长时间等待用户输入
批处理 预先将用户指令集中成清单，批量串行处理用户指令，仍然无法并发执行
进程 进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能
线程 共享进程的内存资源，相互间切换更快捷，支持更细粒度的任务控制，使进程内的子任务得以并发执行
进程和线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位
所有与进程相关的资源，都被记录在PCB中
进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
线程只由堆栈寄存器、程序计数器和TCB组成
总结
线程不能看做独立应用，而进程可以看做独立应用 线程有独立的地址空间， 相互不影响，线程只是进程的不同执行路径 线程没有独立的地址空间，多进程的程序比多线程程序健壮 进程的切换比线程的切换开销大 Java进程和线程的关系 - Java对操作系统提供的功能进行封装，包括进程和线程 - 运行一个程序会产生一个进程，进程包含至少一个线程 - 每个进程对应一个JVM实例，多个线程共享JVM里的堆 - Java采用单线程编程模型，程序会自动创建主线程 - 主线程可以创建子线程，原则上要后于子线程完成执行 2. Thread 中start和run方法的区别 start native 方法 openjdk.java.net
调用start() 方法会创建一个新的子线程并启动 run()方法只是一个Thread的一个普通方法的调用 3. Thread 和Runnable 的区别 Thread 实现了Runnable接口的类，使得run支持多线程 Runnable 只有一个抽象方法run 因为单一继承的原则，推荐多使用Runnable结构 4. 如何给run()方法传参 实现方式主要有三种
构造函数传参 成员变量传参 回调函数传参 如何实现处理线程的返回值 实现方式主要有三种
主线程等待法（有多个变量的时候比较难处理，循环等待的时间是不精确的） 使用Thread的join()方法阻塞当前线程以等待子线程处理完毕(粒度不够细) 通过Callable接口是实现： 通过FutureTask 或者 线程池获取 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/9th_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/9th_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/javabasic/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E5%89%91%E6%8C%87offer/javabasic/README/</guid>
      <description>javabasic 课程涉及到的Java代码，持续更新中&amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8th_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8th_%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/1st_md/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/1st_md/</guid>
      <description>算法面试到底是什么鬼？ 1-1 算法面试不仅仅是正确的回答问题 算法面试的目的 展现思考问题的方式 算法面试过程 看做是和面试官一起探讨一个问题的解决方案。对于问题的细节和应用环境，可以和面试官沟通。 这种沟通本身很重要，它暗示着你思考问题的方式。
我们需要对一组数据进行排序。 快速排序算法 O(nlogn)
正确+更优 这组数据有什么样的特征？ 有没有可能包含有大量的重复元素？ 如果有这种可能的话，三路快排是更好的选择。 Java 默认是三路快排。
这组数据有什么样的特征？ 是否大部分数据距离它的正确位置很近？是否近乎有序？ 如果是这样的话插入排序更优
是否数据的取值范围非常有限？比如学生成绩排序。 计数排序更优
对排序有什么额外的要求 是否需要稳定排序 归并排序更优
数据的存储状况是怎样的 如果使用链表存储，归并排序更优
数据的大小是否可以装在内存里， 外部排序
什么是正确的回答一个算法问题
正确还包含对问题的独到见解，容错性，
1-2 算法面试只是面试的一部分 算法面试优秀不意味着技术面试优秀
算法面试只是技术面试的一部分
项目经历和项目中遇到的实际问题
你遇到印象最深的bug是什么？
面向对象
设计模式
网络相关：安全相关，内存相关，并发相关
系统设计： scalability
面试不仅仅是考察技术水平，以及对过去项目的思考
项目经历
通过过去了解你的思考行为方式
遇到的最大的挑战
犯过的错误
遇到的失败
最享受的工作内容
遇到冲突的处理方式
做的最与众不同的事儿
准备好合适的问题问面试官
1-3 如何准备算法面试 避免完美学习
使用时间片学习
远远不需要达到竞赛的水平
不要轻视基础算法和数据结构，而只关注有意思的题目
各种排序算法 技术数据结构和算法的实现： 如堆，二叉树，图 基础数据结构的使用： 如链表、栈、队列、哈希表、图、Tire、并查集 基础算法： 深度优先、广度优先、二分查找、递归 基本算法思想：递归、分治、回溯搜索、贪心、动态规划 选择合适的OJ online judge
leetcode： online portal for interview</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/7th_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%80%92%E5%BD%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/7th_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E9%80%92%E5%BD%92/</guid>
      <description>二叉树和递归 二叉树天然的递归结构 满二叉树
二叉树的前序遍历 递归实现 1void preOrder(TreeNode node){ 2 if(node==null){ 3 return; // 递归终止条件 4 } 5 System.out.print(node.val); 6 preOrder(node.left); // 递归过程 7 preOrder(node.right); 8} 二叉树的定义：空是一棵二叉树
二叉树总是否包含某个key 1boolean contain(TreeNode node, Key key){ 2 if(node == null){ 3 return false; 4 } 5 if(key == node.key){ 6 return true; 7 } 8 if(contain(node.left,key)|| contain(node.right, key)){ 9 return true; 10 } 11 return false; 12} 1// c++ 释放二叉树的内存 2void destory(TreeNode node){ 3 if(node == null){ 4 return; 5 } 6 destory(node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/9th_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%8E%A9%E8%BD%AC%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95_leetcode%E7%89%88%E6%9C%AC/9th_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划基础 什么是动态规划 斐波那契数列 Fibonacci Sequence 1//时间复杂度 应该是指数级 2int fib(){ 3 if(n==0){ 4 return 0; 5 } 6 if(n==1){ 7 return 1; 8 } 9 return fib(n-1)+fib(n-2); 10} 递归会有很多的重复计算，重复的计算量会非常大。
所以想办法对重复的计算 只计算一次
记忆化搜索-自上而下的解决问题 改进的Fibonacci
1// 记忆化搜索 时间复杂度O(n) 2int memo[]; 3int fib(){ 4 if(n==0){ 5 return 0; 6 } 7 if(n==1){ 8 return 1; 9 } 10 if(memo[n]==-1){ 11 memo[n]=fib(n-1)+fib(n-2); 12 } 13 return memo[n]; 14} 动态规划-自下而上的解决问题 1// 动态规划 2int fib(int n){ 3 vector&amp;lt;int&amp;gt; memo(n+1, -1); 4 memo[0] = 0; 5 memo[1] = 1; 6 for(int i=2; i&amp;lt;n;i++){ 7 memo[i] = memo[i-1]+memo[i-2]; 8 } 9 return memo[n]; 10} 动态规划：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/7th_%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/7th_%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/</guid>
      <description>图 图的表示 邻接矩阵（Adjacent Matrix） 邻接表（Adjacent Matrix） 邻接表适合表示稀疏图（Sparse Graph）
邻接矩阵适合表示稠密图（Dense Graph）
稀疏图 稠密图和完全图 寻路 获得两点之间的一条路径
图的深度优先遍历-时间复杂度
稀疏图（邻接表）：O(V+E)
稠密图（邻接矩阵）：O(v^2^)
深度优先遍历算法-有向图
dfs 查看是否有环- 有向图 广度优先遍历和最短路径 借助队列实现
广度优先遍历求出了无权图的最短路径
图的广度优先遍历-时间复杂度
稀疏图（邻接表）：O(V+E)
稠密图（邻接矩阵）：O(v^2^)
无权图的应用- 迷宫生成，PS抠图 flood fill 魔棒抠图 连通分量
扫雷 走迷宫、 迷宫生成 迷宫的本质是一棵树 本质是一个生成树的过程
不能只用一种方式遍历， 随机队列遍历
欧拉路径 哈密尔顿路径 二分图 同学选课
地图着色 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/8th_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/8th_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>最小生成树 Minimum Span Tree 有权图 Weight Graph 邻接矩阵 Adjacent Matrix 邻接表 使用Edge 表示每一条连接边
最小生成树问题和切分定理 带权无向图、连通图
找V-1条边
切分定理 Cut Property 把图中的节点分成两部分，成为一个切分(Cut)
如果一个边的两个端点，属于切分不同的两边，这个边成为横切边(Crossing Edge);
切分定理：
给定任意切分，横切边中权值最小的边必然属于最小生成树
Prim算法 Lazy Prim Lazy Prim 最小堆中依然有不会是横切边的边。
Lazy Prim 的时间复杂度为O(ElogE)
Prim 算法优化 时间复杂度O(ElogV)
IndexMinHeap
Kruskal算法 使用并查集
使用Union Find 快速判断环
最小生成树问题 最小生成树问题思考
Lazy Prim O(ElogE)
Prim O(ElogV)
Kruskal O(ElogE)
如果横切边有相等的边
根据具体的算法实现，每次选择一个边
此时，图存在多个最小生成树
Vyssotsky’s Algorithm
将边逐渐添加到生成树中
一旦形成环，删除环中权值最大的边</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/9th_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/9th_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>最短路径 路径最短问题和松弛操作（Relaxation） 最短路径问题 Shortest Path 路径规划 城市，路由
工作任务规划
广度优先遍历 -&amp;gt; 最短路径树 Shortest Path Tree
单源最短路径 Single Source Shortest Path
无权图的最短路径
松弛操作是求最短路径的核心
Dijkstra 算法的思想 dijkstra 单源最短路径算法 前提： 图中不能有负权边
复杂度 O(ElogV)
负权边和Bellman-Ford算法 拥有负权环的图，没有最短路径
Bellman-Ford 单源最短路径算法 前提：图中不能有负权环
Bellman-Ford 判断图中是否有负权环
复杂度O(EV)
如果一个图没有负权环，从一个点到另一个点的最短路径，最多经过所有的V个顶线，有V-1条边。否则存在定点经过了两次，即存在负权环。
对一个点的一次松弛操作，就是找到经过这个点的另外一条路径，多一条边，权值更小。
如果一个图没有负权环，从一个点到另外一个点的最短路径，最多经过所有的V个顶线，有V-1条边。
对所有的点进行V-1次松弛操作。
对所有的点进程V-1次松弛操作，理论上就找到了从源点到其他所有点的最短路径。
如果还可以继续松弛，就说明原图中有负权环
##更多和最短路径相关的思考</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/category/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/imooc_%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E6%8F%90%E5%8D%87%E7%AF%87/category/</guid>
      <description>imooc_算法与数据结构综合提升篇 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/imooc/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/imooc/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</guid>
      <description>二叉树的序列化和反序列化 二叉树-&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/CAS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/CAS/</guid>
      <description>CAS 和 ABA 问题 在多并发程序设计中，我们不得不面对并发、互斥、竞争、死锁、资源抢占等问题，归根结底就是读写的问题，有了读写才有增删改查，才有一切。同样也有了谁读谁写、这样的顺序和主次问题，于是就有了上锁，乐观锁和悲观锁、同步和异步、睡眠和换入换出等问题，归根结底就是模拟了社会的分工协作与资源共享的抢占，要理解好这些现象的本质，我们需要更加深刻的进行类比和辨析。要知道这些内容的本质就是内存和CPU之间的故事，有时候还会有一些外存和其他缓存。
https://www.cnblogs.com/zyrblog/p/9864932.html</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/IO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/IO%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</guid>
      <description>RandomAccessFile 不同于FileInputStream和FileOutputStream,不是他们的子类 当我们想对一个文件进行读写操作的时候，创建一个指向该文件的RandomAccessFile流就可以了 ； 但是对于OutputStream和DataOutputStream，我们在使用的时候都是通过他们的构造方法来附加或更新文件，即在构造方法中new FileOutputStream；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java-%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java-%E5%BC%82%E5%B8%B8/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>Java8 新特性 Java8 速度更快，代码更少，强大的Stream API，便于并行 最大化减少空指针异常 optional
Lambda表达式 Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java的语言表达能力得到了提升。
从匿名类到Lambda 的转换 1// 匿名内部类 2Runnable r1 = new Runnable(){ 3 @Override 4 public void run(){ 5 System.out.println(&amp;#34;Hello world&amp;#34;); 6 } 7} 8 9//Lambda 表达式 10Runnable r1 = () -&amp;gt; System.out.println(); 11 12//原来使用匿名内部类作为参数传递 13TreeSet&amp;lt;String&amp;gt; ts = new TreeSet&amp;lt;&amp;gt;(new Comparator&amp;lt;String&amp;gt;(){ 14 @Override 15 public int compare(String o1, String o2){ 16 return Integer.compare(o1.length(), o2.length()); 17 } 18}); 19 20//Lambda 表达式作为参数传递 21TreeSet&amp;lt;String&amp;gt; ts2 = new TreeSet&amp;lt;&amp;gt;( 22	(o1, o2) -&amp;gt; Integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/JavaIO/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/JavaIO/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>Java 虚拟机 虚拟机调优 Java 虚拟机调优参数 -Xms 起始内存 JVM堆内存 -Xmx 最大内存 JVM堆内存 -Xmn 新生代内存 -Xss 栈大小。 就是创建线程后，分配给每一个线程的大小 -XX:NewRatio 设置年轻代和老年代的比值。默认为2:1。如果为3，表示年轻代与老年代的比值为1:3，年轻代占整个年轻代和老年代的1/4。 -XX:SurvivorRatio年轻代中Eden区和两个Survivor区的比值。如果为3，表示Eden:Survivor = 3:2, 因为有两个Survivor区域，所以一个Survivor区占整个年轻代的1/5. -XX:MaxPermSize设置持久代的大小。 收集器的设置
-XX:+UseSerialGC设置串行收集器 -XX:+UseParallelGC设置并行收集器 -XX:+UseParallelOld设置并行老年代收集器 -XX:+UseConcMarkSweepGC设置并发收集器 垃圾回收统计信息
-XX:PrintGC -XX:PrintGCDetails -XX:PrintGCTimeStamps -Xloggc:filename 并行收集器设置
-XX:ParallelGCThreads=n设置并行收集器收集时使用的CPU数。并行收集线程数。 -XX:MaxGCPauseMillis=n设置并行收集最大暂停时间 -XX:GCTimeRatio=n设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置
XX:+CMSIncrementalMode设置为增量模式。适用于单CPU情况。 XX:ParallelGCThreads=n设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 -Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3
-Xms1G JVM初始内存1G 这一部分是不是应该是堆内存 -Xmx2G JVM最大内存 2G -Xmn500M 新生代内存 500M -XX:MaxPermSize 持久代内存 64M -XX:SurvivorRatio=3 新生代中Eden:Servivor = 3:2 JVM 调优 -Xms2G -Xmx2G 将JVM最大内存与初始内存设置相等，避免JVM垃圾回收后重新分配内存。 -Xmn1G 年轻代内存Sun官方推荐配置为整个堆的3/8,通常设置为1/3或1/4。 -Xss256K减小每条线程栈的大小，能生成更多的线程 -XX:NewRatio=4 调整年轻代与老年代的比例 年轻代:老年代=1:4 -XX:MaxTenuringThreshold=0 设置晋升到老年代的对象的年龄。 如果设置为0，则年轻代对象不经过Survivor区，直接进入老年代。如果设置一个较大的值，则年轻代对象会在Survivor区进行多次复制。 -XX:+UseConcMarkSweepGC JVM在server模式下默认使用PararrelScavenge＋SerialOld的收集器组合进行内存回收，不支持与用户线程并发执行。可使用ParNew+CMS+SerialOld的收集器组合进行内存回收（SerialOld收集器做为CMS收集器出现ConcurrentModeFailure失败后的后备收集器使用），减少stop-the-world时间。 -XX:CMSFullGCsBeforeCompaction 使用CMS时，设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/Java%E9%9B%86%E5%90%88%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Java%E9%9B%86%E5%90%88%E7%B1%BB/</guid>
      <description>Java 集合类 线程安全与线程不安全 参考链接 https://www.cnblogs.com/williamjie/p/9099141.html
https://www.cnblogs.com/heyonggang/p/9112731.html
https://blog.csdn.net/andy_budd/article/details/81413464
https://blog.csdn.net/wufaliang003/article/details/80219296
https://blog.csdn.net/VIP_WangSai/article/details/70182933
https://blog.csdn.net/qq_41216743/article/details/101311040
https://blog.csdn.net/cn12306com/article/details/81318871
相关面试题 1. 举例说明List 、Set、HashMap是线程不安全的 List ​ 我们知道ArrayList 是线程不安全的，请编写一个不安全的案例并给出解决方案？对于List我们使用的大多数场景是在单线程下，如果在高并发的情况下，便会出现一些线程不安全的问题
1public class ContainerNotSafeDemo { 2 public static void main(String[] args) throws InterruptedException { 3 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); 4 5// 3种解决方案 6// List&amp;lt;String&amp;gt; list = new Vector&amp;lt;&amp;gt;(); 7// List list = Collections.synchronizedList(new ArrayList&amp;lt;&amp;gt;()); 8// List list = new CopyOnWriteArrayList(); 9 10 for (int i = 0; i &amp;lt; 30; i++) { // 30 个线程，每一个线程都有对list的写与读操作 11 new Thread(() -&amp;gt; { 12 list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>多线程 ​
守护线程 Java的main是普通线程，并不是守护线程，
守护线程会等待所有的线程执行结束后再结束
线程同步 https://www.jianshu.com/p/2394317257ec
https://www.jianshu.com/p/988bfceadb62
https://www.jianshu.com/p/6f98f03430eb
https://www.cnblogs.com/williamjie/p/9099141.html
Java 主线程等待所有子线程执行完毕 Java 主线程等待所有子线程执行完毕再执行。
用sleep() 让主线程睡眠一段时间，但是这个睡眠时间是主观设置的，是有我们自己主观设定的，所以不推荐使用。
1public static void main(String[] args) throws InterrupteException{ 2 for(int i=0; i&amp;lt;5;i++){ 3 new Thread( 4 new Runnable(){ 5 public void run(){ 6 try{ 7 Thread.sleep(1000); 8 }catch(InterruptException e){ 9 e.preintStrackTrace(); 10 } 11 System.out.println(&amp;#34;子线程执行！&amp;#34;); 12 } 13 } 14 ).start(); 15 } 16 Thread.sleep(5000); 17 System.out.println(&amp;#34;主线程执行！&amp;#34;); 18} 使用Thread的jion()等待所有的子线程执行完毕，主线程再执行，thread.jion()把指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在B中调用了线程A的jion()方法，直到线程A执行完毕后，才会继续执行线程B。
1public static void main(String[] args) throws InterrupteException{ 2 Vector&amp;lt;Thread&amp;gt; threadVector = new Vector&amp;lt;&amp;gt;(); 3 for(int i=0; i&amp;lt;5;i++){ 4 Thread childThread = new Thread( 5 new Runnable(){ 6 public void run(){ 7 try{ 8 Thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/JavaNote/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式 单例模式 一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。
getInstance()的返回值是一个对象的引用，并不是一个新的实例。
双重校验锁 1public class Singleton{ 2 private volatile static Singleton singleton; 3 private Singleton(){} 4 public static Singleton getSingleton(){ 5 if(singleton == null){ 6 synchronized(Singleton.class){ 7 if(singleton==null){ 8 singleton = new singleton; 9 } 10 } 11 } 12 } 13} 观察者模式 对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
https://mp.weixin.qq.com/s/sdj9DcnZZNRiWssgygiTTw
装饰者模式 对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。
适配器模式 工厂模式 ##代理模式</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</guid>
      <description>字节跳动面试题总结 1. 进程创建的过程 进程的创建过程可分为以下步骤： （1）申请空白的PCB。 进程控制块 描述信息，控制信息，资源信息，CPU现场 （2）为新进程分配资源。 （3）初始化PCB。 （4）将进程插入就绪队列。
2. linux 文件管理系统 inode(发音：eye-node)译成中文就是索引节点，它用来存放档案及目录的基本信息，包含时间、档名、使用者及群组等。
node inode
inode（即index node，索引节点）是类Unix OS中保存文件系统中的对象元数据的数据结构。
https://www.jianshu.com/p/d60a2b44e78e
3.数据库事务 数据库事务
隔离级别
脏读
不可重复读
幻读
丢失修改</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%9D%A2%E8%AF%95/</guid>
      <description>小红书面试 如何判断单链表有环
1public boolean IsLoop(Node head){ 2 Node fast = head; 3 Node slow = head; 4 if(head = null){ 5 return false; 6 } 7 8 while(fast != null&amp;amp;&amp;amp; slow ！= null){ 9 fast = fast.next.next; 10 slow = slow.next; 11 if(fast = slow){ 12 return true; 13 } 14 } 15 16 return false; 17} 三次握手， 为什么要三次
A -&amp;gt; B SYN=1, seq = x;
A &amp;lt;- B SYN = 1, ACK=1, seq = y, ack = x+1;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/10th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/10th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>10 每日一面 java 中 throws Exception和 catch Exception的区别 AB转账问题，保持数据一致性 TreeMap如何保证有序 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/11th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/11th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>11 每日一面 Ucloud
rpc
sql优化，如何解决高并发
explain 慢查询，建索引
什么方式实现缓存，什么情况下需要用到token,token失效怎么办等
主从复制
数据库四种隔离级别，分别举例子，每种在上一种的基础上加了什么锁(很简单不说了)
Tcp，坚持计时器。keepalive计时器。
写了一个shell命令，列出重复数据。awk+unique+sort很简单也不说了。
网络协议 计算机网络五层协议：物理层、数据链路层、网络层、传输层、应用层
计算机网络的七层OSI协议： 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
路由器属于网络层
网卡与交换机数据数据链路层
TCP和UDP TCP 是面向连接的字节流服务，对系统资源要求比较多。程序结构复杂，保证数据的正确性和顺序性。
UDP是无连接的，面向数据报，对系统的资源要求比较少，程序结构简单，不能保证数据的正确性和顺序性
网站安全与防护
sql 注入
使用例如PDO的预处理，使用或者编写类似mysql_real_escape_string的方法对sql的特殊字符进行转义
**XSS（cross site script）**跨站脚本攻击
将外部脚本植入到页面中
**CSRF(cross-site request forgey)**跨站请求伪造
伪造受信任的用户信息来请求网站
算法相关
冒泡排序
选择排序
​	快速排序
快速排序思想：通过一趟排序将序列分成两部分，一部分所有数据比另一部分所有数据小，然后在这两个序列的内部再分别进行快速排序操作，直到最后形成一个有序序列
二分插入排序思想(之前的序列为有序)：插入第i个元素时，对前面的0~i-1进行折半，当前元素与中间元素比较，如果小，前半部分再次折半，如果大，后半部分进行折半，直到最后left&amp;gt;right,然后把目标位置到i-1的所有元素整体后移，把当前元素放进去
基本查找算法：
顺序查找
二分法查找(折半查找)：将序列分为两部分，找到序列的中间值，如果查找值大于中间值，继续对右半部分进行折半，如果查找值小于中间值，对左半部分进行折半，直到找到或front&amp;gt;end结束，时间复杂度O(log2n)以2为底n的对数
设计模式
MVC是一种设计框架，而不是设计模式，框架是比模式更高的概念
model负责数据逻辑
controller负责用户交互
view负责数据显示流程：
用户对控制器的某个方法发出请求，控制器调用相应的模型返回数据，然后将数据渲染到视图中返回给用户
单例模式i. 私有化构造方法和__clone方法ii. 提供公有的静态的方法返回实例iii. 提供私有的静态属性保存实例
简单工厂模式(重点在创建不同对象，作用就是用来创建对象的) - 例如一个计算器的加减乘除求余取整i. 定义抽象基类让子类分别继承并实现相应方法ii. 定义Factory工厂类里面提供静态方法用于根据不同的参数实例化相应的子类对象
策略模式(重点在于实例化不同类的解决策略不同，作用是根据不同的情况调用相应的策略或算法) - 例如qq普通用户 vip svip购买皮肤的优惠策略i. 定义抽象基类让子类分别继承并实现相应的方法ii. 根据不同的场景实例化相应的类，然后调用其中的方法获取结果
观察者模式
i. 需要有一个抽象的主题接口和一个抽象的观察者接口
ii. 实现一个主题，实现多个观察者</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/1st_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/1st_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>1. 每日一面 蚂蚁金服一面
Java 容器有哪些，哪些是同步容器，哪些是并发容器 ArrayList 和LinkedList 的插入和访问的时间复杂度 java反射原理， 注解原理 新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？ HashMap在什么情况下回扩容，或者有哪些操作会导致扩容？ HashMap put方法的执行过程 HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？ 1.8 还采用了红黑树，讲讲红黑树的特性，为什么人家一定要用红黑是而不是AVL，B树之类的； https 和http 的区别，有没有用过其他安全传输手段？ 线程池的工作原理，几个重要参数，然后给了具体几个参数分析线程池会怎么做，最后问阻塞队列的作用是什么？ Linux怎么查看系统负载情况？ 请详细描述SpringMVN处理请求全流程 Spring 一个Bean 的装配过程 讲一讲AutomicInteger 为什么要用CAS而不是synchronized？ 线程会单独拷贝一份数据到自己的工作空间，只有sync代码块被执行完才会将数据从工作内存刷到主内存，所以，指令重排为什么会导致多线程数据不一致的问题，应该是volatile的内存可见性是解决数据不一致问题的原因</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/2nd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/2nd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>2 每日一面 美团一面
最近做的比较熟悉的项目是哪一个，画一下项目技术架构图 JVM老年代和新生代的比例 YGC和FGC发生的具体场景 jstack，jmap，jutil分别的意义？ 如何线上排查JVM的相关问题 线程池的构造类的方法的5个参数的具体意义？ 单机上一个线程池正在处理服务如果突然断电怎么办（正在处理和阻塞在队列里的请求怎么处理）？ 使用无界阻塞队列会出现什么问题？ 接口如何处理重复请求？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/3rd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/3rd_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>3 每日一面 百度一面
介绍一下集合框架 HashMap 和hashtable 底层实现什么区别？ HashTable 和ConcurrentHashTable 区别？ HashMap 和TreeMap 什么区别？底层数据结构是什么？ Synchronized 和 Lock 什么区别？synchronized 什么情况是对象锁，什么时候是全局锁 ThreadLocal 是什么？底层是如何实现的？写一个例子 volitile的工作原理 cas 如何实现的 至少用四种方法实现一个单例模式 请介绍一个JVM的内存模型？用什么样的垃圾回收器 线上发送频繁full GC如何处理？CPU使用率过高怎么办 如何定位问题？如何解决，说一下解决思路和处理方法 知道字节码吗？字节码都有哪些？Integer x=5；int y=5；比较x=y都经过哪些步骤？ 讲讲类加载机制？有哪些类加载器，这些类加载器加载哪些文件？ 手写类加载Demo 知道osgi吗？他是如何实现的 请问你做过哪些JVM优化？使用什么方法达到什么效果？ Class.forName(&amp;ldquo;java.lang.String&amp;rdquo;) 和String.classGetClassLoader() LoadClass(&amp;ldquo;java.lang.String&amp;rdquo;) 什么区别 四种垃圾回收算法
七种垃圾回收器</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/4th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/4th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>4.每日一面 携程面试
问项目， 注意项目细节
Netty
BIO 同步阻塞IO，一个线程只有一个连接
NIO 同步非阻塞IO ，一个线程有多个连接，一个线程中有很多Channel，通过selector 选择线程
AIO 异步非阻塞IO
双重检验单例
1public class Singleton{ 2 private volatile static Singleton singleton; 3 private Singleton(){ 4 5 } 6 public Singleton getSingleton(){ 7 if(singleton == null){ 8 synchronized(Singleton.class){ 9 if(singleton == null){ 10 singleton = new Singleton(); 11 } 12 } 13 } 14 return singleton; 15 } 16} http1.1 长连接， 心跳包， http2 http3
HTTP 1.1 支持长连接(PersistentConnection)和请求的流水线(Pipelining)处理,在一个TCP连接上可以传送多个HTTP请求，减少了建立和关闭连接的消耗和延迟。在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP 1.0 每次请求都要创建连接的缺点。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/5th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/5th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>5 每日一面 今日头条
HashMap如果一直put元素会怎么样？hashCode全都相同如何？ 重写equals时候为什么要重写hash方法 ApplicationContext 的初始化过程？初始化过程发现循环依赖Spring 是如何处理 GC用什么收集器？收集过程如何？哪些部分可以作为GC Root？ Volatile关键字，指令重排序有什么意义？synchronize怎么用？ 并发包里的原子类有哪些，怎么实现？cas在cpu级别是怎么实现的 Redis数据结构有哪些？如何实现Sorted set？这种数据结构在极端情况下 系统设计题：一个推送场景。50条内容，定时推送，先推5%用户，……设计相关库表，系统模块 MySQL索引是什么数据结构？B-Tree有什么特点？有点是什么 慢查询怎么优化 项目 cache 各部分职责，有哪些优点 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/6th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/6th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>6 每日一面 Dubbo超时重试？Dubbo超时时间设置 如何保障请求顺序执行 分布式事务与分布式锁（扣款不要出现负数） 分布式session设置 执行某操作，前50次成功，第51次失败，a全部回滚，b前50次提交第51次抛异常，a b场景分别如何设置Spring？（传播特性） Zookeeper有哪些作用 JVM内存模型 数据库垂直和水平拆分 MyBatis如何分页；如何设置缓存;MySql分页 熟悉IO吗？与NIO的区别，阻塞和非阻塞 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/7th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/7th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>7 每日一面 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/8th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/8th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>8 每日一面 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/9th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/9th_%E6%AF%8F%E6%97%A5%E4%B8%80%E9%9D%A2/</guid>
      <description>9 每一日面 字节跳动
很荣幸字节跳动一路走到了四面，不管是运气还是实力，都好好准备接下来的面试吧，加油
编程 判断字符串B是否是字符串A的子串 数据结构中的桶排序、平衡二叉树 .手撕代码：机器人跳跃(牛客原题） 手撕代码：逆时针打印矩阵（剑指offer改） 合并两个有序链表，空间复杂度O(1)； DP最长回文串； 给两个1T的文件在2g ram的内存中找出相同项。 给一个有向图，判断有向图中是否有环，如果有环，环的数量是多少？ 给一个大小为n的数组，寻找比k小的最大数的位置。 1.最长回文子串 地图上有若干个点，怎样得到某个点到达某个点的所有的换乘路线 ？ 是否是联通，如果不连通怎么处理 给你一个字符串，字符串当中是一段c语言的代码和注释，注释只有/** /这样的可以嵌套，不包含// 请返回去除所有注释的代码 如果代码当中的/*和/*可以不完全匹配如何告知出现错误 写了一个程序，有个小球，球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10 次落地时，共经过多少米？第 10 次反弹多高？ 写代码：火车售票系统是早7点-晚23点进行网上售票，写一个程序判断是否可以进行网上买票 讲一下二叉搜索树，写节点的删除代码 最大连续子序列和 代码：实现lru，不会哦临时想了一种lgn的实现，面试官不满意 写一个最小堆建堆，分析复杂度 多个串，将含有相同字母的串放到同一个集合，返回集合向量 讲思路 编程：36进制加法（忘记处理最高位的进位，面试官提醒了一下） 在一亿个数中找出最大的10个数，在一亿个数中找出中间的10个数 编程：将0-n的整数放到一个长度为n的数组中，找出缺失的那个数 编程：36进制加法（又来？） 题目：n条直线可以将空间划分为多少个区域 面试题 TCP 和UDP
进程和线程
设计模式
MySQL索引的数据结构
进程间的通信方式
设计一个存储海量评论的结构，要求大量数据的写入，可以随意翻页？
熟悉计算机和网络原理，熟悉操作系统原理，对存储、队列、计算、集群管理中的一项或多项有深入的理解和认识；
常用的排序算法的复杂度，写快排；
Java的JVM的内存布局，垃圾回收的实现，回收器分几部分，都有什么作用；
项目大体阐述下，用了哪些技术、设计模式，最大的感受是什么；十分钟实现用过的观察者模式、工厂模式；
TCP四次挥手讲下？为什么有TIME_WAIT？ TCP比UDP多消耗哪些系统资源？
A(FIN_WAIT_1) -&amp;gt; B(CLOSE_WAIT) FIN=1,seq = u
A(FIN_WAIT_2)&amp;lt;-B ACK=1, seq=v,ack=u+1;
A &amp;lt;-B(LAST_ACK) FIN=1,seq = w,ack=u+1;
A(TIME_WAIT) ACK=1 ,seq=u+1,ack=w+1;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>#计算机操作系统
基本特征 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
操作系统通过引入进程和线程，使得程序能够并发运行。
共享 共享是指系统中的资源可以被多个并发进程共同使用。
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。
基本功能 进程管理 进程控制、进程同步、进程通信、死锁处理、处理机调度等。
内存管理 内存分配、地址映射、内存保护与共享、虚拟内存等。
文件管理 文件存储空间的管理、目录管理、文件读写管理和保护等。
设备管理 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。
Linux 的系统调用主要有以下这些：
Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 大内核和微内核 大内核 大内核是将操作系统功能作为一个紧密结合的整体放到内核。
由于各模块共享信息，因此有很高的性能。
微内核 由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。
在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。
因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。
中断分类 外中断 由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid>
      <description>线程同步 线程同步的概念 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。
在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
线程有可能和其他线程共享一些资源，比如，内存，文件，数据库等。
当多个线程同时读写同一份共享资源的时候，可能会引起冲突。这时候，我们需要引入线程“同步”机制，即各位线程之间要有个先来后到，不能一窝蜂挤上去抢作一团。
线程同步的真实意思和字面意思恰好相反。线程同步的真实意思，其实是“排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。
线程同步的方式和机制 临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。
信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制。
临界区 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护的，而是属于进程维护的。
1）关键段共有初始化、销毁、进入和离开关键区域四个函数。
2）关键段可以解决线程的互斥问题，但因为具有“线程所有权”，所以无法解决同步问题。
3）推荐关键段与旋转锁配合使用。
互斥量 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。
1）互斥量是内核对象，它与关键段都有“线程所有权”所以不能用于线程的同步。
2）互斥量能够用于多个进程之间线程互斥问题，并且能解决某进程意外终止所造成的“遗弃”问题。 3、信号量：信号量也是内核对象。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目
信号量 在用CreateSemaphore()创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最 大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1 ，只要当前可用资源计数是大于0 的，就可以发出信号量信号。但是当前可用计数减小 到0 时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出。线程在处理完共享资源后，应在离 开的同时通过ReleaseSemaphore （）函数将当前可用资源计数加1 。在任何时候当前可用资源计数决不可能大于最大资源计数。
事件对象 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作
1）事件是内核对象，事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。
2）事件可以由SetEvent()来触发，由ResetEvent()来设成未触发。还可以由PulseEvent()来发出一个事件脉冲。
3）事件可以解决线程间同步问题，因此也能解决互斥问题。
线程同步的方法 (1)wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
(2)sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException异常。
(3)notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的 唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
(4)notityAll ():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁， 而是让它们竞争。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/nodus/ipv6-debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/ipv6-debug/</guid>
      <description>Hi, Kural,
About the IPV6 SFC, the following is my debug process.
Now, the func CalculateRoutes() can genarate the create route to the pod, but can&amp;rsquo;t add to the corresponding pod.
The calculated result for the sfc-head pod:
But for the agent pod, while adding routes to the container through func ContainerAddRoute() failed. Because in this function, it will get the host network configuration to find the default gateway, to add an extra route to the host network through the default gateway on the host.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/nodus/k8s-install-script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/k8s-install-script/</guid>
      <description>for containerd
for crio
for docker</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_c/c_process/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_c/c_process/</guid>
      <description>fork create process
fork 被调用一次，可以返回两次。
在调用fork之后的代码会执行两次，一次在父进程中执行，返回的是创建成功的子进程的Id，一次是在子进程中执行，返回的是0；如果出现错误，fork返回的是负值。
1/*linux下：*/ 2 3#include &amp;lt;stdio.h&amp;gt; 4#include &amp;lt;unistd.h&amp;gt; 5 6int main() { 7 pid_t pid; 8 pid = fork(); 9 if(pid == 0) //返回子进程 10 { 11 printf(&amp;#34;child pid: %d\n&amp;#34;, getpid()); 12 } else { 13 printf(&amp;#34;pid: %d\n&amp;#34;, pid);//父进程中返回子进程的pid 14 printf(&amp;#34;father pid: %d\n&amp;#34;, getpid()); 15 } 16} 1pid: 2876921 2father pid: 2876920 3child pid: 2876921 fork的两种用法
父进程希望复制自己，使父子进程同时执行不同的代码段。
比如在网络服务程序中，父进程等待客户端的服务请求。当请求到达时，父进程调用fork()使子进程处理此请求；而父进程继续等待下一个请求。
一个进程要执行不同的程序
这个在shell下比较常见，这种情况下， fork()之后一般立即接exec函数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_c/unix_socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_c/unix_socket/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/1st--/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1st--/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/2_%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/2_%E7%B1%BB%E5%9E%8B/</guid>
      <description>类型 2.1 变量 标识符与关键字 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。
关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。
Go语言中有25个关键字：
1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var 此外，Go语言中还有37个保留字。
1 Constants: true false iota nil 2 3 Types: int int8 int16 int32 int64 4 uint uint8 uint16 uint32 uint64 uintptr 5 float32 float64 complex128 complex64 6 bool byte rune string error 7 8 Functions: make len cap new append copy close delete 9 complex real imag 10 panic recover go 语言中的变量必须先声明再使用。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/3_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/3_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制 if&amp;hellip;else 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var number int = 5 7	if number += 4; 10 &amp;gt; number { 8	number :=0 9	number += 3 10	fmt.Print(number) 11	} else if 10 &amp;lt; number { 12	number -= 2 13	fmt.Print(number) 14	} 15	fmt.Println(number) 16} 17 18// 39 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/4_%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/4_%E5%87%BD%E6%95%B0/</guid>
      <description>函数 现代计算机的进程执行模型大部分是基于“堆栈”的，编译器不需要对函数做过多的转换就能让其在栈上运行
2.1 基本概念 2.1.1 函数定义 一个函数的定义包含如下几个部分： 函数声明关键字func、函数名、参数列表、返回列表和函数体。
首字母的大小写决定该函数在其他包的可见：大写时其他包可见，小写时只有相同的包可以访问。
函数可以没有输入参数、也可以没有返回值（默认返回0）
1func A(){ 2} 3 4func B() int{ 5 return 1 6} 多个相同类型的参数可以使用简写模式
1func add(a,b int) int{ // a int, b int 简写为 a,b int 2 return a+b 3} 支持有名的返回值，参数名相当于函数体最外层的局部变量，命名返回值变量会被初始化为类型零值最后的return可以不带参数名直接返回。
1func add(a,b int) (sum int){ // sum 相当于函数内部的局部变量，被初始化为0 2 sum = a+b 3 return // return sum 的简写模式 4 5 // sum := a+b 6 // return sum // 需要显式的调用return sum 7} 不支持默认值参数？？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/99_Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>Go并发编程案例解析 nginx
influxdb 时序数据库 Prometheus
Grafana
实例代码
https://github.com/itsmikej/imooc_logprocess
常见的并发模型 进程&amp;amp;线程 Apache C10K 服务器要同时支持10K的并发连接 异步非阻塞 （Nginx，Libevent， NodeJs）epoll 复杂度高 协程 GoLang， Erlang， Lua Golang并发实现 程序并发执行 goroutine 多个goroutine间的数据同步通信channels 多个channel选择数据读取或者写入select Goroutines Goroutines 程序并发执行
1foo() // 执行函数foo, 程序等待函数foo返回 2go foo() // 执行函数foo 3bar（） // 不用等待foo返回 Channels Channels多个goroutine间的数据通信与同步
1c := make(chan string) // 创建一个channel 2go func(){ 3 time.Sleep(1*time.Second) 4 c &amp;lt;- &amp;#34;message from closure&amp;#34; // 发送数据到channel 中 5}() 6 7msg:=&amp;lt;- c // 阻塞直到接收到数据 Select Select 从多个Channel 中读取或写入数据</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/99_%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>软件开发的新挑战
多核硬件架构
超大规模分布式计算集群
web模式下导致的前所未有的规模和更新速度
区块链开发语言，
Kubernetes
Docker
只有25个关键字
有垃圾回收机制，但是仍然可以直接使用指针访问内存
CSP并发机制
关键字
c 37
c++ 11 84
go 25
go 垃圾回收，使用指针直接内存访问.
复合和继承
docker kubernetes
go 默认使用静态连接，编译完成是一个独立的二进制
1package main // package name 2 3import &amp;#34;fmt&amp;#34; // dependence 4 5// functionality 6func main() { 7	fmt.Print(&amp;#34;hello world \n&amp;#34;) 8} 应用程序入口，
必须是main包 package main 必须是main方法 func main() 文件名不一定是main.go package 的名字不需要与目录保持一致
退出返回值
与其他主要编程语言的差异
Go main函数不支持任何返回值 通过os.Exit 来返回状态 1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;os&amp;#34; 6) 7 8func main() { 9	fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/base/string_operate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/base/string_operate/</guid>
      <description>1package dal 2 3import &amp;#34;testing&amp;#34; 4 5func Empty() { 6	str := &amp;#34;12312&amp;#34; 7	if str == &amp;#34;&amp;#34; { 8 9	} 10} 11func Lenzero() { 12	str := &amp;#34;&amp;#34; 13	if len(str) == 0 { 14 15	} 16} 17func BenchmarkEmpty(b *testing.B) { 18	for n := 0; n &amp;lt; b.N; n++ { 19	Empty() 20	} 21} 22 23func BenchmarkLenzero(b *testing.B) { 24	for n := 0; n &amp;lt; b.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/Plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/Plan/</guid>
      <description>零copy，
close wait and time wait. Tcp/IP
https
tcp 拥塞控制，粘包
io, select, epoll
红黑树&amp;amp;
raft
元空间中创建对象会不会用到物理内存
无重复字符的最长子串 106 25. K 个一组翻转链表 84 206. 反转链表 83 215. 数组中的第K个最大元素 81 146. LRU缓存机制 https://www.zhihu.com/question/339135205
Golang slice 可以动态扩容，但是如何动态缩容呢？
Golang race
Heap 和stack
porm 技术栈test golang 教程
https://www.kancloud.cn/mutouzhang/gocookbook/686698
https://gobyexample.com/sha1-hashes
http://c.biancheng.net/view/vip_7363.html
prome 教程
http://www.eryajf.net/2468.html
https://ethancai.github.io/2016/06/23/bad-parts-about-json-serialization-in-Golang/
123123123123
https://www.robustperception.io/cardinality-is-key
https://github.com/nusr/hacker-laws-zh
编译原理
https://segmentfault.com/a/1190000020239208
raft
GDPR 报警
grafql
https://jobs.intel.com/ShowJob/Id/2891615/Cloud-Native-Runtime-Development-Engineer
https://jobs.intel.com/ShowJob/Id/2829606/Software-Development-Engineer
https://jobs.intel.com/ShowJob/Id/2891612/Edge-Software-Engineer
*https://jobs.intel.com/ShowJob/Id/2891618/Cloud-Native-Software-Engineer
主题更新维护 没有时间阅读，很难深度思考
块存储
Book Read 《Kubernetes网络权威指南》</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/sdewan/CRE-Share/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/CRE-Share/</guid>
      <description>ESXI configuration and usage ESXI admin interface : https://10.239.241.100/
1user: root passwd: CREshare- 跳板机CRE-relay
1ssh cre@cre-relay.sh.intel.com # 10.239.241.116 2user: cre passwd: 123456 BIOS：123456/123123
How to create a VM with SGX and NIC direct mode 1.select a creation type 2.Select a name and guest OS 3.Select storage 4.Customize settings, CPU/Mem/Disk/SGX/PCI device, and select an OS image SGX enable Add a PCI device Select an OS Image 5.Start your machine and check the status </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/sdewan/sdewan-cnf-test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-cnf-test/</guid>
      <description>openwrt login 1curl -XPOST curl --location -v --request POST &amp;#39;https://10-233-76-144.default.pod.cluster.local/cgi-bin/luci/?luci_username=root&amp;amp;luci_password=root1&amp;#39; --cacert ./ca.pem 2 3 # Cert is the cnf-default-cert, must use the h 4curl --location -v --request POST &amp;#39;https://10-233-76-144.default.pod.cluster.local/cgi-bin/luci/&amp;#39; \ 5--header &amp;#39;Content-Type: application/x-www-form-urlencoded&amp;#39; \ 6--data-urlencode &amp;#39;luci_username=root&amp;#39; \ 7--data-urlencode &amp;#39;luci_password=root1&amp;#39; \ 8--cacert ./ca.pem Create CSR
1curl -XGET &amp;#39;https://10-233-76-144.default.pod.cluster.local/cgi-bin/luci/sdewan/nat/v1/nats&amp;#39; --cacert ./ca.pem 1curl -XGET &amp;#39;https://10-233-76-144.default.pod.cluster.local/cgi-bin/luci/sdewan/pkcs11/v1/crs&amp;#39; --cacert ./ca.pem 1#!/bin/bash 2 3set -x 4 5cnf_ip=&amp;#34;10-233-76-144.default.pod.cluster.local&amp;#34; 6cert_label=&amp;#34;node-1&amp;#34; 7cert_subject=&amp;#34;/CN=node-1&amp;#34; 8 9# you alway a same csr, even you try many times 10curl --location --request POST &amp;#34;https://${cnf_ip}/cgi-bin/luci/sdewan/pkcs11/v1/crs&amp;#34; \ 11--header &amp;#39;Content-Type: application/json&amp;#39; \ 12--data-raw &amp;#34;{ 13 \&amp;#34;cert\&amp;#34;: { 14 \&amp;#34;key_pair\&amp;#34;: { 15 \&amp;#34;key_type\&amp;#34;: \&amp;#34;rsa:2048\&amp;#34;, 16 \&amp;#34;label\&amp;#34;: \&amp;#34;${cert_label}\&amp;#34;, 17 \&amp;#34;id\&amp;#34;: \&amp;#34;0001\&amp;#34; 18 }, 19 \&amp;#34;subject\&amp;#34;: \&amp;#34;${cert_subject}\&amp;#34;, 20 \&amp;#34;pem\&amp;#34;: \&amp;#34;\&amp;#34; 21 } 22}&amp;#34; --cert ca.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/sdewan/sdewan-proposal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-proposal/</guid>
      <description>Leverage TEE to enhance the integrity and security of the SASE network
Software-Define wide area network is one of the most essential components of the SASE architecture, which is based on network technologies that create virtualized WAN connections. SD-WAN decouples the network services from the underlying networks and allows the application traffic to be carried independently of the underlying network hardware, enabling the client&amp;rsquo;s connection anywhere to the applications. How to build up a strong shield for the overlay network of SD-WAN has become a hot issue in the industry.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/sdewan/test-result/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/test-result/</guid>
      <description>Test Result Passed Case: Cluster k8s scc crd-controller cnf cert-manager overlay v1.17.0 old version latest version 0.5.1 v1.1.0 hub/edge-1/edge-2 v1.23.0 - latest version 0.5.1 v1.6.1 Failed Case: case1:
Cluster k8s scc crd-controller cnf cert-manager overlay v1.23.0 new version latest version 0.5.1 v1.6.1 hub/edge-1/edge-2 v1.23.0 - latest version 0.5.1 v1.6.1 case2:
Cluster k8s scc crd-controller cnf cert-manager overlay v1.23.0 new version latest version 0.5.0 v1.6.1 hub/edge-1/edge-2 v1.23.0 - latest version 0.5.0 v1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/tech/web/RPC/thrift/thrift/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/RPC/thrift/thrift/</guid>
      <description>https://blog.csdn.net/u011642663/article/details/56015576</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/tech/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/RabbitMQ/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/RabbitMQ/</guid>
      <description>RabbitMQ 消息中间件 技术精讲
1. RabbitMQ 简介以及AMQP协议 RabbitMQ 是一个开源的消息代理和
RabbitMQ底层是采用Erlang语言进行编写 开源、性能优秀， 稳定性保障 与spring AMQP完美整合，API丰富 集群模式丰富，表达式配置， HA模式， 镜像队列模型 保证数据不丢失的前提做到高可靠性，可用性 AMQP： 高级消息队列协议 RabbitMQ 的安装以及使用 erlang socat rabbitmq-server rpm -ivh XXXXX.rpm lsof -i:5672 # 查看端口 启用控制台插件 rabbit 可以选择使用内存进行存储
RabbitMQ 核心概念 AMQP核心概念
Server：又称作Broker， 接收客户端的连接，实现AMQP实体服务
Connection： 连接， 应用程序与Broker的网络连接
Channel： 网络信道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的一个通道。客户端可以建立多个Channel，每个Channel代表一个会话任务。
Message： 消息， 服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body则就是消息体内容。
Virtual host： 虚拟地址，用于进行逻辑隔离，是最上层的消息路由。一个Virtual Host里面可以有若干个Exchange 和Queue， 同一个Virtual Host里面不能有相同名称的Exchange或Queue。
Exchange： 交换机，接收消息，根据路由键转发消息到绑定的队列
Binding： Exchange 和Queue之间的虚拟连接，binding可以包含routing key
Routing key: 一个路由规则，虚拟机可以用它来确定如何路由一个特定消息
Queue： 也称为Massage Queue, 消息队列，保存消息并将他们转发给消费者
RabbitMQ RabbitMQ默认端口号 4369 (epmd), 25672 (Erlang distribution) 4369 erlang 发现端口 25672 server间通信端口 5672, 5671 (AMQP 0-9-1 without and with TLS) client端通信口 15672 (if management plugin is enabled) 管理界面ui端口 61613, 61614 (if STOMP is enabled) 1883, 8883 (if MQTT is enabled) 生产端的可靠投递 保证消息从生产者到MQ之间的传输是100%可靠的，生产者发送的消息一定能进入消息队列</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/tools/linux/chmod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/chmod/</guid>
      <description>文件权限 文件权限表示 1drwxrwxrwx 3 root wheel 96 Oct 13 20:30 opt 2drwxr-xr-x 6 root wheel 192 Oct 8 18:57 private 3drwxr-xr-x@ 64 root wheel 2048 Oct 8 18:55 sbin 【文件或文件夹】【owner权限】【group权限】【others权限】【 文件数量】 【文件所有者】【文件所在组】【文件夹最后操作日期和时间】
d 表示文件类型为 文件夹 ， - 表示文件类型为 文本文件， l 表示链接文件 r 读权限read 4, w 写权限write 2, x 操作权限execute 1 : rwx 按二进制位置 111， 所以对应 421 修改文件权限 1chmod 权限数字 文件名 2chmod -R 744 /mnt/fileA # 表示将整个/mnt/fileA目录与其中的文件和子目录的权限都设置为744 3chmod o w xxx.xxx #表示给其他人授予写xxx.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/tools/software/Wireshark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/software/Wireshark-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Wireshark 学习笔记 WireShark的前世今生 Gerald Combs
Wireshark 是目前世界上应用最广泛的抓包工具
WIreshark 可以提供分析报告
wireshark will always be opensource
WireShark的概述与安装 网络监听软件原理 网络监听软件是一种监视网络状态、数据流程以及网络上信息传输的管理工具。 可以将网络接口设定成监听模式(混杂模式) 可以截获网络上所传输的信息 双刃剑&amp;ndash;安全问题 防止窃听的方法：加密 主要网络监听软件 常见的网络监听软件
Wireshark Tcpdump Microsoft Network Monitor Kisnet Fiddler Wireshark概述 功能 支持unix、Linux、windows、mac平台 在接口实时捕捉包 能详细显示包的详细协议信息 可以打开/保存捕捉的包 可以导入导出其他捕捉程序支持的包数据格式 可以通过多种方式过滤包 多种方式查找包 通过过滤以多种色彩显示包 创建多种统计分析 不能做的事情 不是入侵检测 ARP欺骗，但是可以观察网络发生的事情 不会处理网络事务 不会进行包的修改 Wireshark下载与安装 Windows： Winpcap + Wireshark
Linux： libpacp + Wireshark
WireShark的基本使用 界面与基本操作 示例协议包
捕获与保存 过滤与过滤表达式 过滤表达式 协议过滤
tap 只显示tcp协议 IP地址过滤
ip.src == 192.168.1.1源地址 ip.dst == 192.</description>
    </item>
    
    <item>
      <title>「6.824」 Lecture 1 Introduction</title>
      <link>https://airren.github.io/6.824/LEC_1_Introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/6.824/LEC_1_Introduction/</guid>
      <description>Distributed System Engineering parallelism
Fault tolerance
Physical
Security /isolated
Challenges:
concurrency
Partial failure
Performance
Lab
MapReduce Raft for fault tolerrance K/V server Sharding K/V servers Infrastructure
storage Communication Computation Abstraction
Implementation
RPC, Thread，Concurrency Performance
scalability , scabale to speed 2 x computer = 2X throughput Fault Tolerance
Availability Recoverability NV (non-volatile)storage /Replication Topic - Consistency
Put (key, value) Get(key) -&amp;gt; value Map Reduce What is distributed system? multiple cooperating computers storage for big web sites, MapReduce, peer-to-peer sharing, &amp;amp;c lots of critical infrastructure is distributed Why do people build distributed system?</description>
    </item>
    
    <item>
      <title>「6.824」 MapReduce</title>
      <link>https://airren.github.io/6.824/MapReduce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/6.824/MapReduce/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「Consul」Consul</title>
      <link>https://airren.github.io/component/MicroService/Consul/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/MicroService/Consul/</guid>
      <description>什么是consul Consul是用来做什么的 服务如何注册到Consul，以及如何进行服务发现 Consul部署 基于docker部署
node consul-server server consul-1 client consul-2 client 1docker run -d -p 8500:8500 -e CONSUL_BIND_INTERFACE=eth0 --name consul-server consul:1.9.4 2docker run -d -e CONSUL_BIND_INTERFACE=eth0 --name consul-1 consul:1.9.4 agent -dev -join=172.17.0.13 3docker run -d -e CONSUL_BIND_INTERFACE=eth0 --name consul-2 consul:1.9.4 agent -dev -join=172.17.0.13 4 5# docker stop consul-server consul-1 consul-2 6# docker rm consul-server consul-1 consul-2 Tips： 查看consul-server ip
1 docker exec -t consul-server ifconfig 可以通过8500端口访问UI
Server:
Client:</description>
    </item>
    
    <item>
      <title>「Daily」TaskList</title>
      <link>https://airren.github.io/interview/daily/TaskList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/TaskList/</guid>
      <description>TaskList 最短路径算法
最小生成树
深度优先遍历、广度优先遍历
KMP算法
LRU
哈弗曼树
go知识学习 参考这个文档，完整的学习一边go
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/
context 春招目标
依图
PDD
字节跳动
浦发</description>
    </item>
    
    <item>
      <title>「Docker」 Docker 常用命令</title>
      <link>https://airren.github.io/CloudNative/Docker/dock_tips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Docker/dock_tips/</guid>
      <description>centos 安装docker 把yum包更新到最新
1yum update 安装需要的软件包
1yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源
1yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 查看所有仓库中所有docker版本，并选择特定版本安装
1yum list docker-ce --showduplicates | sort -r 2 3[root@MiWiFi-R3-srv ~]# yum list docker-ce --showduplicates | sort -r 4 * updates: mirrors.aliyun.com 5Loading mirror speeds from cached hostfile 6Loaded plugins: fastestmirror 7Installed Packages 8 * extras: mirrors.aliyun.com 9docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable 10docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable 11docker-ce.x86_64 18.06.1.ce-3.el7 @docker-ce-stable 12docker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 13docker-ce.x86_64 18.03.1.ce-1.el7.centos docker-ce-stable 14docker-ce.x86_64 18.03.0.ce-1.el7.centos docker-ce-stable 15.</description>
    </item>
    
    <item>
      <title>「Docker」Docker 网络模式</title>
      <link>https://airren.github.io/CloudNative/Docker/docker_net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Docker/docker_net/</guid>
      <description>docker run创建容器时候，可以用-net指定容器的网络模式
1# host 模式 2--net=host 3# container模式 4--net=container:NameorId 5# none模式 6-net=none 7# bridge模式 8-net=bridge host 模式
如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。
例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
container 模式 这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。
none模式 这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。
bridge模式 bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.</description>
    </item>
    
    <item>
      <title>「Go」 Text Template</title>
      <link>https://airren.github.io/component/TimeSeries/go_text_template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/go_text_template/</guid>
      <description>Text and spaces </description>
    </item>
    
    <item>
      <title>「Go」ioutil</title>
      <link>https://airren.github.io/note_go/5.4ioutil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.4ioutil/</guid>
      <description>复用http.request.body
https://studygolang.com/articles/15641?fr=sideba</description>
    </item>
    
    <item>
      <title>「Go」pprof 性能分析</title>
      <link>https://airren.github.io/note_go/performance_analysis/pprof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/performance_analysis/pprof/</guid>
      <description>pprof
可以用于分析程序的性能，并找到瓶颈点。
程序中的 runtime/pprof 性能剖析工具 go tool pprof </description>
    </item>
    
    <item>
      <title>「Go」Struct</title>
      <link>https://airren.github.io/note_go/5.5Struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.5Struct/</guid>
      <description>匿名struct比较
1func main() { 2	sn1 := struct { 3	age int 4	name string 5	}{age: 11, name: &amp;#34;qq&amp;#34;} 6 7	sn2 := struct { 8	age int 9	name string 10	}{age: 11, name: &amp;#34;qq&amp;#34;} 11 12	if sn1 == sn2 { 13	fmt.Println(&amp;#34;sn1 == sn2&amp;#34;,sn1) 14	} 15 16	fmt.Printf(&amp;#34;sn1 addr %p\n&amp;#34;,&amp;amp;sn1) 17	fmt.Printf(&amp;#34;sn2 addr %p\n&amp;#34;,&amp;amp;sn2) 18} 1sn1 == sn2 {11 qq} 2sn1 addr 0xc0000a6020 3sn2 addr 0xc0000a6040 </description>
    </item>
    
    <item>
      <title>「Go」内存分配</title>
      <link>https://airren.github.io/note_go/source_code_profiling/mem_allocation/mem_allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/source_code_profiling/mem_allocation/mem_allocation/</guid>
      <description>重点剖析Go运行时的内部机制，深入了解Go运行期状态，规避GC潜在的问题，节约内存，提升运行性能
环境 Mac环境
(不建议使用，会有很多困扰，直接用Linux)
Debian环境 编译好的可执行文件真正的执行入口并不在main.go的mian()函数中。编译器总会插入一段引导代码，完成命令行参数、运行时初始化等工作才会进入用户逻辑。
编译&amp;amp;GDB调试 main.go
1package main 2 3func main() { 4	println(&amp;#34;hello world&amp;#34;) 5} -gcflags &amp;ldquo;-N -l&amp;rdquo; 关闭编译器代码优化和函数内联，避免断点和单步执行无法准确对应源码行，避免小函数和局部变量被优化掉
1go build -gcflags &amp;#34;-N -l&amp;#34; 2# go build -gcflags &amp;#34;-N -l&amp;#34; -o test main.go 通过info files可以找到程序真正的入口地址0x105a8c0 ,利用断点命令可以找到目标源文件信息。
Mac 下breakpoint 并未显示对应的文件信息，以下所有的操作均在Debian中查看。
不同的操作系统就使用不同的汇编文件
下面这这个汇编文件完成了初始化和运行时的启动动作。
调用初始化函数 创建main goroutine用于执行runtime.main 让当前线程开始执行main goroutine 至此，汇编语言针对特定平台的引导过程全部完成，后续的内容基本上都是由Go代码实现的。
go的汇编
Go ASM 和标准的汇编语法（ NASM 或 YASM ）不太一样，首先你会发现它是架构独立的，没有所谓的 32 或 64 位寄存器，如下图所示：
Tips:Mac 配置gdb环境 GDB Installation on Mac OS X</description>
    </item>
    
    <item>
      <title>「Go」逃逸分析</title>
      <link>https://airren.github.io/note_go/compile_optimize/escape_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/compile_optimize/escape_analysis/</guid>
      <description>堆内存与栈内存
Go程序会在两个地方为变量分配内存，一个是全局的堆空间用来动态分配内存，另一个是每个goroutine的栈空间。与Java、Python等语言类似，Go语言实现垃圾回收机制，所以Go语言的内存管理是自动的，通常开发者不用关心内存分配到栈上还是堆上。但是从性能的角度出发，在栈上和堆上分配内存，性能差异是非常大的。
在函数中申请一个对象，，如果分配在栈中，函数执行结束时自动回收；如果分配在堆中，则在函数结束后某个时间点进行垃圾回收。
在栈上分配和回收内存的开销很低，只需要2个cpu指令: PUSH和POP。一个是将数据push到栈空间以完成分配，pop则是释放空间。也就是说在栈上分配内存，消耗的仅是将数据copy到内存的时间。内存的I/O通常能达到30GB/s，因此在栈上分配内存的效率是非常高的。
在堆上分配内存，一个很大的额外开销则是垃圾回收。Go语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率。
参考资料：
https://geektutu.com/post/hpg-escape-analysis.html</description>
    </item>
    
    <item>
      <title>「Grafana」安装使用Grafana</title>
      <link>https://airren.github.io/component/TimeSeries/Grafana/install_grafana/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/Grafana/install_grafana/</guid>
      <description>Grafana监控面板 安装
1docker run -d --name=grafana -p 3000:3000 grafana/grafana </description>
    </item>
    
    <item>
      <title>「Hackintosh」冥王峡谷 完美黑苹果</title>
      <link>https://airren.github.io/life/nuc_perfect_hacintosh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/life/nuc_perfect_hacintosh/</guid>
      <description>冥王峡谷可以使用HacMini实现傻瓜化的完美黑苹果，目前已经完美支持Big Sur 11.1。只需额外买一个无线网卡，既可以实现WiFi、蓝牙、Airdrop和HandOff的完美使用。</description>
    </item>
    
    <item>
      <title>「HomeBrew」</title>
      <link>https://airren.github.io/tools/tips/home_brew/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/home_brew/</guid>
      <description>brew 是用于操作系统层面上的软件包的安装
gem只是管理ruby 软件</description>
    </item>
    
    <item>
      <title>「Hugo」Hugo基本使用</title>
      <link>https://airren.github.io/tools/hugo/hugo_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/hugo/hugo_basic/</guid>
      <description>hugo 增加 评论
编译&amp;amp;发布
MarkDown 语法 公式解析
引入MathJax。MathJax 是一个Javascript库，通过官方提供的CDN集成到自己的页面非常简单，只需把一下内容添加到所有的页面，例如foot.html
1&amp;lt;script type=&amp;#34;text/javascript&amp;#34; async 2 src=&amp;#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&amp;#34;&amp;gt; 3&amp;lt;/script&amp;gt; 配置文件 config.toml 代码高亮设置
1pygmentsUseClasses = true 2[markup] 3 [markup.highlight] 4 codeFences = true 5 guessSyntax = true 6 hl_Lines = &amp;#34;&amp;#34; 7 lineNoStart = 1 # display line number 8 lineNos = true 9 lineNumbersInTable = false 10 noClasses = true 11 style = &amp;#34;github&amp;#34; 12 tabWidth = 4 行号已经可以显示了，但是复制的时候会与行号一起复制，修改自定义css
1.highlight .ln { 2 width: 20px; 3 display: block; 4 float: left; 5 text-align: right; 6 user-select: none; # 表示复制是不能被选中的 7 padding-right: 8px; 8 color: #ccc; 9} </description>
    </item>
    
    <item>
      <title>「InfluxDB」</title>
      <link>https://airren.github.io/component/TimeSeries/InfluxDB/%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/InfluxDB/%E5%8E%9F%E7%90%86/</guid>
      <description>https://zhuanlan.zhihu.com/p/97247465
https://zhuanlan.zhihu.com/p/85097140
https://www.cnblogs.com/suhaha/p/11692210.html
https://www.cnblogs.com/suhaha/p/11692210.html</description>
    </item>
    
    <item>
      <title>「InfluxDB」InfluxDB 安装</title>
      <link>https://airren.github.io/component/TimeSeries/InfluxDB/install_influxdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/InfluxDB/install_influxdb/</guid>
      <description>安装InfluxDB 1docker run --name=influxdb -d -p 8086:8086 influxdb 2docker exec -it influxdb influx InfluxDB Desc 对应数据库 database 数据库 measurement 数据库中的表 point 表中的一行数据 databases
1show databases 2use iaas_metrics 3show measurements 数据查询
1select * from host_CpuBusy where time &amp;gt; now() -7d order by time limit 10; influx(&amp;ldquo;telegraf&amp;rdquo;, &amp;lsquo;&amp;lsquo;&amp;lsquo;SELECT sum(usage_system) FROM &amp;ldquo;cpu&amp;rdquo; group by &amp;ldquo;host&amp;rdquo; &amp;lsquo;&amp;rsquo;&amp;rsquo;, &amp;ldquo;20m&amp;rdquo;, &amp;ldquo;2m&amp;rdquo;, &amp;ldquo;1m&amp;rdquo;)****
grafa 配置查询influxdb
https://ken.io/note/grafana-quickstart-influxdb-datasource-graph
https://www.jianshu.com/p/f0905f36e9c3</description>
    </item>
    
    <item>
      <title>「Java」</title>
      <link>https://airren.github.io/interview/JavaNote/Automic-%E5%8E%9F%E5%AD%90%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/JavaNote/Automic-%E5%8E%9F%E5%AD%90%E7%B1%BB/</guid>
      <description>Automic 原子类 1 Atomic 原子类介绍 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所以，所谓原子类说简单点就是具有原子/原子操作特征的类。
并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。
根据操作的数据类型，可以将JUC包中的原子类分为4类
基本类型
使用原子的方式更新基本类型
AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean ：布尔型原子类 数组类型
使用原子的方式更新数组里的某个元素
AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray ：引用类型数组原子类 引用类型
AtomicReference：引用类型原子类 AtomicReferenceFieldUpdater：原子更新引用类型里的字段 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型
AtomicIntegerFieldUpdater:原子更新整型字段的更新器 AtomicLongFieldUpdater：原子更新长整型字段的更新器 AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 CAS ABA 问题
描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。 例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！ 代码例子（以AtomicInteger为例） 1import java.</description>
    </item>
    
    <item>
      <title>「JetBrains」 GoLand技巧</title>
      <link>https://airren.github.io/tools/tips/goland/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/goland/</guid>
      <description>自动补齐json Format 通过SFTP同步本地与远端代码 Preference&amp;gt;Build,Execution,Deployment&amp;gt;SFTP
Go 远程Debug https://github.com/derekparker/delve</description>
    </item>
    
    <item>
      <title>「K8s」Kubernates 安装</title>
      <link>https://airren.github.io/CloudNative/Kubernates/KubernatesInstall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/KubernatesInstall/</guid>
      <description>环境准备 K8s 只能基于Linux环境部署，用Win/Mac的小伙伴们怎么在自己的PC上Setup环境呢。此时就推荐Canonical家的Multipass了，Canonical 是谁，当然是Ubuntu的母公司了。
安装 kubelet kubeadm kubectl 官方文档
1sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https curl 2curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - 3cat &amp;lt;&amp;lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list 4deb https://apt.kubernetes.io/ kubernetes-xenial main 5EOF 6sudo apt-get update 7sudo apt-get install -y kubelet kubeadm kubectl 8sudo apt-mark hold kubelet kubeadm kubectl # 设置为不再更新 初始化 1swapoff -a 2kubeadm init ctl 3# kubeadm config images pull --v=10 4 # 国内正常网络不能从k8s.</description>
    </item>
    
    <item>
      <title>「LeetCode」LeetCode</title>
      <link>https://airren.github.io/DataStruct/LeetCode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/LeetCode/</guid>
      <description>1 1 package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	fmt.Println(twoSum([]int{2, 7, 11, 15}, 9)) 7} 8 9func twoSum(nums []int, target int) []int { 10 11	maps := make(map[int]int) 12 13	for i, value := range nums { 14	mid := target - value 15 16	res, ok := maps[mid] 17	if ok { 18	return []int{res, i} 19	} else { 20	maps[value] = i 21	} 22	} 23	return []int{} 24} 120.</description>
    </item>
    
    <item>
      <title>「Linux」 Make</title>
      <link>https://airren.github.io/tools/linux/make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/make/</guid>
      <description>1.PHONY: clean # .PHONY后面的target表示一个伪造的target，而不是真实存在的文件的target 2clean: 3	rm -rf *.out </description>
    </item>
    
    <item>
      <title>「Linux」Grep</title>
      <link>https://airren.github.io/tools/linux/grep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/grep/</guid>
      <description>The grep filter searches a file for a particular pattern of characters, and displays all lines that contain that pattern. The pattern that is searched in the file is referred to as the regular expression (grep stands for globally search for regular expression and print out).
Syntax:
1grep [options] pattern [files] 1Options Description 2-c : This prints only a count of the lines that match a pattern 3-h : Display the matched lines, but do not display the filenames.</description>
    </item>
    
    <item>
      <title>「Linux」Systemd</title>
      <link>https://airren.github.io/tools/linux/systemd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/systemd/</guid>
      <description>守护进程
http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html</description>
    </item>
    
    <item>
      <title>「Linux」xargs</title>
      <link>https://airren.github.io/tools/linux/xorgs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/xorgs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>「Mac」Mac初始化</title>
      <link>https://airren.github.io/tools/mac/mac_init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/mac/mac_init/</guid>
      <description>文本工具 Typora 效率相关 Karabiner 开发相关 goland Brew go git iterm2 Alfred ohmyzsh vim docker Kitematic .virmrc 1syntax on 2set nu 3inoremap jj &amp;lt;ESC&amp;gt; git
1git config --global init.defaultBranch main </description>
    </item>
    
    <item>
      <title>「Mac」Mac初始化</title>
      <link>https://airren.github.io/tools/tips/mac_init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/mac_init/</guid>
      <description>文本工具 Typora 效率相关 Karabiner 开发相关 goland Brew go git iterm2 Alfred ohmyzsh vim docker Kitematic .virmrc 1syntax on 2set nu 3inoremap jj &amp;lt;ESC&amp;gt; </description>
    </item>
    
    <item>
      <title>「Multipass」虚拟机管理工具</title>
      <link>https://airren.github.io/tools/tips/multipass/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/multipass/</guid>
      <description>好久没有在虚拟机上做一些学习开发的工作了，最近由于换工作，开始学习k8s。尝试在虚拟机上进行k8s环境的部署。打开Ubuntu 网站下载镜像的时候看到了Multipass，于是就尝试一下吧。
类Docker的设计，确实好用。</description>
    </item>
    
    <item>
      <title>「MVC」 Web服务的MVC设计模式</title>
      <link>https://airren.github.io/tech/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/web_mvc_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/web_mvc_pattern/</guid>
      <description>https://blog.csdn.net/u013594528/article/details/80859443?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase
https://blog.csdn.net/u013594528/article/details/80859443?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase</description>
    </item>
    
    <item>
      <title>「NIO」网络IO</title>
      <link>https://airren.github.io/interview/cs_basic/net_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/cs_basic/net_io/</guid>
      <description>NIO
epoll linux
mac
windows</description>
    </item>
    
    <item>
      <title>「OS」操作系统之基础</title>
      <link>https://airren.github.io/os/base_of_os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/os/base_of_os/</guid>
      <description>1.操作系统概述 什么是操作系统？
操作系统就是组织所有的硬件，为用户程序提供调用接口的代码。是计算机硬件与应用之间的一层软件。封装了对硬件调用的实现，以及进程的管理。
硬件管理分类：
CPU管理、内存管理、终端管理、磁盘管理、文件管理
网络管理、电源管理、多核管理
计算机硬件组成如图
我们学习一门编程语言，最先学习的就是打印“Hello World”。
计算机把代码加载到内存，通过PCI总线将数据写入显存地址，图形控制器将数据显示到面板。
对操作系统的学习需要掌握以下几点
系统调用: 使用显示器 print； 使用CPU：fork； 使用文件： open、read
一段文字是如何写到磁盘上的
成为掌握计算机关键技术的工程师，而不是仅仅调用API的工程师。
Lab1: 扩展线程 实现线程调度 Lab2: 实现系统调用 将整个接口剥掉，添加 Lab3: 实现虚存管理 扩展实现内存管理 Lab4: 扩展文件系统 扩展实现一个文件管理 知名计算机高校
CMU Carnegie Mellon University: 卡内基·梅隆大学
MIT Massachusetts Institute of Technology： 麻省理工学院
Leland Stanford Junior University 斯坦福大学
&amp;ldquo;Learn OS concepts by coding them!!!&amp;rdquo;
2. 操作系统引导 从打开电源开始，操作系统做了什么？
计算机怎么工作的
不要总等着别人告诉你答案，尽量自己去寻找
从知识和常识出发进行推理，思索
图灵机-&amp;gt; 通用图灵机
前缀表达式
后缀表达式
自动机
PC program counter
取指执行
、</description>
    </item>
    
    <item>
      <title>「Prom」PromeQL</title>
      <link>https://airren.github.io/component/TimeSeries/Prometheus/prome_ql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/Prometheus/prome_ql/</guid>
      <description>打点类型
Counter
Guage
Histogram
查询方式</description>
    </item>
    
    <item>
      <title>「Prom」Prometheus 安装及使用简介</title>
      <link>https://airren.github.io/component/TimeSeries/Prometheus/prom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/Prometheus/prom/</guid>
      <description>Prom Intro Prometheus 是SoundCloud开源的系统监控和报警工具集。通过Prometheus可以进行时序数据的采集、监控和报警。
时序数据模型 Time Series Data Model Metric 是一个对时序指标的统称，例如.：http_requests_total - the total number of HTTP requests received，就可以称为一条Metric
在Prometheus 中每一个时序序列(time-series)都是由于Metric Name 和Key-Value组成的
例如：
1http_request_total{host=192.168.2.1,status=200} Metric Name： http_request_total 在Prometheus中Metric Name只能由大小写字母、数字、下划线、冒号组成，且不能以数字开头，对应正则为[a-zA-Z_:][a-zA-Z0-9_:]*。冒号保留，会在定义规则的时候使用。
Label Name: host 和status都属于Label. 在Prometheus中Label Name只能由大小写字母、数字、下划线组成，且不能以数字开头，对应的正则为[a-zA-Z_][a-zA-Z0-9_]*。一般_开头的Labels保留位系统内部使用。
Notation
1&amp;lt;Metric Name&amp;gt;{&amp;lt;Label Name&amp;gt;=&amp;lt;Label Value&amp;gt;,...} 2api_http_request_total{method=&amp;#34;POST&amp;#34;, handler=&amp;#34;/messages&amp;#34;} # 同OpenTSDB 3 4node_cpu_seconds_total{cpu=&amp;#34;2&amp;#34;,mode=&amp;#34;system&amp;#34;} 195721.31 1&amp;lt;--- metric name------&amp;gt;&amp;lt;-----lable set------&amp;gt;&amp;lt;-timestamp -&amp;gt;&amp;lt;-value-&amp;gt; 2node_cpu_seconds_total{cpu=&amp;#34;2&amp;#34;,mode=&amp;#34;system&amp;#34;}@1434417560938 195721.31 3# timestamp 是毫秒级时间戳 4# value 有且只有一个 float64 __ 作为前缀标签，只能在系统内部使用。 Prome底层实现指标名称是以__name__=&amp;lt;metric name&amp;gt;形式存储的，以下两种表达方式是相同的。
1api_http_request_total{method=&amp;#34;POST&amp;#34;, handler=&amp;#34;/messages&amp;#34;} 2{__name_=api_http_request_total, method=&amp;#34;POST&amp;#34;, handler=&amp;#34;/messages&amp;#34;} Component 所有基础组件的安装都基于Docker。</description>
    </item>
    
    <item>
      <title>「Regex」正则表达式</title>
      <link>https://airren.github.io/tools/linux/regex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/regex/</guid>
      <description>正则表达式主要用来进行字符串匹配操作
1^[0-9]+abc$ 2# ^ 表示以xxx开头的字符串 3# [0-9] 表示匹配0-9之间的一个数字，例如 8； [0-9]+表示匹配0-9之间的多个数字，例如：867 4# abc$ 表示以abc结尾的字符串，$表示以xxx结尾 1^[a-z0-9_-]{5,16}$ 2# 只能含有小写字母，数字，下划线,减号，且长度为5-16的字符串 字符 Description . 除了\r \n以外的任何单字符 \w 匹配字母、数字、下划线，等价于[A-Za-Z0-9_] * 匹配前面的子表达式零次或者多次 </description>
    </item>
    
    <item>
      <title>「SSH」Iterm ssh长时间卡死</title>
      <link>https://airren.github.io/tools/tips/ssh_stuck/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/ssh_stuck/</guid>
      <description>1sudo vi /etc/ssh/ssh_config 2 3# 增加如下两行 4ServerAliveInterval 50 #每隔50秒就向服务器发送一个请求 5ServerAliveCountMax 3 #允许超时的次数，一般都会响应 6 7vim /etc/ssh/sshd_config 8，找到ClientAliveInternal 将后面的数字0改为60 ，注意去掉前面的#，因为如果最前面是井号的话是注释掉的 Iterm ssh 导致卡死
1vi /etc/ssh/ssh_config 2# 增加如下两行 3ServerAliveInterval 60 4ServerAliveCountMax 2 </description>
    </item>
    
    <item>
      <title>「Swagger」 Gin 项目使用swagger</title>
      <link>https://airren.github.io/tech/web/gin/swagger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tech/web/gin/swagger/</guid>
      <description>安装并使用Swaggo testsetes
1go get -u -x github.com/swaggo/swag/cmd/swag Gin中使用Swagger</description>
    </item>
    
    <item>
      <title>「Telegraf」 Telegraf</title>
      <link>https://airren.github.io/component/TimeSeries/TeleGraph/telegraph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/TeleGraph/telegraph/</guid>
      <description> Telegraf is an agent for collecting metrics and writing the to InfluxDB or other outputs.
Install
1docker run -d --name telegraf --net=container:influxdb telegraf </description>
    </item>
    
    <item>
      <title>「tmux」虚拟终端</title>
      <link>https://airren.github.io/tools/linux/tmux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/linux/tmux/</guid>
      <description>​	当使用ssh 连接一台远程计算机的时候，如果此时正在执行一个进程，突然断网了，那么这个进程也会被迫中断了。当重新ssh连接到这台远程计算机的时候，已经找不到之前正在执行的进程了。因为上一次连接的会话(Session)已经终止， 这次的重新连接又新建了一个会话。如果你遇到过这种问题你就会发现： 会话和进程是绑定的，会话终止，当前正在执行的进程也会终止。
​	为了解决上述问题，你可以尝试使用下Tmux。
安装及基本使用 1# 安装在需要远程连接的远程服务器上 2apt install tmux 1# 新建 2tmux new -s &amp;lt;session name&amp;gt; 3 4# 切换到某个session 5tmux attach -t &amp;lt;session name&amp;gt; 6 7# 退出某个session，依旧保留进程 8tmux detach 9 10# 分隔窗口 11tmux split-window 12tmux split-window -h # 水平分隔 13 14# 切换窗口 【Ctrl】+【b】 然后按下 【；】 快捷键 前缀键 【Ctrl】+【b】。先按下前缀键后，在使用功能键。
copy-mode use vi shortcuts 1cat &amp;lt;&amp;lt;EOF | tee -a ~/.tmux.conf 2setw -g mode-keys vi 3set -g @plugin &amp;#39;tmux-plugins/tpm&amp;#39; 4set -g @plugin &amp;#39;tmux-plugins/tmux-sensible&amp;#39; 5set -g @plugin &amp;#39;tmux-plugins/tmux-resurrect&amp;#39; 6 7run &amp;#39;~/.</description>
    </item>
    
    <item>
      <title>「TSDB」时序数据&amp;时序数据库简介</title>
      <link>https://airren.github.io/component/TimeSeries/OpenTSDB/opentsdb_introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/TimeSeries/OpenTSDB/opentsdb_introduction/</guid>
      <description>什么是时序数据？
时序数据的应用场景和特征？
时序数据库？
时序数据 时序数据，就是与时间强相关度的一系列数据。关注的是某一时刻的数据值，而不是最终的数据。是一个过程而不是一个结果。时序数据描述的是一个数据（指标）在时间维度上的变化。例如： 股票K线、环境监测。
时序数据的特征：
数据以一定的时间间隔产生，生产速率稳定。 写入多，查询少 时序数据不允许更新 时序数据主要是按时间范围查询 时序数据库 传统的数据库并不适合存储时序数据，针对时序数据的特征，时序数据库的基本要求如下：
支持高并发、高吞吐量的写入 支持海量数据存储 高可用（时序数据在互联网公司常用作报警数据源） 支持复杂的多维度的查询 易于横向扩展 常见的时序数据库
时序数据基本概念 一条时序数据是由多个DataPoint构成的。每个DataPoint包含以下几个方面
metric： 一般也叫metric name，是时序数据的指标名
tags: 一个或者多个tag组合，用户描述metric的不同维度。每个Tag由tagk&amp;amp;tagv组成。例如：一个请求的来源 host=10.20.178.23，dc=cn。tags标明数据的维度。
value： 表示对应的数值。例如：请求的latency 或者qps等。
timestamp： 时序数据的具体时间，可以是秒级或者毫秒级别的Unix时间戳。
例如： JVM_Heap_Memory_Usage_MB{host=127.0.0.1, instanceId=jvm01}
Downsampling</description>
    </item>
    
    <item>
      <title>「VSCode」Vs Code 使用技巧</title>
      <link>https://airren.github.io/tools/tips/vscode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/tips/vscode/</guid>
      <description>https://geek-docs.com/vscode/vscode-tutorials/vscode-workspace-switch.html
https://zhuanlan.zhihu.com/p/188499395
Ctrl +K Ctrl +S Keyboard Shortcuts
切换区域的快捷键 -&amp;gt; Focus on
区域 key Focus on folders view Ctrl + K L Focus on Open Editors View Ctrl + K E Focun on Terminal View Ctrl +K K Extensions Usage Extension Spell checker Code spell checker </description>
    </item>
    
    <item>
      <title>「XiaoKr」小氪机器人</title>
      <link>https://airren.github.io/life/xiaokr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/life/xiaokr/</guid>
      <description>PCB设计 </description>
    </item>
    
    <item>
      <title>「剑指offer」 Go语言版本</title>
      <link>https://airren.github.io/DataStruct/%E5%89%91%E6%8C%87offer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/%E5%89%91%E6%8C%87offer/</guid>
      <description>编码过程中首先要校验输入数据的合法性。
写代码之前首先想好有哪些测试用例，要提高代码的测试覆盖率。
3. 数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
2 &amp;lt;= n &amp;lt;= 100000
如果使用Map，则时间复杂度为O(n), 空间复杂度为O(n)。题目中的关键信息为长度为n的数组，且所有数字都在0~n-1的范围内，所以可以不用额外开辟空间。
1func findRepeatNumber(nums []int) int { 2	var tmp int 3	for i, v := range nums { 4	if v != i { 5	if nums[v] == v { 6	return v 7	} 8	tmp = nums[v] 9	nums[v] = v 10	nums[i] = tmp 11	} 12	} 13	return -1 14} 15 16// 时间复杂度为O(n),空间复杂读为O(1) 4.</description>
    </item>
    
    <item>
      <title>「心晴」</title>
      <link>https://airren.github.io/life/do_not_mazy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/life/do_not_mazy/</guid>
      <description>永远不要让别人影响你的心晴
学习好的地方，
摒弃坏的地方，
不要被同化
To Be A Nice Person.</description>
    </item>
    
    <item>
      <title>「算法」贪心算法</title>
      <link>https://airren.github.io/DataStruct/ds_greed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_greed/</guid>
      <description>例题 【简单】n个活动时间，选择可以参与最多的活动
优先选择结束最早的活动
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sort&amp;#34; 6) 7 8type node struct { 9	startAt int 10	endAt int 11} 12 13var ( 14	total int 15	now int 16	res int 17	nodeList = make([]node, 0) 18) 19 20func main() { 21	_, _ = fmt.Scanf(&amp;#34;%d&amp;#34;, &amp;amp;total) 22	nodeList = make([]node, total) 23	for i := 0; i &amp;lt; total; i++ { 24	_, _ = fmt.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」Tree</title>
      <link>https://airren.github.io/DataStruct/06_ds_tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/06_ds_tree/</guid>
      <description>单链表的查询时间复杂度是O(n)
跳表
树
图
Linked List 是特殊化的Tree
Tree 是特殊化的图
斐波那契， 状态树，递归树
状态树空间
决策树空间
二叉树 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上。
完全二叉树:
存储结构:
链式存储
1// golang 2type Node struct { 3	Data int64 4	LeftNode *Node 5	RightNode *Node 6} // C++ struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(NULL), right(NULL){} }
1 23. ```java 3public class TreeNode{ 4 public int val; 5 public TreeNode left,right; 6 public TreeNode(int val){ 7	this.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」排列组合</title>
      <link>https://airren.github.io/DataStruct/ds_combine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_combine/</guid>
      <description>组合 1import java.util.*; 2 3public class Mains{ 4 public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; resultss = new ArrayList&amp;lt;&amp;gt;(); 5 6 public void combinations(List&amp;lt;Integer&amp;gt; selected, List&amp;lt;Integer&amp;gt; data, int num){ 7 if(num == 0){ 8 resultss.add(new ArrayList&amp;lt;Integer&amp;gt;(selected)); 9 return; 10 } 11 if(data.size() == 0 ){ 12 System.out.print(&amp;#34;&amp;#34;); 13 return; 14 } 15 selected.add(data.get(0)); 16 combinations(selected, data.subList(1, data.size()), num -1); 17 selected.remove(data.get(0)); 18 combinations(selected, data.subList(1, data.size()), num ); 19 } 20 public static void main(String[] args) { 21 Mains combin = new Mains(); 22 int[] nums = new int[]{1,2,3,4,5}; 23 combin.</description>
    </item>
    
    <item>
      <title>「算法与数据结构」排序算法</title>
      <link>https://airren.github.io/DataStruct/ds_sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_sort/</guid>
      <description>排序算法 术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内部排序：待排序的数据可以全部放入内存中；
外部排序：待排序数据的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存(磁盘)进行访问；
时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小。
排序算法总结 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n^2^) O(n) O(n^2^) O(1) In-place 稳定 选择排序 O(n^2^) O(n^2^) O(n^2^) O(1) In-place 不稳定 插入排序 O(n^2^) O(n) O(n^2^) O(1) In-place 稳定 希尔排序 O(n logn) O(nlog^2^n) O(nlog^2^n) O(1) In-place 不稳定 归并排序 O(n logn) O(n logn) O(n logn) O(n) Out-place 稳定 快速排序 O(n logn) O(n logn) O(n^2^) O(n logn) In-place 不稳定 堆排序 O(n logn) O(n logn) O(n logn) O(1) In-place 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) Out-place 稳定 桶排序 O(n+k) O(n+k) O(n^2^) O(n+k) Out-place 稳定 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) Out-place 稳定 n:数据规模；k:&amp;ldquo;桶&amp;quot;的个数；n-place:占用常数内存，不占用额外内存；Out-place:占用额外内存</description>
    </item>
    
    <item>
      <title>「算法与数据结构」查找算法</title>
      <link>https://airren.github.io/DataStruct/ds_find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_find/</guid>
      <description>二分查找 1public class BinarySearch{ 2 public static void main(String[] args) { 3 int[] arr = {1,2,3,4,5,6,7,8}; 4 int k = 8; 5 System.out.println(binarySerach(arr, k)); 6 } 7 8 public static int binarySerach(int[] arr, int k){ 9 int a = 0; 10 int b = arr.length; 11 12 while(a &amp;lt; b){ 13 int mid = a+(b-a)/2; 14 if(k &amp;lt; arr[mid]){ 15 b = mid; 16 }else if(k &amp;gt; arr[mid]){ 17 a = mid + 1; 18 }else{ 19 return mid; 20 } 21 } 22 return -1; 23 24 } 25} </description>
    </item>
    
    <item>
      <title>「算法与数据结构」链表</title>
      <link>https://airren.github.io/DataStruct/ds_linkedlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/ds_linkedlist/</guid>
      <description>单向链表 1import java.util.*; 2class Node{ 3 private final int value; 4 private Node next; 5 6 public Node(int value){ 7 this.value = value; 8 this.next = null; 9 } 10 public int getValue(){ 11 return this.value; 12 } 13 public Node getNext(){ 14 return this.next; 15 } 16 public void setNext(Node next){ 17 this.next = next; 18 } 19 20 public static void printLinkedList(Node head){ 21 while(head != null){ 22 System.</description>
    </item>
    
    <item>
      <title>「网络」网络基础</title>
      <link>https://airren.github.io/blog/network_base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_base/</guid>
      <description>What is the network layer? Network-to-network connections are what make the Internet possible. The &amp;ldquo;network layer&amp;rdquo; is the part of the Internet communications process where these connections occur, by sending packets of data back and forth between different networks, In the 7-layer OSI model, the network layer is layer 3. The Internet Protocol(IP) is one of the main protocols used at this layer, along with several other protocols for routing, resting and encryption.</description>
    </item>
    
    <item>
      <title>「装机」 ITX A4机箱设计</title>
      <link>https://airren.github.io/life/itx_%E6%9C%BA%E7%AE%B1%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/life/itx_%E6%9C%BA%E7%AE%B1%E8%AE%BE%E8%AE%A1/</guid>
      <description>ITX机箱 详设计一个属于自己的ITX机箱
装机清单 参考链接 ITX机箱图纸参考链接 https://sff.design/1210.html https://sff.design/15201.html ACC X11参考链接 https://item.jd.com/10024295444328.html#crumb-wrap
gpp https://www.kyairsoft.com/4-3-desert-warrior-full-marking.html</description>
    </item>
    
    <item>
      <title>「计算机网络」 计算机网络串讲</title>
      <link>https://airren.github.io/interview/cs_basic/network_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/cs_basic/network_basic/</guid>
      <description>网络硬件 双绞线 类型 五类线CAT5 超五类线CAT5e 六类线CAT6 超六类线CATT6e 七类线CAT7 频率带宽 100MHz 100MHz 200MHz 500MHz 600MHz 传输速率 100Mbps 1000Mbps 1000Mbps 1Gbps 10Gbps 最大长度 100m 100m 100m 55m 屏蔽类型 屏蔽/非屏蔽 屏蔽/非屏蔽 屏蔽/非屏蔽 屏蔽/非屏蔽 双层屏蔽 双绞线线序 直通，交叉(主要用于对等设备的通信)
标准 1 2 3 4 5 6 7 8 EIA/TIA 568A 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕 EIA/TIA 568B 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕 </description>
    </item>
    
    <item>
      <title>【Linux】 Systemd</title>
      <link>https://airren.github.io/blog/linux_systemd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux_systemd/</guid>
      <description>1# 通过Pid获取对应的service 2systemd status &amp;lt;Pid&amp;gt; </description>
    </item>
    
    <item>
      <title>【慕课网】Go开发短地址服务</title>
      <link>https://airren.github.io/note_go/99_go_short_addr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_go_short_addr/</guid>
      <description>1 短地址服务 将长地址缩短到一个很短的地址，用户访问这个短地址可以重定向到原本的长地址。
如何设计HTTP Router 和handler 如何在HTTP 处理流程中加入Middleware 如何利用Go的Interface来实现可扩展的设计 如何使用redis的自增长序列生成短地址 2 主服务模块 API接口 POST /api/shorten GET /api/info?shortlink=shortlink GET /:shortlink - return 302 code 重定向 POST /api/shorten Params
Name Type Description url string Required. URL to shorten. e.g. https://www.example.com expiration_in_minutes int Required. Expiration of short link in minutes. e.g. value 0 represents permanent. Response
1{ 2 &amp;#34;shortlink&amp;#34;:&amp;#34;P&amp;#34; 3} GET /api/info?shortlink=shortlink Params
Name Type Description shortlink string Required. Id of shortened. e.g. P Response</description>
    </item>
    
    <item>
      <title>2021-03-12</title>
      <link>https://airren.github.io/interview/daily/2021-03-12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-12/</guid>
      <description>Golang
以下代码的输出内容 1package main 2import ( 3	&amp;#34;fmt&amp;#34; 4) 5 6func main() { 7	deferCall() 8} 9func deferCall() { 10	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; before&amp;#34;) }() 11	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; in process&amp;#34;) }() 12	defer func() { fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt; done&amp;#34;) }() 13	panic(&amp;#34;&amp;lt;&amp;lt;&amp;lt; panic here&amp;#34;) 14} 输出结果如下
1&amp;gt;&amp;gt;&amp;gt; done 2&amp;gt;&amp;gt;&amp;gt; in process 3&amp;gt;&amp;gt;&amp;gt; before 4panic: &amp;lt;&amp;lt;&amp;lt; panic here defer执行的顺序是后进先出, 压栈。当出现panic的时候，会按照defer的后进先出的顺序执行，最后才会执行panic。
defer是一个压栈过程。
这段代码的输出，以及原因 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	slice := []int{0, 1, 2, 3} 7	m := make(map[int]*int) 8 9	for key, val := range slice { 10	m[key] = &amp;amp;val 11	} 12 13	for k, v := range m { 14	fmt.</description>
    </item>
    
    <item>
      <title>2021-03-13</title>
      <link>https://airren.github.io/interview/daily/2021-03-13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-13/</guid>
      <description>Golang
下面两段代码输出什么 1// 1. 2 func main() { 3 s := make([]int, 5) 4 s = append(s, 1, 2, 3) 5 fmt.Println(s) 6 } 7 8// 2. 9 func main() { 10 s := make([]int,0) 11 s = append(s,1,2,3,4) 12 fmt.Println(s) 13} 输出结果如下
1[0 0 0 0 0 1 2 3] 2[1 2 3 4] 使用make 新建 slice 会根据初始化的容量补0
这段代码的问题 1 func funcMui(x,y int)(sum int,error){ 2 return x+y,nil 3 } 有多个返回值的时候，返回值的名字要么全部省略，要么全部写上</description>
    </item>
    
    <item>
      <title>2021-03-14</title>
      <link>https://airren.github.io/interview/daily/2021-03-14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-14/</guid>
      <description>Golang
使用channel实现简单并发，注意执行顺序
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sync&amp;#34; 6	&amp;#34;time&amp;#34; 7) 8 9var wg sync.WaitGroup 10 11func printer(ch chan int) { 12	for i := range ch { 13	fmt.Printf(&amp;#34;Received %d \n&amp;#34;, i) 14	&amp;lt;-time.After(time.Second / 5) 15	fmt.Printf(&amp;#34;Job %v done \n&amp;#34;, i) 16	} 17	println(&amp;#34;All Jobs done&amp;#34;) 18	wg.Done() 19	println(&amp;#34;Finished&amp;#34;) 20} 21 22// main is the entry point for the program. 23func main() { 24	c := make(chan int) 25	go printer(c) 26	wg.</description>
    </item>
    
    <item>
      <title>2021-03-15</title>
      <link>https://airren.github.io/interview/daily/2021-03-15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-15/</guid>
      <description>Golang
获取变量的数据类型
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;reflect&amp;#34; 6) 7 8func main() { 9 10	// string type : string 11	var1 := &amp;#34;hello world&amp;#34; 12 13	// integer : int 14	var2 := 10 15 16	// float : float64 17	var3 := 1.55 18 19	// boolean : bool 20	var4 := true 21 22	// shorthand string array declaration : []string 23	var5 := []string{&amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;baz&amp;#34;} 24 25	// map is reference datatype : map[string]string 26	var6 := map[int]string{100: &amp;#34;Ana&amp;#34;, 101: &amp;#34;Lisa&amp;#34;, 102: &amp;#34;Rob&amp;#34;} 27 28	// complex64 and complex128 29	// is basic datatype : complex128 30	var7 := complex(9, 15) 31 32	// using %T format specifier to 33	// determine the datatype of the variables 34 35	fmt.</description>
    </item>
    
    <item>
      <title>2021-03-16</title>
      <link>https://airren.github.io/interview/daily/2021-03-16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-16/</guid>
      <description>Golang
同时定义多个相关的struct, 这样写可读性更好一些
1type ( 2	// item defines the fields associated with the item tag 3	// in the rss document. 4	item struct { 5	XMLName xml.Name `xml:&amp;#34;item&amp;#34;` 6	PubDate string `xml:&amp;#34;pubDate&amp;#34;` 7	Title string `xml:&amp;#34;title&amp;#34;` 8	Description string `xml:&amp;#34;description&amp;#34;` 9	Link string `xml:&amp;#34;link&amp;#34;` 10	GUID string `xml:&amp;#34;guid&amp;#34;` 11	GeoRssPoint string `xml:&amp;#34;georss:point&amp;#34;` 12	} 13 14	// image defines the fields associated with the image tag 15	// in the rss document.</description>
    </item>
    
    <item>
      <title>2021-03-17</title>
      <link>https://airren.github.io/interview/daily/2021-03-17/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-17/</guid>
      <description>Golang
1// A map of registered matchers for searching. 2var matchers = make(map[string]Matcher) 3 4// Run performs the search logic. 5func Run(searchTerm string) { 6	// Retrieve the list of feeds to search through. 7	feeds, err := RetrieveFeeds() 8	if err != nil { 9	log.Fatal(err) 10	} 11 12	// Create an unbuffered channel to receive match results to display. 13	results := make(chan *Result) 14 15	// Setup a wait group so we can process all the feeds.</description>
    </item>
    
    <item>
      <title>2021-03-xx</title>
      <link>https://airren.github.io/interview/daily/2021-03-xxxx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-xxxx/</guid>
      <description>Golang</description>
    </item>
    
    <item>
      <title>2021-04-20</title>
      <link>https://airren.github.io/interview/daily/2021-04-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-04-20/</guid>
      <description>Flush
清空缓冲区
首先，咱们设想要给鱼缸换水，所以需要一个水泵，水泵是连接鱼缸和下水道的，咱们的任务就是将鱼缸里面水全抽干，这时，我们就可以把水管当做缓冲区。如果咱们一见鱼缸里面水抽干了就立马关了水泵，这时会发现水管里还有来不及通过水泵流向下水道的残留水，我们可以把抽水当做读数据，排水当做写数据，水管当做缓冲区，这样就容易明白了。
那么这样一来我们如果中途调用close()方法，输出区也还是有数据的，就像水缸里有水，只是在缓冲区遗留了一部分，这时如果我们先调用flush()方法，就会强制把数据输出，缓存区就清空了，最后再关闭读写流调用close()就完成了。
缓冲区可以简单地理解为一段内存区域。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。
https://blog.csdn.net/qq_38129062/article/details/87115620</description>
    </item>
    
    <item>
      <title>2021-04-21</title>
      <link>https://airren.github.io/interview/daily/2021-03-21/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-03-21/</guid>
      <description>Flush
清空缓冲区
首先，咱们设想要给鱼缸换水，所以需要一个水泵，水泵是连接鱼缸和下水道的，咱们的任务就是将鱼缸里面水全抽干，这时，我们就可以把水管当做缓冲区。如果咱们一见鱼缸里面水抽干了就立马关了水泵，这时会发现水管里还有来不及通过水泵流向下水道的残留水，我们可以把抽水当做读数据，排水当做写数据，水管当做缓冲区，这样就容易明白了。
那么这样一来我们如果中途调用close()方法，输出区也还是有数据的，就像水缸里有水，只是在缓冲区遗留了一部分，这时如果我们先调用flush()方法，就会强制把数据输出，缓存区就清空了，最后再关闭读写流调用close()就完成了。
缓冲区可以简单地理解为一段内存区域。可以简单地把缓冲区理解为一段特殊的内存。某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。
https://blog.csdn.net/qq_38129062/article/details/87115620</description>
    </item>
    
    <item>
      <title>2021-05-20</title>
      <link>https://airren.github.io/interview/daily/2021-05-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-20/</guid>
      <description> 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5var testMap = map[string]map[string]struct { 6	Name string 7}{ 8	&amp;#34;first&amp;#34;: {&amp;#34;second&amp;#34;: {Name: &amp;#34;12312&amp;#34;}}, 9	&amp;#34;second&amp;#34;: {&amp;#34;second&amp;#34;: {&amp;#34;12312&amp;#34;}}, 10} 11 12func main() { 13	d := testMap[&amp;#34;first&amp;#34;][&amp;#34;second&amp;#34;].Name 14	fmt.Printf(&amp;#34;++-%v-++\n&amp;#34;, d) 15 16 17 // map 不会报 nil 18	c := testMap[&amp;#34;first22&amp;#34;][&amp;#34;second&amp;#34;].Name 19	fmt.Printf(&amp;#34;++-%v-++\n&amp;#34;, c) 20} 结果
1++-12312-++ 2++--++ </description>
    </item>
    
    <item>
      <title>2021-05-26</title>
      <link>https://airren.github.io/interview/daily/2021-05-26/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-26/</guid>
      <description>rwarestse ewartawe
-gcflags=-l
1. 线上的配置文件写在了哪里 1GOMAXPROCS = 8 2TSDB_HOST = bytetsd-query-server-prod-ppe-va.byted.org 3 4 5# influxdb 配置 本地如何调试 一些特殊的token的解析 NaNAsZero, not_sliteral_or, nullAsZero 是否还可以rebase bosun开源版本 ui fenbu cs Trace bytetrace
expr （context） trace 对齐其他语言的框架， 例如ginex context
state &amp;ndash;&amp;gt; context
inf.bytesd.bosun
Log slog
Error errors 业务状态码
err
静态
非200
5001 执行失败，动态参数解析失败， duration， 计算错误
5002 runtime panic
5003 panic string
对齐trace
新加的一些函数 funcs.go
pprof 8071</description>
    </item>
    
    <item>
      <title>2021-05-26</title>
      <link>https://airren.github.io/interview/daily/2021-05-27/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-05-27/</guid>
      <description>rwarestse ewartawe
-gcflags=-l
1. 线上的配置文件写在了哪里 1GOMAXPROCS = 8 2TSDB_HOST = bytetsd-query-server-prod-ppe-va.byted.org 3 4 5# influxdb 配置 本地如何调试 一些特殊的token的解析 NaNAsZero, not_sliteral_or, nullAsZero 是否还可以rebase bosun开源版本 ui fenbu ssssTrace bytetrace
expr （context） trace 对齐其他语言的框架， 例如ginex context
state &amp;ndash;&amp;gt; context
inf.bytesd.bosun
Log slog
Error errors 业务状态码
err
静态
非200
5001 执行失败，动态参数解析失败， duration， 计算错误
5002 runtime panic
5003 panic string
对齐trace
新加的一些函数 funcs.go
pprof 8071</description>
    </item>
    
    <item>
      <title>2021-06-01</title>
      <link>https://airren.github.io/interview/daily/2021-06-01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/interview/daily/2021-06-01/</guid>
      <description>sync.pool</description>
    </item>
    
    <item>
      <title>Basic of client-go</title>
      <link>https://airren.github.io/blog/k8s_source_code_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_3/</guid>
      <description>The repositories The Ku
The Client Library&amp;ndash; k8s.io/client-go k8s.io/client-go is a typical web service client library that supports all API types that are officially part of Kubernetes. It can be used to execute the usual REST verbs.
Create Get List Update Delete Patch Watch For each Kubernetes 1.x.y release, there is a client-go release with a matching tag kubernetes-1.x.y.
Most of your code that speaks to Kubernetes APIs will use tools/clientcmd/ to set up a client from a kubeconfig file, and kubernetes/ for the actual Kubernetes API clients.</description>
    </item>
    
    <item>
      <title>C Build Tool</title>
      <link>https://airren.github.io/note_c/C&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_c/C&#43;&#43;/</guid>
      <description>1# g++ Linux 2g++ -std=c++17 -W -Wall -Wfatal-errors &amp;lt;file_name&amp;gt; 3# Clang MacOS 4clang++ -std=c++17 -W -Wall -Wfatal-errors &amp;lt;file_name&amp;gt; Makefile AutoMake 1sudo apt install autoconf autopoint pkg-config libffi-dev libtool libtasn1-6-dev gettext libtasn1-bin cmake 为了跨平台实现。
创建 CMakeLists.txt, 使用cmake ,生成 Makefile, 然后再使用make 或者 cmake --build . -j
https://www.cnblogs.com/52php/p/5681725.html
https://stackoverflow.com/questions/1516609/difference-between-cc-gcc-and-g
Meson https://mesonbuild.com/</description>
    </item>
    
    <item>
      <title>Cloud Native</title>
      <link>https://airren.github.io/blog/CloudNative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/CloudNative/</guid>
      <description>4C8G 70%-80% 虚拟化浪费掉了
裸金属
2001 VMware虚拟化技术
2006 AWS推出EC2服务
2010 Openstack社区成立。 虚拟化技术，管理操作系统
2011.04 第一个 开源PaaS平台 CloudFoundry
2013.03 开源Docker发布。 操作系统之上的应用容器化。
2014.06 Google 发布Kubernetes, 应用编排
2015.07 Google 宣布成立CNCF基金会
Building sustainable ecosystems for cloud native software.
IaaS Infrastructure-as-a-service 基础设施即服务
PaaS Platform as a service
SaaS Software as a service
CaaS container as a service
优势 ：
稳定性： 几个9 SLA 0.999 年宕机时间
弹性扩展
安全性
成本
易用性
IDC
单体架构
集群架构阶段（单集群，同时只有一个实例提供服务）
分布式架构阶段（负载均衡，同时提供服务）
微服务架构， 以业务天然分库
ServiceMesh： 网格化架构
RPC 远程调用/ Gateway 负载均衡-&amp;gt; 服务与IP映射 facade pattern ： 真正想做一件事，对外暴露统一访问接口：负载均衡、协议抓换、用户鉴权</description>
    </item>
    
    <item>
      <title>Cloud-Native HSM based on Intel Software Guard(SGX)</title>
      <link>https://airren.github.io/sdewan/SGX-HSM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/SGX-HSM/</guid>
      <description>Patent Cloud-Native HSM is a cloud-native Hardware Security Module(HSM) service that allows you to host encryption keys in the Intel Software Guard extension enclave and perform cryptographic operations accelerated by QAT in a cluster of HSM. You can manage the HSM resource with the Kubernetes customer resources, so you do not need to worry about scaling, managing, and clustering. You can leverage the Kubernetes&amp;rsquo; function to provide the HSM to your service.</description>
    </item>
    
    <item>
      <title>clusternet</title>
      <link>https://airren.github.io/sdewan/clusternet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/clusternet/</guid>
      <description>Cluster Net Test Environment Access method 1# this machine is out of intel, please use the socks proxy: 2# proxy-prc.intel.com:1080 3# use this private key to access this the relay machine: 4# first login to 5ssh -p 3302 airren@124.223.99.93 # passwd: 123- 6# next login to 7ssh airren@node-1 # passwd:123- PreRequisites Kind Create cluster
1# create cluster one node 2 3 4# create cluster multinode 5 6# create cluster with configuration Delete cluster</description>
    </item>
    
    <item>
      <title>CNI Container Networking Interface</title>
      <link>https://airren.github.io/nodus/k8s-network-cni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/k8s-network-cni/</guid>
      <description>Docker CNM What is CNI?
How CNI plugin works?
What a CNI plugin is made of?
How a CNI plugin is being used in K8s?
How a CNI plugin is executed?
Anatomy of Pod networking
What is CNI CNI stands for Container Networking Interface
An interface between container runtime and the network implementation
Configure the network interfaces and routes
Concern itself only with the netwrok connectivity.
How CNI plugin works? A CNI binary Handle connectivity - configures the network interface of the Pod /opt/cni/bin A daemon Handle reachability - manager routings across the cluster What a CNI plugin is made of ?</description>
    </item>
    
    <item>
      <title>cross complile</title>
      <link>https://airren.github.io/blog/openwrt_cross_compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/openwrt_cross_compile/</guid>
      <description>openWRT Cross compile 1export STAGING_DIR=/home/airren/openwrt/staging_dir/toolchain-x86_64_gcc-8.4.0_musl 2 3 4export TOOLCHAIN_DIR=$STAGING_DIR 5export TOOLCHAIN_PATH=$TOOLCHAIN_DIR/bin 6export CXX=$TOOLCHAIN_PATH/g++-uc 7export AR=$TOOLCHAIN_PATH/x86_64-openwrt-linux-musl-ar 8export CXXFLAGS=&amp;#34;-O2&amp;#34; 9 10 11export CROSSCOMPILE_PATH=$TOOLCHAIN_DIR/usr 12# export CFLAGS=&amp;#34;-I$CROSSCOMPILE_PATH/jhhhhinclude&amp;#34; 13 14 15export LDCFLAGS=&amp;#34;-L$TOOLCHAIN_DIR/usr/lib -lz&amp;#34; 16export LD_LIBRARY_PATH=$TOOLCHAIN_DIR/usr/lib 17export PATH=$TOOLCHAIN_PATH:$PATH 1./autogen.sh --build=x86_64-pc-linux-gnu --host=i486-openwrt-linux 2./autogen.sh --build=x86_64-pc-linux-gnu --host=x86_64-openwrt-linux 3 4make CC=i486-openwrt-linux-gcc LD=i486-openwrt-linux-ld 5make CC=x86_64-openwrt-linux-gcc LD=x86_64-openwrt-linux-ld build openwrt in a docker
1apt update 2apt install -y git wget build-essential gawk gcc-multilib flex git gettext libncurses5-dev libssl-dev python3-distutils rsync unzip zlib1g-dev 3 4apt update 5apt install build-essential ccache ecj fastjar file g++ gawk \ 6gettext git java-propose-classpath libelf-dev libncurses5-dev \ 7libncursesw5-dev libssl-dev python python2.</description>
    </item>
    
    <item>
      <title>Deploy essential components by Docker</title>
      <link>https://airren.github.io/component/deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/deployment/</guid>
      <description>K8sStudy:
Docker Node: Jenkins, Mysql, casbin_allinone, portioner,hemidall (1 node 4 core, 8G)
ODMS with NFS. (3 node, 1 NFS node)
K8s node for CNI study
K8s node for others, DPDK?
Dev node for source code and dev
move Openwrt and VM to a same node
Application Casdoor 1docker run -d --restart=always --name casdoor \ 2-p 8001:8000 \ 3casbin/casdoor-all-in-one Heimdall 1docker volume create heimdall 2docker run -d --restart unless-stopped --name=heimdall \ 3-e PUID=1000 -e PGID=1000 -e TZ=Europe/London \ 4-p 8086:80 -p 8463:443 \ 5-v heimdall:/config \ 6linuxserver/heimdall:latest CI&amp;amp;CD Jenkins 1docker volume create jenkins_data 2docker run -d --restart=always --name jenkins \ 3-u 0 --privileged \ 4-p 8080:8080 -p 50000:50000 \ 5-v jenkins_data:/var/jenkins_home \ 6-v /var/run/docker.</description>
    </item>
    
    <item>
      <title>Device Plugin</title>
      <link>https://airren.github.io/blog/k8s_device_plugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_device_plugin/</guid>
      <description>GitHub: Intel Device plugins for Kubernetes
Device Plugins Device Plugins
Use the Kubernetes device plugin framework to implement plugins for GPUs, NICs, FPGAs, InfiniBand, and similar resources that require vendor-specific setup.
Instead of customizing the code for Kubernetes itself, vendors can implements a device plugin that you deploy either manually or as a DaemonSet. The targeted device include GPUs, high-performance NICs, FPGAs, InfiniBand adapters, and other similar computing resources that may require vendor specific initialization and setup.</description>
    </item>
    
    <item>
      <title>Docker Images</title>
      <link>https://airren.github.io/CloudNative/Docker/docker_build_image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Docker/docker_build_image/</guid>
      <description>镜像仓库 Linux 本地镜像仓库：/var/lib/docker/image
镜像应该是分层存储的。
Docker images 是存储在镜像仓库服务Images Registry。Docker 客户端的镜像仓库服务是可配置的，默认使用的是Docker Hub。
镜像仓库服务包含多个镜像仓库 Image Repository（同一个镜像的不同版本）。一个镜像仓库中包含多个镜像Image。
Docker Hub 也分为Official Repository 和 Unofficial Repository。
1docker pull &amp;lt;repository&amp;gt;:&amp;lt;tag&amp;gt; 2// 如果省略tag默认会pull tag 为 latest的image。但是latest并不保证这是仓库中最新的镜像。 如果希望从第三方镜像服务仓库获取镜像(not Docker Hub)，则需要在镜像仓库名称前加上第三方镜像仓库服务的DNS名称。
1# gcr.io -&amp;gt; Google Container Images Registry. 2docker pull gcr.io/k8s-staging-nfd/node-feature-discovery:master Image Tag 不同的Images Tag可以绑定同一个Image ID
通过--filter 来过滤docker image ls 返回的内容
1docker image ls --filter dangling=true dangling image -&amp;gt; with out name &amp;amp; tag :.
通常因为构建新的镜像，为该镜像打了一个已经存在的标签。Docker会remove old image上的标签，将该标签标在新Image上。Old Image 就会变成 dangling image。</description>
    </item>
    
    <item>
      <title>Docker networking</title>
      <link>https://airren.github.io/CloudNative/Docker/docker_networking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Docker/docker_networking/</guid>
      <description>Docker networking is based on an open-source pluggable architecture called the Container Network Model(CNM). libnetwork is Docker&amp;rsquo;s real-work implementation of the CNM, adn it provides all of the Docker&amp;rsquo;s core networking capabilities. Drivers plug into libnework to provide specifice network topologies.
The theory At the highest level, Docker networking comprise three major components.
Single-host bridge network </description>
    </item>
    
    <item>
      <title>Dockerfile</title>
      <link>https://airren.github.io/blog/docker_dockerfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/docker_dockerfile/</guid>
      <description>Dockerfile 中的entrypoint 和CMD的区别
1CMD executable param1 param2 # 不用使用这种shell表示法，1 号进程为shell 2CMD [&amp;#34;executable&amp;#34;,&amp;#34;param1&amp;#34;,&amp;#34;param2&amp;#34;] EntryPoint 和CMD都可以在执行的时候被覆盖。
组合使用ENTRYPOINT和CMD, ENTRYPOINT指定默认的运行命令, CMD指定默认的运行参数. 例子如下:
1FROM ubuntu:trusty 2ENTRYPOINT [&amp;#34;/bin/ping&amp;#34;,&amp;#34;-c&amp;#34;,&amp;#34;3&amp;#34;] 3CMD [&amp;#34;localhost&amp;#34;] docker 会把CMD的命令拼接到Entrypoint之后</description>
    </item>
    
    <item>
      <title>Extend Disk Space without shutdown</title>
      <link>https://airren.github.io/blog/linux-ubuntu-lvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux-ubuntu-lvm/</guid>
      <description>We have a sever for code test, but with the test case growth, the Disk space is not enough for use.
Fortunately, we use ubuntu LVM to manage the Disk.
1fdisk /dev/sdb 1pvdisplay https://gyazo.com/40b3c078d6bb755f9cca318b3c28b2cf
1vgextend ubuntu-vg /dev/sdc1 1vgdisplay 1lvdisplay 1lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv 2resize2fs /dev/ubuntu-vg/ubuntu-lv Multipass extend VM disk size.
Multipass uses qemu to create the VM instance. So you can modify the qemu image manually to change the VM disk size.</description>
    </item>
    
    <item>
      <title>free命令</title>
      <link>https://airren.github.io/CloudNative/Linux/free/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/free/</guid>
      <description>type desc total physical mem used used = total- free-buffers-cache free Free/Unused memory shared It is here only for backward comopatibility buff/cache The combined memory used by the kernel buffers and page cache ans slabs. This memory can be reclaimed at any time if needed by the applicaitons. If you want buffers and cache to displayed in two separate columns, use -w options. available An estimate of the amount of memory that is availablew for starting new applications, without swaping.</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://airren.github.io/CloudNative/Linux/git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/git/</guid>
      <description>1# git cache user and passwd 2git config --global credential.helper cache </description>
    </item>
    
    <item>
      <title>Go Assembly</title>
      <link>https://airren.github.io/note_go/0_go_assambely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/0_go_assambely/</guid>
      <description>Golang的汇编是基于Plan9的的汇编，是一个中间汇编的方式，这样可以忽略底层CPU架构的差别。
汇编主要了解各种寄存器的使用以及寻址方式。根据Golang的汇编我们可以深入理解Golang的底层实现。比如内存如何分配，栈如何扩张，接口如何转变。
如何从go语言获取对应的汇编
1go build -gcflags &amp;#34;-N -l&amp;#34; -ldflags=-compressdwarf=false =o main.out main.g 2go tool objdump -s &amp;#34;main.main&amp;#34; main.out &amp;gt; main.S 3# or 4go tool compile -S main.go 5# or 6go build -gcflags -S main.go 汇编基础语法 通用寄存器 寄存器与物理机架构有关，不同的架构有不同的物理寄存器。
在amd64架构上提供了16个通用寄存器给用户使用。
Plan9汇编语言提供了如下映射，这样就可以在汇编语言中这几应用就可以使用物理寄存器了。
x64架构中所有的寄存器都是64位
amd64 Plan9 rax AX rbx BX rcx CX rdx DX rdi DI rsi SI rbp BP rsp SP r8 R8 r9 R9 r10 R10 r11 R11 r12 R12 r13 R13 r14 R14 rip PC 虚拟寄存器 伪寄存器不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针。</description>
    </item>
    
    <item>
      <title>Go compile</title>
      <link>https://airren.github.io/note_go/0_go_compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/0_go_compile/</guid>
      <description>n
https://zhuanlan.zhihu.com/p/343562661
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</description>
    </item>
    
    <item>
      <title>Go 设置Golang开发环境</title>
      <link>https://airren.github.io/note_go/1_SettingUpGoEnv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_SettingUpGoEnv/</guid>
      <description>安装Go 开始写Golang之前，你首先需要下载并且安装Golang开发工具。可以在Golang的官方网站下载最新的安装包。根据你的开发平台选择下载对应的版本。对于Mac用户(或者Windows用户)来说.pkg(或msi)安装包会自动把Golang安装到合适的位置，并将命令加入到环境变量，并且自动移除老版本。如果使用Mac更加推荐直接使用brew install go， 使用brew 可以方便的管理Go多个版本。
对于Linux或者FreeBSD用户可以直接下载对应的.tar.gz, 并解压到文件名为go的目录中。把这个文件Copy到/usr/local/下。然后把/usr/local/go/bin添加到$PATH中。
1tar -C /usr/local -xzvf go1.17.3.linux-amd64.tar.gz 2# change .profile to .bashrc or.zsh depend on you evnironment 3echo &amp;#34;export PATH=$PATH:/usr/local/go/bin&amp;#34; &amp;gt;&amp;gt;$HOME/.profile Go 程序编译完成后是一个独立的二进制文件，不需要依赖任何运行软件(例如，Python需要Python解释器，Java需要JVM)。仅在需要编译Go代码的环境上安装Go即可。
安装完成后，打开Terminal(Window 打开CMD)，验证Go是否安装成功。
1go version 在所有的配置都正确的情况下，可以看到输出的版本信息
1# mac intel cpu 64bit 2go version go1.17.3 darwin/amd64 从上述信息中可以看出，Go的版本是1.17.3,使用的开发机器是 Mac(Darwin 是MacOS的Kernel Name, amd64 是指64-bit的x86 CPU架构)。
如果你没有得到正确的版本信息，很有可能是你没有把go加入到环境变量，或者有其他的程序名称也为go。对于Mac或者Unix-like用户，可以使用which go查看当前环境下的go的是否正确关联到/usr/local/go/bin。如果路径正确，也有可能是下载错了安装包，检查下安装包的位数是否与当前操作系统匹配，有可能在64-bit的系统上下载了32-bit的安装包。另外，也有可能是芯片架构选错了。
Go 工作空间 从2009年Go开始使用，在开发者如果组织代码和管理依赖上经历了几次变化。在Go 1.11所有的代码必须保存在GOPATH之下，之后的版本用户可以在任意目录下存储自己的代码。但是Go依然希望有一个独立的工作空间可以存储通过go install安装额第三方包。默认的工作空间是$HOME/go, 下载的第三方包默认存储在$HOME/go/src,编译的二进制文件存储在$HOME/go/bin。你可以直接使用这个默认的工作空间，或者通过设置$GOPAHT指定一个工作空间。
无论你是否使用默认的wokespace，建议你把$GOPATH/bin加入到$PATH中。 通过指定$GOPATH可以清楚地描述当前环境的Go工作空间，把$GOPATH/bin加入到可执行路径中可以直接使用go install 安装的第三方包。
如果是Unix-like的开发环境可以把下面几行加入到$HOME/.profile中。
1# if use ubuntu you should add to .</description>
    </item>
    
    <item>
      <title>How to Create a go project for Cloud Native</title>
      <link>https://airren.github.io/blog/project_go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/project_go/</guid>
      <description>Dockerfile Use Makefile to compiling and buid docker images </description>
    </item>
    
    <item>
      <title>Intel AMXAV</title>
      <link>https://airren.github.io/blog/intel_spx_AMX/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/intel_spx_AMX/</guid>
      <description>Introduce SIMD 单指令数据-&amp;gt; VNNI/INT8
Intrinsics for Intel(R) Advanced Matrix Extension Instructions Intel Advanced Matrix Extension is a new 64-bit programming paradigm consisting of two components:
A set of 2-dimensional registers(tiles) representing sub-arrays from a larger 2-dimensional memory image Am accelerator that is able to operate on tiles; the first implementation of this accelerator is called TMUL(tile matrix multiply unit) Intrinsic for Intel Advanced Matrix Extension AMX-BF16 Instructions This intrinsic supports tile computational operations on bfloat16 number.</description>
    </item>
    
    <item>
      <title>IntelliJ设置</title>
      <link>https://airren.github.io/tools/software/IntelliJ%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/tools/software/IntelliJ%E8%AE%BE%E7%BD%AE/</guid>
      <description>IntelliJ设置 1. 创建文件时候自动添加作者和创建时间 Preference-&amp;gt; Editor-&amp;gt;File and Code Templates-&amp;gt;Include -&amp;gt;File Header
1/** 2 * @author Airren 3 * @date ${DATE} ${TIME} 4 * @version 1.0 5 */ </description>
    </item>
    
    <item>
      <title>IPSec</title>
      <link>https://airren.github.io/blog/network_ipsec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_ipsec/</guid>
      <description>IPsec is a group of networking protocols used for setting up secure encrypted connections, such VPNs, across publicly shared networks.
What is IPsec IPsec is a group of protocols that are used together to set up encrypted connections between devices. It helps keep data send over public networks secure. IPsec is often used to set up VPNs, and it works by encrypting IP packets, along with authenticating the source where the packets come from.</description>
    </item>
    
    <item>
      <title>iptables</title>
      <link>https://airren.github.io/blog/network_iptables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_iptables/</guid>
      <description>防火墙 逻辑上，防火墙可以分为主机防火墙和网络防火墙。主机防火墙针对单个主机进行防护；网络防火墙往往处于网络入口或者边缘，针对网络入口进行防护，服务于防火墙背后的本地局域网。
物理上，防火墙可以分为硬件防火墙和软件防火墙。硬件防火墙在硬件级别实现部分防火墙功能，另一部分基于软件实现，性能高，成本高；软件防火墙应用软件处理逻辑运行于通用计算平台之上的防火墙，性能低，成本低。
iptables/netfilter iptables其实不是真正的防火墙，可以把它理解陈伟一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的“安全框架”中，这个“安全框架”才是真正的防火墙， 这个框架的名字叫netfilter。
netfilter才是防火墙真正的安全框架，位于内核空间。iptables其实是一个命令行工具， 位于用户空间，我们使用iptables这个工具操作真正的框架netfilter。
netfilter/iptables组成的linux平台下的包过滤防火墙，是免费的，具有以下功能：
网络地址转换(NAT, Network Address Translate) 数据包内容修改 数据包过滤(防火墙功能) 我们虽然可以使用service iptables start启用iptables服务，但其实准确的来说iptables并没有一个守护进程，不能算是真正意义上的服务，而算是内核提供的功能。
iptables是按照规则(rules)来办事的, rules 就是我们预定义的条件。规则一般定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中。这些规则分别指定了源地址、目的地址、传输协议(如TCP、UDP、ICMP)和服务类型(如HTTP、FTP和SMTP)等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包， 如放行(accept)、拒绝(reject)和丢弃(drop)等。配置防火墙主要工作就是添加、修改和删除这些规则。
ewctl
hubDevice Objcet true 默认hub</description>
    </item>
    
    <item>
      <title>Istio MultiCluster</title>
      <link>https://airren.github.io/blog/4_istio_multicluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/4_istio_multicluster/</guid>
      <description>Multicluster Replicated Control Plane is an uses case to enable communication between two service in difference service mesh without using Ingress and can enable mutual TLS between the service.
Istio 1.8 Upgrade Notes
Multicluster .global Stub Domain Deprecation As part of this release, Istio has switched to a new configuration for multi-primary (formerly “replicated control planes”). The new configuration is simpler, has fewer limitations, and has been thoroughly tested in a variety of environments.</description>
    </item>
    
    <item>
      <title>K8s Cloud Native</title>
      <link>https://airren.github.io/CloudNative/Kubernates/1-k8s-cloudnative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/1-k8s-cloudnative/</guid>
      <description>Kubenetes生产落地全程实践
核心概念
架构设计
认证授权
高可用集群搭建
二进制&amp;amp; kubeadm
3台master两台2 node
calico、coredns、dashboard
业务迁移到Kubenetes
Harbor
服务发现策略
IngressNginx
Docker 化服务、K8s、服务发现
CICD
namespace、resources、label
服务的调度与编排
健康检查
调度策略
部署策略
日志与监控
第2章 kubernetes快速入门 本章中将从核心概念、架构设计、认证授权以及集群搭建方案对比几方面，带领大家快速掌握kubernetes的重要知识点，助力快速入门。
2-1 了解kubernetes 舵手： 渔网、渔船 docker : 鲸鱼，集装箱 🐳
Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.
It groups containers that makeup application in to logical units for easy management and discovery.Kubernetes builds upon 15 years of experience of running production workloads at Google, combined with best-of-breed ideas and practices from the community.</description>
    </item>
    
    <item>
      <title>K8s ConfigMap</title>
      <link>https://airren.github.io/CloudNative/Kubernates/9-k8s-configmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/9-k8s-configmap/</guid>
      <description>给Pod传递参数 通过环境变量给Pod传递参数 可以在container的描述文件中加入一个env的参数，值是一个数组，每个元素都是键值对，值是string。
1--- 2apiVersion: v1 3kind: Pod 4metadata: 5 name: first-pod 6 labels: 7 app: nginx 8spec: 9 containers: 10 - name: 00-simple-pod-nginx 11 image: nginx:1.17.0 12 env: 13 - name: INTERVAL 14 value: 30s 通过命令行参数给Pod传递参数 加入一个args配置，命令行参数是一个字符串数组</description>
    </item>
    
    <item>
      <title>K8s DaemonSet</title>
      <link>https://airren.github.io/CloudNative/Kubernates/7-k8s-daemonset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/7-k8s-daemonset/</guid>
      <description>NodeExporter 用于采集一个Host上的各种性能指标，并且暴露给Prometheus 采集。因为NodeExporter需要采集每一个Host的数据状态，所以就产生了一个需求，在每一个K8s的机器上都要运行一个Pod, 而实现这个需求的K8s资源类型就叫做DaemonSet。
DaemonSet DaemonSet的功能就是保证每个Node都运行Pod， 但是如果某个K8s的Node下线之后，对应的Pod也下线，还是保持每个Node一个Pod。如果新增一个Node，就会在新增的Node中增加一个Pod，保证所有的Node中有且只有一个当前Pod。
1--- 2apiVersion: apps/v1 3kind: DaemonSet 4metadata: 5 name: node-exporter 6 namespace: kube-system 7 labels: 8 k8s-app: node-exporter 9 kubernetes.io/cluster-service: &amp;#34;true&amp;#34; 10 addonmanager.kubernetes.io/mode: Reconcile 11 version: v1.2.2 12spec: 13 selector: 14 matchLabels: 15 k8s-app: node-exporter 16 version: v1.2.2 17 updateStrategy: 18 type: OnDelete 19 template: 20 metadata: 21 labels: 22 k8s-app: node-exporter 23 version: v1.2.2 24 spec: 25 priorityClassName: system-node-critical 26 containers: 27 - name: prometheus-node-exporter 28 image: &amp;#34;prom/node-exporter:v1.</description>
    </item>
    
    <item>
      <title>K8s Deployments</title>
      <link>https://airren.github.io/CloudNative/Kubernates/5-k8s-deployment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/5-k8s-deployment/</guid>
      <description>蓝绿部署 蓝绿部署是一种比较常见的部署方式，经常会用于新旧版本不兼容的情况。
先将新版本(绿版)的服务运行起来。 将所有的流量切到新版本的服务上 删除旧版本(蓝版)的服务 创建新版本的ReplicaSet，将Service指向新的Pods，删除旧版本的ReplicaSet
滚动升级 蓝绿部署可以有效保证业务的正确性，但是也带来了一定的风险，例如稳定性。
假设新部署的应用是有问题的，一旦切换之后就会导致业务的崩溃，造成损失。于是就有了稍微友好的升级方式，滚动升级。
先关闭一个旧版本的实例 开启一个新版本的实例用于替换旧版本 替换成功时候循环1和2，直到所有的实例升级完成。 在整个过程中，如果中途发现异常可以及时停手，及时止损。而且Kubernetes也在客户端中支持了这个特性。kubectl rolling-update。
升级前后RC的Selector都被改变了 操作都是在客户端执行的？ 金丝雀发布 金丝雀发布是滚动发布的一种特例，在滚动发布中，是不会等待的，除非中间出错了。但是有些时候，我们并不想要全都升级，可能只是处于POC的一些原因，我们只希望部分实例是新的，大部分是旧的，而这种情形，我们就称之为金丝雀发布。
升级少部分实例 查看效果，如果好，全部升级 如果不好，则不升级 声明式升级 前面介绍的这些升级发布方式在K8s上很多时候是半手工方式执行的，而Kubernetes作为一款DevOPS友好的系统，已经内置了对于部署方式的一种资源抽象，这个资源就是：Deployment。
Deployment &amp;ndash;&amp;gt; ReplicaSet &amp;ndash;&amp;gt; Pods
Deployment 存在的意义为：在升级应用程序时，需要引入额外的ReplicaSet，并协调新旧两个RS，使他们再根据彼此不断修改，而不会造成干扰。Deployment将这些运维过程都代码化，内置为自己的逻辑，从而让升级变得简单。
首先我们使用Deployment创建3个实例
1# deploy.yaml 2--- 3apiVersion: apps/v1 4kind: Deployment 5metadata: 6 name: first-deployment 7 labels: 8 app: simple-pod-deployment 9spec: 10 replicas: 3 11 selector: 12 matchLabels: 13 app: simple-pod-deployment 14 template: 15 metadata: 16 name: simple-pod-deployment 17 labels: 18 app: simple-pod-deployment 19 spec: 20 containers: 21 - name: simple-pod-de 22 image: lukelau/rest-docker:0.</description>
    </item>
    
    <item>
      <title>K8s Groups and Versions and Kinds</title>
      <link>https://airren.github.io/blog/k8s_1_GVK/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_1_GVK/</guid>
      <description>Groups and Versions An API Group in Kubernetes is simply a collection of related functionality. Each group has one or more versions,
Kinds and Resources Each API group-version contains one or more API types, which we call Kinds.
A resource is simply a use of Kind in the API. Often, there&amp;rsquo;s a one-to-one maping between Kinds and resources. For intance, the pods resource crooesponds to the Pod Kind. However, sometimes, the same Kind may be returned by multiple resources.</description>
    </item>
    
    <item>
      <title>K8s Job</title>
      <link>https://airren.github.io/CloudNative/Kubernates/6-k8s-job/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/6-k8s-job/</guid>
      <description>Replicas 和deployment这两类资源都是用于控制workload的。这两种类型的资源一般都是持续运行的，同时还有一些辅助方式帮助workload出现异常时恢复，以及根据情况进行动态伸缩的特性。
Job 根据Job的定义创建出对应的Pod，然后关注Pod的状态， 直到满足定义。例如Pod执行成功了或者执行失败了，并且达到了重试次数。
1--- 2apiVersion: batch/v1 3kind: Job 4metadata: 5 name: pi 6spec: 7 template: 8 spec: 9 containers: 10 - name: pi 11 image: perl 12 command: [&amp;#34;perl&amp;#34;, &amp;#34;-Mbignum=bpi&amp;#34;,&amp;#34;-wle&amp;#34;, &amp;#34;print bpi(2000)&amp;#34;] 13 restartPolicy: Never 14 backoffLimit: 4 Job正常执行结束后结果如上图。这是一个只执行一次的Job。它的操作方式就是创建一个Pod，然后运行一遍，然后就退出。如果想执行多次，则只需要增加一个参数
1completions: 2 执行2次时创建了两个Pod，然后保证这两个Pod都执行成功。
我们在使用Deployment等Workload的时候，一般会指定restartPolicy，默认都是RestartOnFail。在Job中不能这么指定，因为这个逻辑应该由Job来控制， 而不是让Pod来控制。
CronJob 定时任务， CronJob就是在Job的基础上加上了周期定义的API
1--- 2apiVersion: batch/v1 3kind: CronJob 4metadata: 5 name: batch-job-pi 6spec: 7 schedule: &amp;#34;0,15,30,45 * * * *&amp;#34; 8 jobTemplate: 9 spec: 10 template: 11 metadata: 12 labels: 13 app: pi-job 14 spec: 15 containers: 16 - name: pi 17 image: perl 18 command: [&amp;#34;perl&amp;#34;, &amp;#34;-Mbignum=bpi&amp;#34;,&amp;#34;-wle&amp;#34;, &amp;#34;print bpi(2000)&amp;#34;] 19 restartPolicy: Never </description>
    </item>
    
    <item>
      <title>K8s network</title>
      <link>https://airren.github.io/blog/k8s_network/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_network/</guid>
      <description>容器网络 每一个容器都可以有一个自己独立的网络栈，这个独立的网络栈是基于Linux的Network Namespace实现的。
这个独立的网络栈包含了： Network Interface、Loopback Device、Routing Table和IPtables规则。对于一个进程来说，这些要素就构成了它发起和响应网络请求的基本环境。
容器可以使用自己独立的网络栈(创建属于自己的Network Namespace)，也可以直接使用Host的网络栈(不创建Network Namespace)。
1# Uset -net=host to share the host network 2docker run -d -net=host --name nginx-host nginx 直接使用Host的网络栈可以提供良好的网络性能，但是不可避免的会引入网络资源共享的问题，比如端口冲突。大多数应用场景下，我们希望容器能够有自己独立的IP地址和端口，即有自己独立的Namespace。
这个时候，就会出现一个问题，在这个被隔离的容器进程中如何与其他的Network Namespace里的容器进程进行交互呢。
一般我们如果希望两台主机之间的通信，直接用网线把这两台主机连接起来即可；而如果是多台主机之间通信我们可以将其连接在同一台交换机上。
在Linux系统中，能够起到虚拟交换机作用的虚拟网络设备是Bridge，是二层网络设备。主要功能是根据MAC地址来将数据包转发到网桥的不同Port上。
为了实现上述目的，docker项目会在Host上创建一个docker0的网桥，凡是连接在docker0网桥上的容器，就相当于在同一个二层网络。
接下来就是如何把容器连接到docker0网桥上，这就需要veth pair的虚拟设备了。veth pair创建出来以后总是以两张虚拟网卡veth peer的形式成对出现的。并且从其中一个peer发出的数据包可以直接出现在与之对应的另一个peer上，即使veth pair的两端不在同一个Network Namespace 中。因此，veth pair常常用作连接不同Network Namespace的网线。</description>
    </item>
    
    <item>
      <title>K8s Overview</title>
      <link>https://airren.github.io/CloudNative/Kubernates/1-k8s-overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/1-k8s-overview/</guid>
      <description>Node 节点主要负责容器的管理，用于运行容器和保证容器的状态。默认情况下Master节点不承担Node节点的功能，但是可以通过特殊的配置让Master节点也可作为Node节点。
Etcd用于存储Kubernetes的元数据，但是不要求一定要以容器的形式运行。
1kubeadm init --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.0.22 --pod-network-cidr pod 的ippool, --apiserver-advertise-address 为暴露的k8sAPI调用IP.
节点(Node)
一个Node是一个运行K8s的主机，作为K8s worker, 通常称之为Minion。每个节点都运行如下K8s关键组件：
kubelet：主节点代理 kube-proxy: service使用其将链接路由到Pod docker/rocket: k8s 使用容器技术创建容器 容器组(Pod)
一个Pod对应若干容器组成的一个容器组，同一个Pod内的容器共享一个存储卷(volume)，同一个Pod中的容器共享一个网络Namespace,可以使用localhost互相通信。
Pod是短暂的，不是持续性实体。一个Pod是一个特定的应用打包集合，包含一个或者多个容器。和运行的容器类似，一个Pod只有很短的运行周期。Pod被调度到一个Node运行，直到容器的生命周期结束或者其被删除。
容器组生命周期(Pod Status)
包含所有容器状态集合，包括容器组状态类型，容器组生命周期，事件，重启策略，以及replication controllers.
标签(labels)
标签是用来连接一组对象的，比如容器组Pod。lable可以用来组织和选择子对象。 一个Label是attach到Pod的一对键值对，用来传递用户定义的属性。
Replication Controllers
主要负责指定数量的Pod在同一时间一起运行。Replication controller 确保任意时间都有指定数量的Pod副本在运行。如果为某个Pod创建了Replication Controller并且指定为3副本，它会创建3个Pod,并持续监控他们。如果某个Pod不响应，那么Replication controller 会替换它，保持Pod总数为3.
当创建Replication Controller时，需要指定两个东西。
Pod模板： 用来创建Pod副本的模板 Label：Replication Controller 需要监控的Pod的Label 现在已经创建了Pod的一些副本，那么在这些副本上如何负载均衡呢，我们需要的是service
Service：
如果Pod是短暂的，那么重启时IP地址可能会变，怎么才能从前端容器正确可靠的指向后台容器呢。
Service是定义一系列Pod以及访问这些Pod的策略的一层抽象。Service通过Label找到Pod组。因为service是抽象的，所在在图表里通常看不到他们的存在。
现在假定有两个后台Pod,并且定义后台service名称为“backend-service”，label选择器为(tier=backend,app=myapp)。backend-service的Service会完成如下两件重要的事情：
会为Service创建一个本地集群的DNS入口，因此前端只需要DNS查找主机名为“backend-service”就能够解析出前端应用程序可用的IP地址 现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod中的哪一个呢。Service在这两个后台Pod之间提供透明的负载均衡，会将请求发给其中的任意一个。通过每个Node上运行的代理 kube-proxy完成。 Kubernetes Master
集群拥有一个K8s Master,K8s Master 提供集群的独特视角，并拥有一系列组件，如Kubernetes API server. API server 提供可以用来和集群交互的REST 端点。Master 节点包含用来创建和复制Pod的Replication Controller.
参考资料：</description>
    </item>
    
    <item>
      <title>K8s StafulSet</title>
      <link>https://airren.github.io/CloudNative/Kubernates/8-k8s-stafulset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/8-k8s-stafulset/</guid>
      <description>前面介绍的几种workload都有一个共性，那就是创建出来的Pod都是一致的。所谓的一致就是说，假设我们使用的是ReplicaSet，创建了3个Pod，那么这3个Pod创了名字一定不一样之外，其他属性可能都是一样的，包括运行时的参数和模式以及数据存储。
如果是Web Service，数据保存到后端的DB中，上述逻辑是没有问题的。
如果使用ReplicaSet来部署一个DB的多实例， 就可肯能存在问题了。
数据持久化，一般使用PVC，当使用PVC 和PV的时候
​
ReplicaSet -&amp;gt; Pods(3 个) -&amp;gt; 持久卷声明 -&amp;gt; 持久卷
3个Pod的数据都写到同一个Pv中，这样肯定是不行的？？？
StatefulSet 为了解决Pod的状态性的问题，K8s引入了StatefulSet的概念
Pod有单独的存储和固定的网络标识 需要配备一个headless Service，用于DNS 可以通过DNS快速发现其他的Pod 可以直接通过Pod DNS通信 每个Pod都可以通过DNS访问到，这种特性在其他workload中是不能实现的。通过StatefulSet可以让Pod持有状态，即使因为故障Pod重建了，那么对应的Pod的名字和数据都会保留，和重建之前没有什么区别。
使用StatefulSet 必须建立一个HeadlessService，然后绑定这个headlessservice到StatefulSet。
以MongoDB为例，创建一个StatefulSet，因为还没有介绍到PVC和PV的内容，所以MongoDB将使用本地存储卷。
创建Headless Service
创建 StatefulSet
通过DNS访问Pod
在StatefulSet的Pod中可以通过DNS直接访问其他Pod。
1mongo --host mongo-1.mongo 可以通过&amp;lt;pod-name&amp;gt;.&amp;lt;service-name&amp;gt;的形式访问Pod。这其实和StatefulSet的设计是有关系的，在类似的Deployment中Pod的名字是不固定的，而在StatefulSet中，Pod的名字是固定的。
和ReplicaSet对比
因为有状态的Pod彼此不同，通常希望操作的是其中的特定的一个，所以StatefulSet通常要求你创建一个用来记录每个Pod网络标记的HeadlessService。通过这个Service，每个Pod都拥有独立的DNS记录，而这在ReplicaSet中是不行的？（如果为ReplicaSet创建一个Headless Service会发生啥？） 因为StatefulSet缩容任何时候只会操作一个Pod实例，所以有状态应用的缩容不会很迅速。 StatefulSet在有实例不健康的情况下，是不允许缩容的。 持久存储 一个StatefulSet可以拥有一个或者多个卷声明模板，这些声明会在创建Pod前创建出来，绑定到一个Pod的实例上。 扩容StatefulSet会创建两个API对象，一个Pod和一个卷声明；但是缩容StatefulSet却会删除一个Pod对象，而会留下PVC，因为一旦删除PVC则意味着PV会被回收。 StatefulSet at-most-one
Kubernetes 必须保证两个拥有相同标记和绑定相同持久卷声明的有状态的Pod实例不会同时运行。一个StatefulSet必须保证有状态的实例的 at-most-one 语义。也就是说StatefulSet必须保证一个Pod不再运行后，才会去创建它的替换Pod。</description>
    </item>
    
    <item>
      <title>K8s 源码阅读 -- 环境搭建</title>
      <link>https://airren.github.io/blog/k8s_source_code_1_contribute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_1_contribute/</guid>
      <description>Branch Strategy Fork K8s 源码， 并从自己的仓库中clone到本地。设置Upstream， 跟踪K8s源码的更新
Kubernetes Project 使用标准的Github &amp;ldquo;Fork and Pull&amp;rdquo; workflow。在git中，个人Fork的仓库应该设置为&amp;quot;origin&amp;quot;, 而原始项目的仓库成为&amp;quot;upstream&amp;quot;。为了保证个人分支(origin)和上游(upstream)更新保持一致，需要在你的本地仓库中完成以下设置。
Adding Upstream 增加upstream 作为一个remote，并且配置为不可以push。
1git remote add upstream https://github.com/kubernetes/kubernetes.git 2git remote set-url --push upstream no_push 设置完成后可以通过git remote -v 检查remote的配置情况。
Keeping Your Fork in sync Fetch all the changes from upstream and &amp;ldquo;rebase&amp;rdquo; them on your local master branch. 这将保证你的本地仓库与上游项目保持同步。Push the local changes to your remote master.
1git fetch upstream 2git checkout master 3git rebase upstream/master 4git push You should do this minimally before creating a new branch to work on you feature or fix.</description>
    </item>
    
    <item>
      <title>K8s 源码阅读 4</title>
      <link>https://airren.github.io/blog/k8s_source_code_4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_4/</guid>
      <description>Short Names and Categories Like native resources, custom resources might have long resources names. CRs can have short names as well.
Again, kubectl learns about short names via discovery information.
1apiVersion: apiextensions.k8s.io/v1beta1 2kind: CustomResourcesDefinition 3metadata: 4	name: ats.cnat.programming-kubernetes.info 5spec: 6	... 7	shortNames: 8	- at Further, CRs&amp;ndash;as any other resources&amp;ndash;can be part of categories. The most common use is the all category, as in kubectl get all. Is lists all user-facing resources in a cluster, like pods and services.</description>
    </item>
    
    <item>
      <title>K8s 源码阅读 5 Automating Code Generation</title>
      <link>https://airren.github.io/blog/k8s_source_code_5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_5/</guid>
      <description>Calling the Generators Usually, the code generators are called in mostly the same way in every controller project.
Here, all means to call all four standard code generators for CRs.
deepcopy-gen
Generate func(t *T)DeepCopy() *T and func(t *T)DeepCopyInfo(*T) method.
client-gen
Creates typed client sets
informer-gen
Creates informers for CRs that offer an event-base interface to react to changes of CRs on the server.
lister-gen
Creates lister for CRs that offer a read-only caching layer for GET and LIST request.</description>
    </item>
    
    <item>
      <title>K8s 源码阅读 6 Solutions for Writing Operators</title>
      <link>https://airren.github.io/blog/k8s_source_code_6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_6/</guid>
      <description>Following sample-controller Bootstraping Business Logic We are now in the position to implement the business logic of the custom controller. That is, we implement the state transitions between the three phases&amp;ndash;form PhasePending to PhaseRuning to PhaseDone&amp;ndash;in controller.go.
processNextWorkItem() processNextWorkItem() bool will read a single work item off the workquque and attempt to process it, by calling the syncHandler.
1func (c *Controller) processNextWorkItem() bool{ 2 obj, shutdowon := c.workqueue.Get() 3 4 if shutdown{ 5 return false 6 } 7 8 // We wrap this block in a func so we can defer c.</description>
    </item>
    
    <item>
      <title>K8s 源码阅读7</title>
      <link>https://airren.github.io/blog/k8s_source_code_7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_7/</guid>
      <description>In this chapter we&amp;rsquo;ll discuss the operational aspects of controllers and operators, showing you how to package them, walking you through best practices for running controllers in production, and making sure that your extension points don&amp;rsquo;t break your Kubernetes cluster, security, or performance-wise.
Lifecycle Management and Packaging Let&amp;rsquo;s start with the low-hanging fruit: packaging and delivering your controllers so that a user can install it in a straightforward manner.
Packaging: The Challenge While Kubernetes defines resources with manifest, typically written in YAML, a low-level interface to declare the state of resources, these manifest files have shortcoming.</description>
    </item>
    
    <item>
      <title>Kube Config 控制多个集群</title>
      <link>https://airren.github.io/blog/5_kube_config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/5_kube_config/</guid>
      <description>https://www.cnblogs.com/zhaobowen/p/13963343.html
https://zhuanlan.zhihu.com/p/169746514
https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/
https://juejin.cn/post/6968129599070797837
1export KUBECONFIG git blame</description>
    </item>
    
    <item>
      <title>Kubenetes Pod</title>
      <link>https://airren.github.io/CloudNative/Kubernates/2-k8s-pod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/2-k8s-pod/</guid>
      <description>Pod
在Kubernetes中，一切都是资源，你可以通过create/get/describe/delete 来操作这些资源。
在操作一种资源之前，我们需要先对这个资源进行定义，在k8s中常用的是yaml配置文件配置。
1# 00-siample-pod.yaml 2--- 3apiVersion: v1 4kind: Pod 5metadata: 6 name: first-pod 7 labels: 8 app: nginx 9spec: 10 containers: 11 - name: 00-simple-pod-nginx 12 images: nginx:1.17.0 apiVersion：资源的版本，可以理解为你要创建的是 PodV1{}还是PodVn{}
kind: 资源的类型
metadata：
​	name： 创建出来的资源的名字
​ labels：与其他资源粒度或者操作的关联
spec: 资源的参数
通过kubectl apply -f创建资源
1kubectl apply -f 00-simple-pod.yaml 如果需要更新资源，修改yaml后，重新kubectl apply -f xxx.yaml 就可以。
获取Pod状态
1kubectl get pod first-pod 2# get more detail 3kubectl get pod first-pod -o wide 4# get all pods of all-namespace 5kubectl get po -A 获取Pod 详情</description>
    </item>
    
    <item>
      <title>Kubernetes API Basic</title>
      <link>https://airren.github.io/blog/k8s_source_code_2_api_basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_source_code_2_api_basic/</guid>
      <description>Controller and Operator In this section you&amp;rsquo;ll learn about controllers and operators in Kubernetes and how they work.
The API server has the following core responsibilities:
To serve the Kubernetes API. This API is used cluster-internally by the master components, the worker nodes, and you Kubernetes-native apps, as well as externally by clients such as kubectl. To proxy cluster components, such as the Kubernetes dashboard, or stream logs, services ports, or serve kubectl exec sessions.</description>
    </item>
    
    <item>
      <title>Kubernetes CRD</title>
      <link>https://airren.github.io/CloudNative/Kubernates/10-k8s-crd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/10-k8s-crd/</guid>
      <description>Kubernetes 1.16 正式GA了CRD。
CRD介绍 声明式编程 在Kubernetes中我们使用了Deployment/DamenSet/tatefulSet来管理应用workdload，使用Service/Ingress来管理应用的
https://zhuanlan.zhihu.com/p/34445114</description>
    </item>
    
    <item>
      <title>Kubernetes Replication Controller</title>
      <link>https://airren.github.io/CloudNative/Kubernates/4-k8s-replic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/4-k8s-replic/</guid>
      <description>Replication Controller 1# replica.yaml 2--- 3apiVersion: v1 4kind: ReplicationController 5metadata: 6 name: first-replic 7spec: 8 replicas: 3 9 template: 10 metadata: 11 name: simple-pod 12 labels: 13 app: simple-pod 14 spec: 15 containers: 16 - name: timemachine 17 image: lukelau/rest-docker:0.0.1 18 args: 19 - -server.addr=0.0.0.0:8000 以上配置会保证Pod的数量稳定为3个。当我们删除一个Pod之后，Replication Controller就会创建出一个新的Pod来维持Pod的数量。
RC之所以会发现Pod已经挂掉了，是因为探针(Container probes)的存在。在K8s中， kubelet会通过指定的探针方式去探测容器是否存活。
三种探针方式
三种类型的handler
ExecAction： Executes a specified sommand inside the container. The diagnostic is considered successful if the command exits with a status code of 0.</description>
    </item>
    
    <item>
      <title>Kubernetes Service</title>
      <link>https://airren.github.io/CloudNative/Kubernates/3-k8s-service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/3-k8s-service/</guid>
      <description>Pod是最小的单元， 往往我们在运行一个应用的时候，对Pod有一些额外的要求，例如高可用或者多实例，这就意味着如果你只记住一个Pod的IP，那么很多时候时有问题的。 例如高可用，可能会因为Pod的重建而改变，这样你记住的那个IP就失效了。一个很自然的想法就是固定IP。
为什么要使用service
因为K8s里面的Pod是可以被调度的，并且重建的，所以没有固定的IP Pod的数量可能不只一个，当有多个Pod实例的时候负载均衡的需求。 1# service.yaml 2--- 3apiVersion: v1 4kind: Service 5metadata: 6 name: first-service 7spec: 8 type: NodePort 9 selector: 10 app: nginx 11 ports: 12 - protocol: TCP 13 port: 5580 14 targetPort: 80 15 nodePort: 32280 selector 过滤携带label app=nginx的pod
targetPort： pod 提供服务的端口
service代理Pod的内部端口为5580： 内部访问，固定IP：Port
service代理Pod的外部端口为32280， 通过k8s集群的IP，可以进行 外部可访问
1# create service 2kubectl apply -f service.yaml 3# get service status 4kubectl get service first-service 外部访问service
上面这个配置之所以可以在外部访问，是因为制定了Service的Type为NodePort， 在K8s中如果不指定这个Type的话，service时只能在K8s集群内部访问的，集群外部是访问不了的。</description>
    </item>
    
    <item>
      <title>Linux Network Command</title>
      <link>https://airren.github.io/blog/network_command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_command/</guid>
      <description>nc Netcat(or nc) is a command-line utility that reads and write data across network connections, using the TCP or UDP protocols. It is one of the most powerful tools in the network and system administrators arsenal, and it as considered as a Swiss army knife of networking tools.
Netcat is cross-platform, and it&amp;rsquo;s available for Linux, macOS, Windows , and BSD. You can use Netcat to debug and monitor network connections, scan for open ports, transfer data, as a proxy and more.</description>
    </item>
    
    <item>
      <title>Linux socket</title>
      <link>https://airren.github.io/blog/linux_socket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux_socket/</guid>
      <description>Internet domain socket Unix domain socket You can forward the unix domain socket with the -R option of the ssh command.
1ssh -R remote_socket:local_socket https://github.com/nikhilroxtomar/Multiple-Client-Server-Program-in-C-using-fork</description>
    </item>
    
    <item>
      <title>Mac Init</title>
      <link>https://airren.github.io/blog/Mac_init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/Mac_init/</guid>
      <description>HomeBrew 1/bin/bash -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;#34; 1brew install wget 2 3brew install go Software Chrome
Typora
Istat Menus
Alfred
Dash
Wireshark
Sublime
Modify Keys settings -&amp;gt; Keyboard -&amp;gt; modifyKeys
Tools 1apt install vim git tmux golang Vim 1# ~/.vimrc 2cat &amp;lt;&amp;lt;EOF| tee -a ~/.vimrc 3set nu 4syntax on 5inoremap jj &amp;lt;ESC&amp;gt; 6 7 8set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 9set termencoding=utf-8 10set encoding=utf-8 11 12&amp;#34; show existing tab with 4 spaces width 13set tabstop=4 14&amp;#34; when indenting with &amp;#39;&amp;gt;&amp;#39;, use 4 spaces width 15set shiftwidth=4 16&amp;#34; On pressing tab, insert 4 spaces 17set expandtab 18 19EOF oh my zsh 1sudo apt install zsh 2sh -c &amp;#34;$(wget https://raw.</description>
    </item>
    
    <item>
      <title>Make</title>
      <link>https://airren.github.io/blog/linux_make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux_make/</guid>
      <description>The marker - means ignore the err of this line command
@ only prints the result of command.</description>
    </item>
    
    <item>
      <title>Multi-Cluster Kubernetes</title>
      <link>https://airren.github.io/Multi-Cluster/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/Multi-Cluster/</guid>
      <description>What is Multi-Clusters Multi-cluster Kubernetes is a kubernetes deployments method that consists of to or more clusters. This deployment method is highly flexible. You can have clusters on the same physical host or different hosts in the same data center. You can also create a multi-cloud environment with clusters living in different clouds and even in different countries.
cluster network connections: https://submariner.io/getting-started/
https://isovalent.com/data/multi-cluster-ebook.pdf
Multi clusters server deployment: https://github.com/karmada-io/karmada
https://github.com/clusternet/clusternet
Submariner Submariner allows pods to directly communicate between Kubernetes clusters</description>
    </item>
    
    <item>
      <title>multus</title>
      <link>https://airren.github.io/blog/k8s_network_multus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_network_multus/</guid>
      <description>https://github.com/k8snetworkplumbingwg/multus-cn
Multus CNI enables attaching multiple netwrok interface to pods in Kubernets.
Multus CNI is a container nerwork interface plugin for Kubernets that enables attaching multiple network interfaces to pods. Typicaly, in Kubernetes each pod only has one network interface (apart from a loopback) &amp;ndash; with Multus you can create a multi-homed pod that has multiple interface. This is accomplished by Multus acting as a &amp;ldquo;meta-plugin&amp;rdquo;, a CNI plugin that can call multiple other CNI plugins.</description>
    </item>
    
    <item>
      <title>Nodus</title>
      <link>https://airren.github.io/nodus/nodus-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/nodus-architecture/</guid>
      <description>Image ovn4nfv-k8s-plugin NFN-Operator Exposes virtual, provider chaning CRDs to external world Programs OVN to create L2 switch Watches for PODs being coming up Assigns IP address ofr every network of the deployments Looks for replics and auto create routes for chaning to work Create LBs for distributing the load across CNF replicas OVN4NFV NFN-Agent Performs CNI operations Configuration VLAN and Routes in Linux Kernel(in case of ruotes, it cloud do it in both root and network namespace) Communicates with OVSDB to inform og provider interface.</description>
    </item>
    
    <item>
      <title>Nodus Dev Note</title>
      <link>https://airren.github.io/nodus/nodus-dev/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/nodus-dev/</guid>
      <description>SFC for IPV6 vagrant file updte:
mount a local file to the VM
1config.vm.synced_folder &amp;#34;/home/ubuntu/qiang/nodus-1.24/SDEWAN-SetUp/&amp;#34;, &amp;#34;/home/vagrant/mnt&amp;#34; vagrant version update to 2.2.19
1vagrant_version=2.2.19 enable ipv4_forward in calico configuration
update ovn deploy yaml: update image tag, update ovn_subnet
1 OVN_SUBNET: &amp;#34;10.154.141.0/18&amp;#34; 2OVN_GATEWAYIP: &amp;#34;10.154.141.1/18&amp;#34; 3 4 5 privileged: true 6 mountPropagation: Bidirectional 1apiVersion: k8s.plugin.opnfv.org/v1alpha1 2kind: NetworkChaining 3metadata: 4 name: example-networkchaining 5spec: 6 # Add fields here 7 chainType: &amp;#34;Routing&amp;#34; 8 routingSpec: 9 namespace: &amp;#34;default&amp;#34; 10 networkChain: &amp;#34;net=virtual-net1,app=slb,net=dync-net1,app=ngfw,net=dync-net2,app=sdewan,net=virtual-net2&amp;#34; 11 left: 12 - networkName: &amp;#34;left-pnetwork&amp;#34; 13 gatewayIp: &amp;#34;172.</description>
    </item>
    
    <item>
      <title>OAuth 2.0</title>
      <link>https://airren.github.io/blog/OAuth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/OAuth/</guid>
      <description>OAuth 2.0 </description>
    </item>
    
    <item>
      <title>ODMS Install</title>
      <link>https://airren.github.io/sdewan/odms-install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/odms-install/</guid>
      <description>Home Page: https://wiki.ith.intel.com/display/ITSODMS/Observability+Data+Management+Suite+Home
[TOC]
Operator Prometheus-operator https://prometheus-operator.dev/
https://github.com/prometheus-operator/prometheus-operator
The prometheus operator manages the Promentheus Clust atop Kubernetes.
Opentelemetry-operator https://github.com/open-telemetry/opentelemetry-operator
Kubernetes reflector https://github.com/emberstack/kubernetes-reflector
Reflector is a Kubernetes addon designed to monitor changes to resources (secrets and configmaps) and reflect changes to mirror resources in the same or other namespaces.
OpenTelemetry Agent &amp;amp; Gateway Configure by CR opentelemetrycollectors.opentelemetry.io
Agent collect Metric, Logs, and can add labels or attributes, and finally push the data to the opentelemetry gateway.</description>
    </item>
    
    <item>
      <title>OpenVPN Setup</title>
      <link>https://airren.github.io/blog/network_openvpn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_openvpn/</guid>
      <description>Configuration Server side Server.conf
1# /etc/openvpn/server/server.conf 2local 10.0.0.230 3port 1194 4proto udp 5dev tun 6ca ca.crt 7cert server.crt 8key server.key 9dh dh.pem 10auth SHA512 11tls-crypt tc.key 12topology subnet 13client-config-dir /etc/openvpn/ccd # bind ip with client name 14route 192.166.0.0 255.255.255.0 # route add to server side 15push &amp;#34;route 192.167.0.0 255.255.255.0&amp;#34; # route add to client side 16server 10.8.0.0 255.255.255.0 17push &amp;#34;redirect-gateway def1 bypass-dhcp&amp;#34; 18ifconfig-pool-persist ipp.txt 19push &amp;#34;dhcp-option DNS 10.0.0.1&amp;#34; 20keepalive 10 120 21cipher AES-256-CBC 22user nobody 23group nogroup 24persist-key 25persist-tun 26verb 4 # log level, 1-11, bigger more details 27crl-verify crl.</description>
    </item>
    
    <item>
      <title>OS memory</title>
      <link>https://airren.github.io/blog/os_memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/os_memory/</guid>
      <description>What is the maximum size of the stack?
It depends on your operating system. On Windows, the typical maximum size for a stack is 1MB, whereas it is 8MB on a typical modern Linux, although those values are adjustable in various ways. If the sum of your stack variables (including low-level overhead such as return addresses, stack-based arguments, return value placeholders, and alignment bytes) in the entire call stack exceeds that limit, you get a stack overflow, which typically takes down your program without any chance at recovery.</description>
    </item>
    
    <item>
      <title>OVN Open virtual Network</title>
      <link>https://airren.github.io/nodus/ovn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/nodus/ovn/</guid>
      <description>Open Virtual Network
OVN(Open Virtual Network) is a series of daemons for the Open vSwitch that translate virtual network configuration into OpenFlow.
OVN provides a higher-layer of abstraction than Open vSwitch, working with logical routers and logical switches, rather than flows.
Why did we choose OVN for Nodus?
One of the best programmable controller
Hides OVS complexity
Broader eco-system
L2 CNI - Support for unicast, multicast, broadcast applications
One site level IPAM - No IP address restriction with number of nodes</description>
    </item>
    
    <item>
      <title>Performance profiling</title>
      <link>https://airren.github.io/blog/linux_perf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/linux_perf/</guid>
      <description>Linux Performance Counter Hardware Event CPU
Performance Monitor Unit
Instruction retired Processor clock cycles Cache
Software Event Software counter/tracepoint
Page fault process context Tracepints is the hook in the Linux kernel. 在特定代码执行的时候会被触发。
1ls /sys/kernel/debug/tracing/events ![image-20221201151615697](/Users/airren/Library/Application Support/typora-user-images/image-20221201151615697.png)
If the machine not a baremetal, it can&amp;rsquo;t collect hardware event. For example in a esxi VM.
Request
LLC-load-misses Instructions Cycles The ODMS containes now:
Dashboard consists of 12 panels based on following metrics:</description>
    </item>
    
    <item>
      <title>PKCS11</title>
      <link>https://airren.github.io/blog/crypto_pkcs11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/crypto_pkcs11/</guid>
      <description>PKCS#11 Terminology Cryptoki Cryptoki(Cryptographic Token Interfaces) is a library(dll or so file) that is provided by the cryptographic device vendors. It contains an implementation of the PLCS#11 C header files. Every cryptographic device vendor provides its own PKCS#11 complaint library. Applications has to load this library in order to access the cryptographic device.
Slots Slots are the logical partitions in the cryptographic device. In case of HSMs, there could be hundreds or more slots are available while in the case of smart cards, there could be only on slot available.</description>
    </item>
    
    <item>
      <title>React</title>
      <link>https://airren.github.io/react/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/react/%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>React 入门笔记 1. 自定义组件&amp;mdash;在html中使用react 1&amp;lt;!DOCTYPE html&amp;gt; 2&amp;lt;html&amp;gt; 3 &amp;lt;head&amp;gt; 4 &amp;lt;title&amp;gt;Hello React&amp;lt;/title&amp;gt; 5 &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; 6 &amp;lt;/head&amp;gt; 7 &amp;lt;body&amp;gt; 8 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 9 &amp;lt;!--应用渲染位置 --&amp;gt; 10 &amp;lt;/div&amp;gt; 11 &amp;lt;script src=&amp;#34;react/build/react.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 12 &amp;lt;script src=&amp;#34;react/build/react-dom.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 13 &amp;lt;script&amp;gt; 14 // 应用的JavaScript代码 15 ReactDOM.render( 16 React.DOM.h1(null, &amp;#34;hello world&amp;#34;), 17 document.getElementByID(&amp;#34;app&amp;#34;) 18 ) 19 &amp;lt;/script&amp;gt; 20 &amp;lt;/body&amp;gt; 21&amp;lt;/html&amp;gt; React.DOM.*的使用 1React.DOM.h1( 2	{ 3 id: &amp;#34;my-heading&amp;#34; // 第一参数用于指定该组件的DOM 属性 4 }, 5 &amp;#34;hello world&amp;#34; // 第二个参数定义该组件的子元素 6), 7 8// 可以有多个子元素 9Reat.</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://airren.github.io/blog/redis_preview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/redis_preview/</guid>
      <description>bitmap
背景知识 文件：
​ 数据可以存在文件里，通过grep awk 查找文件。
​ 如果文件变大，10M -&amp;gt; 1T , 查找会变慢。全量扫描IO。
数据库：（受限于IO）
​ mysql 存储， 存储分块，可以通过索引直接获取datapage中的数据。
索引也是数据块
二级索引，给索引建立索引
表很大，如果连接比较少，读 如果命中索引，查询还是毫秒级别
如果并发很大（足够大），如果每个查询的数据都是独立的，会收到吞吐的限制。
Redis+数据库：（内存与磁盘的折中方案）
nosql -&amp;gt; key vale
短域名-&amp;gt; 长域名，计数
关联表的数据也放置在value中。只关注每条记录自身。
基于内存的
worker 单线程
6.x IO threads
value 是有类型的 string、list、set、hash、zset；且每种类型有自己的本地方法。
数据向计算移动
计算向数据移动
连接池：
socket list 线程池：
可以使用一个线程去处理连接池中的连接（nio，多路复用，epoll） 内存数据库：（受限于成本）
Hana https://bytedance.feishu.cn/docs/doccnwV2ZxHYiLagaPOQSZ3ldlr
常识：s&amp;lt;- ms &amp;lt;-us &amp;lt;-ns
硬盘：
带宽、吞吐：百兆，1-2G pci-e/ nvme 3G/s
寻址时间 ms
内存:
寻址时间 ns redis 安装 http://db-engines.com
http://redis.io
编译安装</description>
    </item>
    
    <item>
      <title>Reflect, Unsafe, and Cgo</title>
      <link>https://airren.github.io/note_go/14-golang_reflect_unsafe_cgo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/14-golang_reflect_unsafe_cgo/</guid>
      <description>Reflect
Reflection Let Us Work with Types at Runtime But sometimes, relying on only compilation-time information is a limitation. You might need to work with variables at runtime using information that didn&amp;rsquo;t exist when the program was written. Maybe you&amp;rsquo;re trying to map data from a file or network request into a variable, or you want to build a single function that works with different types. In those situations, you need to use reflection.</description>
    </item>
    
    <item>
      <title>SDEWAN AWS test nodus</title>
      <link>https://airren.github.io/sdewan/sdewan-AWS-testnodus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-AWS-testnodus/</guid>
      <description>ICN-SDWAN-Virginia AWS2
IPv4 Prefixes Public IPv4 Private IPv4 ICN-SDWAN-Virginia-Eth1 3.211.4.230 10.20.0.232 ICN-SDWAN-Virginia-Eth0 34.230.111.156 10.20.0.23 ICN-SDWAN- California AWS5
IPv4 Prefixes Public IPv4 Private IPv4 ICN-SDWAN-California-Eth1 54.177.9.32 172.16.182.169 ICN-SDWAN-California-Eth0 54.241.18.249 172.16.182.237 iptables -I POSTROUTING -d 172.17.0.2/32 -j SNAT &amp;ndash;to-source 192.169.0.4 -t nat
iptables -I POSTROUTING -d 10.0.0.1/24 -j SNAT &amp;ndash;to-source 10.8.0.1 -t nat
AWS2 eth1 MAC Address
0e:4e:31:15:1a:ed
0e:4e:31:15:1a:ed
1ip addr add 10.20.0.232/20 dev 1eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 0e:4e:31:15:1a:ed brd ff:ff:ff:ff:ff:ff inet 10.</description>
    </item>
    
    <item>
      <title>SDEWAN Leverage SGX to provide Secure Access Service Edge</title>
      <link>https://airren.github.io/sdewan/sdewan-sgx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-sgx/</guid>
      <description>SD-WAN handles the network connectivity issues between distributed applications in a seamless, secure, and efficient manner by replacing traditional branch routers with virtualized or appliance-based software. However, as the concept of edge prevails recently, distributed applications are usually deployed across multiple resource-constrained k8s edges. Then how to expose the services and manage the connections in a cloud-native way becomes a critical issue for users.
The open-source project Software Define Edge WAN(SD-EWAN) under the Akraino community’s ICN blueprint is definitely a comprehensive solution.</description>
    </item>
    
    <item>
      <title>SDEWAN Setup</title>
      <link>https://airren.github.io/sdewan/sdewan-pull-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-pull-mode/</guid>
      <description>SDEWAN: Setup by pull mode Version requirement:
​	Ubuntu: 20.04
​	scc: build from https://github.com/intel-sandbox/akraino-sdewan/tree/rc-22.06
​	cnf: docker pull integratedcloudnative/sdewan-cnf:0.5.3
crd-controller: docker pull integratedcloudnative/sdewan-controller:0.5.3
0.Create an Github repo for pull mode ​	Create an Github repo for SDEWAN pull mode, for example: https://github.com/airren/flux
​ Next, prepare an Personal access tokens for SDEAN to access the repo.
Update your repo info and token to this file SDEWAN-SetUp/ewo-tools/cluster-sync-object.yaml.
1# SDEWAN-SetUp/ewo-tools/cluster-sync-object.yaml 2--- 3# creating cluster-sync-obj 4version: ewo/v1 5resourceContext: 6anchor: overlays/overlay1/cluster-sync-objects 7metadata: 8name: cso2 9description: 10userData1: 11userData2: 12spec: 13kv: 14- gitType: github 15- userName: Airren # change to your own github username 16- gitToken: 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 # change to your own 17- repoName: flux # change to your own 18- branch: main Update the GITHUB_TOKEN in SDEWAN-SetUp/setup_flux.</description>
    </item>
    
    <item>
      <title>SDEWAN SGX Test Environment</title>
      <link>https://airren.github.io/sdewan/sdewan-sgx-testenv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/sdewan-sgx-testenv/</guid>
      <description>Prepare Machine 1sudo ip route add default via 10.0.11.100 dev eno1 2 3cat &amp;lt;&amp;lt;EOF | sudo tee /etc/resolv.conf 4nameserver 127.0.0.53,10.248.2.5 5options edns0 trust-ad 6search sh.intel.com 7EOF 8 9sudo vi /etc/netplan/00-installer-config.yaml 10network: 11 ethernets: 12 eno1: 13 dhcp4: true 14 nameservers: 15 addressses: [10.248.2.5] 16 version: 2 17 18 19 20git clone -b sgx http://sdewan.sh.intel.com:10880/airren/SDEWAN-SetUp.git 21 22 23 24 25apt-cache search linux-image 26sudo apt-get install linux-image-your_version_choice linux-headers-your_version_choice linux-image-extra-your_version_choice 27 28# must reboot you machine 29sudo apt update &amp;amp;&amp;amp; sudo apt install -y linux-image-5.</description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://airren.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/search/</guid>
      <description>This file exists solely to respond to /search URL with the related search layout template.
No content shown here is rendered, all content is based in the template layouts/page/search.html
Setting a very low sitemap priority will tell search engines this is not important content.
This implementation uses Fusejs, jquery and mark.js
Initial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [&amp;ldquo;HTML&amp;rdquo;, &amp;ldquo;JSON&amp;rdquo;] ```</description>
    </item>
    
    <item>
      <title>Service function chain</title>
      <link>https://airren.github.io/sdewan/service-function-chain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/sdewan/service-function-chain/</guid>
      <description>1node-1 10.151.128.13 2node-2 10.151.128.14 1# Hub 2ip rule add iif vti_192.169.0.1 lookup 51 3ip rule add iif vti_192.169.0.2 lookup 51 4ip route add default via &amp;lt;net pod&amp;gt; dev net1 table 51 5#ip route add default via 10.151.128.13 dev net1 table 51 6 7# Node-1 8ip route add 192.169.0.0/24 via 10.151.128.14 dev net1 9 10# Node-2 11ip route add 192.169.0.0/24 via 10.151.128.12 dev net1 12 13 14sysctl -w net.ipv4.ip_forward=1 15 echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward </description>
    </item>
    
    <item>
      <title>String 字符串</title>
      <link>https://airren.github.io/DataStruct/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/DataStruct/string/</guid>
      <description>计算生物学家的一项工作就是根据密码将DNA转换为由4个碱基组成的非常长的字符串。
Knuth、Morris、Pratt 子字符串查找算法，这些经典算法的基础是两个基本概念：形式语言和确定有限状态自动机。
JACA 安装配置</description>
    </item>
    
    <item>
      <title>strongswan</title>
      <link>https://airren.github.io/blog/2_strongswan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/2_strongswan/</guid>
      <description>When reading/adjusting any StrongSwan configurations, remember these important words:
left is local to the machine it&amp;rsquo;s stated on; right is remote in the same manner
So, on the server side, left is local to the server and on the client side, left is local to that client.
check the X509 cert details
1openssl x509 -text -noout -in /etc/ipsec.d/private/sunKey.pem ​
Ubuntu Set up IPsec Tunnel 1docker run --rm -d -i --network host --name cnf --user root -v /home/ubuntu/entrypoint.</description>
    </item>
    
    <item>
      <title>StrongWAN configure with CNF.</title>
      <link>https://airren.github.io/blog/2_strongwan_NAT_travalse/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/2_strongwan_NAT_travalse/</guid>
      <description>Download the material
1wget -r -N -nd http://sdewan.sh.intel.com:8888/ipsec-demo/ modify the node selector in cnf-1.yaml and cnf-2.yaml respectively. Create 2 pod on different node with host network.
1 nodeSelector: 2 # change to the specific node 3 kubernetes.io/hostname: node Copy cert to the CNF Pod.
Find the container id for cnf-1 and cnf-2.
1# For cnf-1, copy sunCert to it 2docker cp ./cert/caCert.pem $(kubectl describe po cnf-1|grep docker:|awk -F / &amp;#39;{print $3}&amp;#39;):/etc/ipsec.</description>
    </item>
    
    <item>
      <title>ToDoList</title>
      <link>https://airren.github.io/ToDo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/ToDo/</guid>
      <description>CNCN 项目的几个阶段
Libos
NIO BIO
DMA是什么
sr-iov
ebpf
ovs
cilium
calico flannel
ipsec GRE
两个方向，一个是存储，一个是网络
1、有dpdk、ebpf、ovs、lvs、nginx、hyperplane等系统研发经验； 2、有智能网卡、硬件卸载、P4等高性能网络研发经验； 3、有VPC、NAT、负载均衡等云网络产品研发经验。
GRE/VxLAN/OpenFlow等协议；
ESXI8.0 license: 4V492-44210-48830-931GK-2PRJ4</description>
    </item>
    
    <item>
      <title>Unix Init</title>
      <link>https://airren.github.io/blog/Linux_init/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/Linux_init/</guid>
      <description>Tools 1apt install vim git tmux golang Vim 1# ~/.vimrc 2cat &amp;lt;&amp;lt;EOF | tee -a ~/.vimrc 3set nu 4syntax on 5inoremap jj &amp;lt;ESC&amp;gt; 6 7 8set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 9set termencoding=utf-8 10set encoding=utf-8 11 12&amp;#34; show existing tab with 4 spaces width 13set tabstop=4 14&amp;#34; when indenting with &amp;#39;&amp;gt;&amp;#39;, use 4 spaces width 15set shiftwidth=4 16&amp;#34; On pressing tab, insert 4 spaces 17set expandtab 18 19EOF oh my zsh 1sudo apt install -y zsh 2sh -c &amp;#34;$(wget https://raw.</description>
    </item>
    
    <item>
      <title>User Kuberbuilder to create a CRD operator</title>
      <link>https://airren.github.io/blog/k8s_operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_operator/</guid>
      <description>Develop Environment Kind kind is a tool for running local Kubernetes clusters using Docker container &amp;ldquo;nodes&amp;rdquo;. kind was primarily designed for testing Kubernetes itself but may be used for local development or CI.
1kind load docker-image --name &amp;lt;kind-cluster-name&amp;gt; --nodes &amp;lt;node-name&amp;gt; &amp;lt;image-name&amp;gt;:latest Certmangaer 1helm repo add jetstack https://charts.jetstack.io 2helm repo update 3helm install \ 4 cert-manager jetstack/cert-manager \ 5 --namespace cert-manager \ 6 --create-namespace \ 7 --version v1.10.1 \ 8 --set installCRDs=true Question</description>
    </item>
    
    <item>
      <title>VPC</title>
      <link>https://airren.github.io/blog/network_VPC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_VPC/</guid>
      <description></description>
    </item>
    
    <item>
      <title>What is VLAN and Virtual Network Interface</title>
      <link>https://airren.github.io/blog/network_VLAN/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_VLAN/</guid>
      <description>In our day-to-day life, we have seen LAN and WAN architectures mostly because we have to deal with only one IP address on one interface. We either connect our system with LAN cable or with WiFi.
In this article, we will discuss the VLAN and how to create the VLAN on the Ubuntu server, but let first understand what is VLAN and why we use VLAN.
What is VLAN Virtual Local Area Network(VLAN) is a logical concept of breaking large broadcast domains into small domains.</description>
    </item>
    
    <item>
      <title>What is VXLAN</title>
      <link>https://airren.github.io/blog/network_VXLAN/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/network_VXLAN/</guid>
      <description></description>
    </item>
    
    <item>
      <title>中文简体</title>
      <link>https://airren.github.io/CloudNative/Kubernates/K8s_network/Servicefufu-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/K8s_network/Servicefufu-/</guid>
      <description></description>
    </item>
    
    <item>
      <title>参数传递</title>
      <link>https://airren.github.io/CloudNative/Linux/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid>
      <description>1. 顺序传参 参数名 作用 $0 filename $1/$2/$3 &amp;hellip;.$n 第n个参数 2. OPT 只能用单个字母
1#!/bin/bash 2 3while getopts &amp;#34;:n:a:h&amp;#34; optname; do 4	case &amp;#34;$optname&amp;#34; in 5	&amp;#34;n&amp;#34;) 6	echo &amp;#34;get option -name, value is $OPTARG&amp;#34; 7	;; 8	&amp;#34;a&amp;#34;) 9	echo &amp;#34;get option -age, value is $OPTARG&amp;#34; 10	;; 11	&amp;#34;h&amp;#34;) 12	echo &amp;#39; 13	-n name of user 14	-a age of user 15	&amp;#39; 16	;; 17	&amp;#34;:&amp;#34;) 18	echo &amp;#34;No argument value for option $OPTARG&amp;#34; 19	;; 20K	&amp;#34;?</description>
    </item>
    
    <item>
      <title>基本语法梳理</title>
      <link>https://airren.github.io/note_go/1_Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%A2%B3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%A2%B3%E7%90%86/</guid>
      <description>源文件 原文件使用UTF-8编码，对Unicode支持良好。每个源文件都属于包的一部分，在文件头部用package声明所属包的名称
1package main 2func main(){ 3 println(&amp;#34;hello world!!&amp;#34;) 4} 以.go作为文件扩展名，语句结束分号会被默认省略，支持C样式注释。入口函数main没有参数，且必须放在main包中
用import导入标准库或第三方包
1package main 2import{ 3 &amp;#34;fmt&amp;#34; 4} 5 6func main(){ 7 fmt.Println(&amp;#34;hello world!&amp;#34;) 8} 可以直接运行或者编译为可执行文件
变量 使用var定义变量，支持类型推断。基础数据类型划分清晰明确，有助于编写跨平台应用。编译器确保变量总是被初始化为0，避免出现意外状况。
1package main 2func main(){ 3 var x int32 4 var s=&amp;#34;hello world!&amp;#34; 5 // 两个数据之间默认使用空格隔开 6 println(x,s) 7} 在函数内部，还可以省略var关键字，使用更简单的定义模式。
1package main 2 3//y := 200 // 该声明方式仅在函数内部使用，不可用来声明全局变量 4func main() { 5	x := 100 6	println(x) 7} 编译器将未使用的局部变量定义当做错误
表达式 Go仅有三种流控制语句
if 1package main 2 3func main() { 4	x := 100 5	if x &amp;gt; 0 { 6	print(&amp;#34;x&amp;#34;) 7	} else if x &amp;lt; 0 { 8	print(&amp;#34;-x&amp;#34;) 9	} else { 10	print(&amp;#34;0&amp;#34;) 11	} 12} switch 1package main 2 3func main() { 4	x := 0 5	switch { 6	case x &amp;gt; 0: 7	print(&amp;#34;x&amp;#34;) 8	case x &amp;lt; 0: 9	print(&amp;#34;-x&amp;#34;) 10	default: 11	print(&amp;#34;0&amp;#34;) 12	} 13} for 1func main() { 2	for i := 0; i &amp;lt; 5; i++ { 3	println(i) 4	} 5	for i := 4; i &amp;gt;= 0; i-- { 6	println(i) 7	} 8} 1package main 2 3func main() { 4	x := 0 5 for x &amp;lt; 5 { // 相当于 while(x&amp;lt;5) 6	println(x) 7	x++ 8	} 9} 1package main 2 3func main() { 4	x := 4 5	for { // 相当于while(true) 6	println(x) 7	x-- 8	if x &amp;lt; 0 { 9	break 10	} 11	} 12} 在迭代遍历时，for&amp;hellip;range除了元素外，还可以返回索引</description>
    </item>
    
    <item>
      <title>安装配置Mysql</title>
      <link>https://airren.github.io/component/DataBase/mysql/install_mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/component/DataBase/mysql/install_mysql/</guid>
      <description>修改表字段
1# 新增一个字段 2alert table rules add effect_time mysql sql 8.0 认证问题
connect to 10.227.4.115:3306 err: this authentication plugin is not supported
1alter user root@% identified with mysql_native_password by &amp;#34;123456&amp;#34; 1CREATE DATABASE IF NOT EXISTS echo_bio DEFAULT CHARSET utf8 COLLATE utf8_general_ci; </description>
    </item>
    
    <item>
      <title>容器技术基础</title>
      <link>https://airren.github.io/CloudNative/Kubernates/Container-Intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Kubernates/Container-Intro/</guid>
      <description>为什么容器里只能跑“一个进程”？ 为什么我原先一直在用某个JVM参数，在容器里就不好使了？ 为什么kubernetes就不能固定IP地址？容器网络联不通又该如何去debug？ Kubernetes中的StatefulSet和Operator到底什么区别？PC和PVC这些概念又该怎么用？ Linux进程模型对容器本身的重要意义，控制器模式对整个K8s项目提纲挈领的作用？ 从PaaS到K8s PaaS PaaS(Platform as a Service) 应用托管。
Docker镜像，其实就是一个压缩包，直接由一个完整的操作系统的所有文件和目录构成。
其实只打包了文件系统，不包括操作系统的内核。各种内核相关的模块或者特性支持完全依赖于宿主机。
通过docker build 打包镜像，docker run 运行镜像，docker run创建的沙盒，就是使用Linux Cgroups和Namespace机制创建出来的隔离环境。解决了应用打包这个根本性问题。
Swarm swarm 提供集群管理功能
单机docker项目
1docker run &amp;lt;container-name&amp;gt; 多机docker项目
1docker run -H &amp;#39;swarm cluster API&amp;#39; &amp;lt;container-name&amp;gt;	Fig 项目 Fig项目第一次在开发者面前提出了容器编排(Container Orchestration)的概念。
加入用户现在需要部署的是应用容器A、数据库容器B、负载均衡容器C，那么Fig就允许用户把ABC三个容器定义在一个配置文件中， 并且可以指定他们之间的关联关系，比如容器A需要访问数据库B。定义好之后，只需要执行一条非常简单的指令。
1fig up Fig就会把这些容器的定义和配置交给DockerAPI按照访问逻辑一次创建。而容器A和B之间的关联关系，也会交给docker的Link功能通过写入hosts文件的方式进行配置。更重要的是，你还可以在Fig的配置文件里定义各种容器的副本个数等编排参数。
Fig 项目被Docker收购后更名为Compose。
Libcontainer LibContainer -&amp;gt; RunC
以RunC为依据，制定容器和镜像的标准和规范。
OCI(Open Container Initiative), 意在将容器运行时和镜像的实现从Docker项目中完全剥离出来。
Containerd 容器运行时
进程隔离与限制 程序被执行起来，它就从磁盘上的二进制文件，变成了计算机 内存中的数据，寄存器里的值，堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。像这样一个程序运行起来后的计算机执行环境的总和，就是：进程。
对于进程来说，它的静态表现就是程序，一个二进制文件；而一旦运行起来，就变成了计算机数据和状态的总和，这就是进程的动态表现。
容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。对于大多数Linux容器来说， Cgroups是用来制造约束的主要手段， 而Namespace技术则是用来修改进程视图的主要方法。
隔离 1docker run -it busybox /bin/sh What is BusyBox?</description>
    </item>
    
    <item>
      <title>怎么成为K8s的Contributor</title>
      <link>https://airren.github.io/blog/k8s_contributer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/k8s_contributer/</guid>
      <description>Important Doc
Contributor Cheat Sheet 加入SIG SIG(Special Interest Groups) 是Kubernetes社区中关注特定模块的永久组织。
作为刚参与社区的开发者，可以从sig/app, sig/node, sig/scheduling 这几个SIG开始。
KEP KEP(Kubernetes Enhancement Proposal)。对于功能和API的修改都需要先在kubernetes/enhancements仓库对应SIG的目录下提交Proposal才能实施。所有的Proposal都必须经过讨论，通过社区SIG Leader的批准。
很多不熟悉Kubernetes工作流的开发者会在社区中直接提交一个包含API改动的commit，但是如果这类commit没有对应的KEP 是不会被社区合入的。
项目设计 所有进入开发状态的功能都会有一个非常详细的KEP。KEP有一个详细的模板，设计是非常规范的。我们再日常的开发中也可以使用类似的格式写设计文档或者技术文档。
最近几年新实现的功能都会有着比较详细的KEP文档
分布式协作 Kubernetes 中所有的社区会议都会使用Zoom录制，并上传到Youtube。大多数的讨论和交流也对会再对应的issue和PR中。
每个提交的PR都要通过2K以上的成员的review以及几千个单元测试、集成测试、端到端测试以及扩展性测试，这些测定共同保证了项目的稳定性。
kubernetes/test-infra 项目中包含了Kubernetes的测试基础配置。 很多端到端的测试都会启动Kubernetes集群，并在真实的环境中测试代码的逻辑，这些测试可能一次会执行几十分钟，并且有一定概率出现Flaky。
影响力 提高个人和公司在开源社区的影响力，也是参与社区的重要目的。
对个人来说，参与开源项目可以快速理解项目的实现原理以及工作流程。如果想要在未来从事相关的工作，参与开源项目一定是加分项。
对公司来说，参与开源项目可以提高公司在开源社区的话语权，提高公司的技术影响力。足够的话语权也会让开源社区在关键需求上有较快的支持，减少与社区代码的分叉，降低维护成本，并满足公司内部的需求。
操作指南 参与开源项目并不一定要从非常复杂的功能或者Proposal开始。任何一个对代码库有利的PR都是值得提交的。修复代码中的typo 或者静态检查错误，作为最开始的工作是没有任何问题的。这能够帮我们快速热身。不过在熟悉了kubernetes的提交流程之后就没有必要做类似的提交了，以为所有的提交都需要Reviewer和Approver的批准，我们应该尽可能的做有意义的变动，减少他们的工作量。
从阅读源码开始 我们可以从自己熟悉的模块入手，了解该模块的实现原理，在阅读代码的过程中，我们很容易发现源代码中的一些typo和缺陷，这个时候就可以提交PR修复这些问题。
从静态检查开始 .golint_failures 文件中忽略了几百个Package中的静态检查，你可以在其中选择合适的Package作为成为Kubernetes贡献者的而第一步。
从项目管理开始 也可以选择Kubernetes的项目管理， sig/release.
选取第一个kubernetes问题 issue 列表
使用tag过滤问题 “good first issue” “help wanted” 这些标签表明了对新手非常友好。有时候问题也会被打上错误标签，也许是技术难度被低估了。
TODO 搜索代码库里的TODO。
Go 语言的开发规范、分布式社区的治理方式
代码需要每天都看，留出专门的时间来查看Kubernetes的源码，对它的核心组件的实现看看，构建一下, 测试一下，修一下Bug，typo等。
一般半年之后，你就可以熟悉基础项目，并且开始贡献代码。
当你已经和团队协作的很熟悉，就会自然承接一些子任务，然后团队就会赋予你写的权限，这样就可以顺理成章的成为Kubernetes的committer。这个时候你就是这个子项目的maintainer了
TODO 加入 Kubenetes Slack Channle 加入邮件列表 加入SIG 参加社区会议 提issue 如何提交PR</description>
    </item>
    
    <item>
      <title>极客时间 GO实践</title>
      <link>https://airren.github.io/note_go/99_Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/</guid>
      <description>微服务概览 康威定律
You build it. You fix it.
按照业务组织服务。
按照业务能力组织服务的意思是
去中心化 数据去中心化 隔离性： 每个服务要独享自己的存储设置。 治理去中心化 账号服务 服务发现 技术去中心化 收敛语言，go, C++ 基础设置自动化 CICD
Prometheus/ELK/Control Panle
可用性&amp;amp;兼容性设计 Design for Failure，所有的依赖都可能会炸，所有可能出现err的地方都可能出现panic。
隔离 超时控制 负载保护 限流 降级 重试 负载均衡 微服务设计 API Gateway API版本升级，强耦合
面向用户的业务场景的API，而不是面向资源的API&amp;ndash; 前轻后重
安全认证，限流
gRPC &amp;amp; 服务发现 第6课 评论系统架构设计 https://github.com/go-kratos
功能模块 理解整个背后的业务逻辑，理解业务的本质，事情的初衷。搞清楚系统背后的背景，才能做出最佳的抽象和设计。
在动手设计前反复思考，真正编码的时间只有5%？
不要在想的不清不楚的时候动手。
Mysql: OLTP 如果是group by等计算密集型查询的容易把数据库打垮。
Binlog ?
架构设计等同于数据设计，梳理清楚数据的走向和逻辑。
尽量避免环形依赖。
malloc 申请2G的内存，是否真正绑定了2G物理内存。
什么是缺页中断。
架构设计
存储设计
可用性设计</description>
    </item>
    
    <item>
      <title>滕王阁序</title>
      <link>https://airren.github.io/life/silence/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/life/silence/%E6%BB%95%E7%8E%8B%E9%98%81%E5%BA%8F/</guid>
      <description>唐·王勃
​	豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。雄州雾列，俊采星驰。台隍枕yixiazhij</description>
    </item>
    
    <item>
      <title>策略路由</title>
      <link>https://airren.github.io/CloudNative/Linux/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/CloudNative/Linux/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/</guid>
      <description>策略路由 所有来自网络A的包选择X路径，其他选择Y路径。或者说所有TOS为A的包选择路径F,其他选择路径K.
多表路由（multiple Routing Tables） 传统的路由算法仅仅使用一张表，有些情形下是需要使用多路由表的。
规则（Rule） 所有来自192.168.1.5的包，使用路由表10,本规则的优先级是990
所到到192.168.127.117的包使用路由表11, 本规则的优先级是991；
规则三要素
什么样的包应用本规则 ip route add 增加路由到指定的路由表，默认为main表</description>
    </item>
    
    <item>
      <title>自控力</title>
      <link>https://airren.github.io/blog/Book_WillPower/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/Book_WillPower/</guid>
      <description>自控力
The WillPower Instinct
“意志力学科”这门课汇集了心理学、经济学、神经学、医学领域关于自控的最新洞见，告诉人们如何改变旧习惯，培养健康的新习惯、克服拖延、抓住重点、管理压力。阐述了为何人们会在诱惑前屈服，以及怎样才能抵挡住诱惑。此外，它还提出了理解自控局限的重要性，以及培养意志力的最佳决策。
对于意志力科学的理解有助于培养自控力，让人们更有精力追逐最重要的东西。自控的策略有助于人们抵制各种各样的诱惑。
为了成功做到自控，你必须知道自己为何失败 提高自控力的最有效途径在于，弄清自己如何失控、为何失控。意识到自己有多容易失控，并非意味着你是一个失败者。恰恰相反，这将有助于你避开意志力失效的陷阱。研究表明，自诩为意志坚定的人反而最容易在诱惑面前失控。因为他们无法预测自己在何时何地、会由于何种原因失控。他们在面对挫折时更容易吃惊，在陷入困境时更容易放弃。
自知之明是自控的基础。认识到自己意志力存在问题，则是自控的关键。
当我们屈从于诱惑或者拖着不该做的事时，是什么拖了我们的后腿？是哪些致命的错误？更重要的是，我们如何寻找机会，避免来犯同样的错误。我们怎样从失败中汲取经验，为成功铺平道路？
这些行为虽不完美，却是人之常态。每个人都在以某种方式抵制诱惑、癖好、干扰和拖延。这不是个体的弱点或个人的不足，而是普遍的经验，是人所共有的状态。
理论固然好，但是数据更重要。
沉迷于电视剧不能自拔
总是幻想或者希望自己和主角处于同样的状态，同样可以随心所欲的处理各种困境。更不想进一步打破自己的幻想，不想回归现实。可事实却是，越沉浸于其中，却又距离故事中的主角远了一步。这个世界上有太多看不完的故事，不是每个故事都需要去读，选择重要的，选择真正有意义，有营养的文化饕餮。</description>
    </item>
    
    <item>
      <title>高并发负载均衡</title>
      <link>https://airren.github.io/blog/high_concurrency_lb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/blog/high_concurrency_lb/</guid>
      <description>高并发，负载均衡，高可用
不要因为技术而技术, 软件工程学需要分层解耦
应用层 1# $$ current process pid 2cd /proc/$$/fd 0 stdin
1 stdout
2 stderr
1# 8 is the name of the file descriptor, &amp;lt;&amp;gt; in and out direction 2exec 8&amp;lt;&amp;gt; /dev/tcp/www.baidu.com/80 3# exec 8&amp;lt;&amp;amp; - 4# &amp;amp; represent the argument is a fd 5echo -e &amp;#34;GET / HTTP/1.0\n&amp;#34; &amp;gt;&amp;amp; 8 传输层 </description>
    </item>
    
  </channel>
</rss>
