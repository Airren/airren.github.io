<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go Note on ByteGopher</title>
    <link>https://airren.github.io/note_go/</link>
    <description>Recent content in Go Note on ByteGopher</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Sep 2020 11:40:22 +0000</lastBuildDate><atom:link href="https://airren.github.io/note_go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「Go」依赖管理 Go Modues/ GOPATH</title>
      <link>https://airren.github.io/note_go/1_go_modules/</link>
      <pubDate>Tue, 04 Aug 2020 23:53:48 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_go_modules/</guid>
      <description>不要吝啬你的批评与感悟，敬请留言，我们一起进步。
如果你有过以下问题，欢迎阅读文章，提出意见与建议
go mod 怎么使用？ GOPATH是什么？ GO111MODULE=&amp;quot;&amp;quot; 这个参数决定了什么？ go get、go download 有什么区别？ import到底import的什么东西？ 依赖管理工具 用过Java 的同学都知道，对依赖的管理经历了从原始的手动引入jar包，到使用maven等自动化管理工具去引入第三方依赖的过程，从而可以使用别人已经开发好的优秀工具。如果使用过Python的同学可能会熟练的使用pip install 第三方的工具包。Java 和Python的第三方工具包都是集中式管理的，使用maven 或者是pip 都是从对应的管理中心下载更新依赖。当然还有 npm、yarn、gradle等其他语言的依赖版本工具。
在go语言中，第三方依赖的管理工具经过了一个漫长的发展过程。在GO1.11 发布之前govendor、dep等工具百花齐放。直到go mod 出现，开始一统天下。go 的依赖非常简单粗暴，只要依赖源码就可以了。例如：
1import &amp;#34;github.com/jinzhu/gorm&amp;#34; github.com/jinzhu/gorm 就是gorm的GitHub项目路径。
GOPATH时期 Go 在1.11 之前使用GOPATH模式进行依赖的管理。安装部署go环境，使用go 进行开发的时候强制被要求要设置GOPATH（当然安装过程中也会默认指定$GOPATH=~/go）。 要在GOPATH路径下新建 /src /bin /pkg文件夹。
1➜ ~/go 2├── bin # 存储go编译生成的二进制可执行文件，一般会把该路径配置到PATH中,PATH=$PATH:$GOPATH/bin 3├── pkg # 存储预编译的目标文件，以加快后续的编译速度 4└── src # 存储Go的源代码，一般以$GOPATH/src/github.com/foo/bar的路径存放 1➜ ~ go env |grep GOPATH 2GOPATH=&amp;#34;/Users/bytedance/go&amp;#34; 在这种模式下，如果使用go get 拉取外部依赖会自动下载并安装到$GOPATH/src 目录下。
这种模式下，go get没有版本管理的概念，无法处理依赖不同版本的问题，因为同一个依赖都存在同一个路径下面。
在Go官方还没有推出Go Modules 的时候，go的依赖管理工具可谓是百花齐放，例如 govendor， dep，但是最终Go Modules发布，平息了诸侯割据的局面。</description>
    </item>
    
    <item>
      <title>「Go」并发实现</title>
      <link>https://airren.github.io/note_go/8_go_concurrency/</link>
      <pubDate>Wed, 05 Aug 2020 00:14:06 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/8_go_concurrency/</guid>
      <description>如何用go实现一个简单的并行任务
Golang并发 1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;sync&amp;#34; 6) 7 8var wg sync.WaitGroup 9 10func printer(ch chan int) { 11	for i := range ch { 12	fmt.Printf(&amp;#34;Received %d &amp;#34;, i) 13	} 14	wg.Done() // 15} 16 17// main is the entry point for the program. 18func main() { 19	c := make(chan int) 20	go printer(c) 21	wg.Add(1) 22 23	// Send 10 integers on the channel.</description>
    </item>
    
    <item>
      <title>「Go」context</title>
      <link>https://airren.github.io/note_go/7_go_context/</link>
      <pubDate>Tue, 11 Aug 2020 23:53:48 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/7_go_context/</guid>
      <description>context.Context用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与Goroutine有非常密切的关系。
1type Context interface{ 2 Deadline()(deadline time.Time, ok bool) 3 Done() &amp;lt;-chan struct{} 4 Err() error 5 Value(key interface{}) interface{} 6} context.Context有四个方法：
Deadline() 返回context.Context被取消时间，也就是完成工作的截止日期；
Done() 返回一个channel，这个channel 会在当前工作完成或者上下文被取消后关闭，多次调用Done方法返回的是同一个channel；
Err() 返回context.Context 结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值
如果 context.Context 被取消，会返回Canceled错误；
如果 context.Context 超时，会返回DeadlineExceeded错误；
Value 从context.Context 中获取键对应的值。对同一个上下文来说，多次调用value并传入相同的key会返回相同的结果，该方法用来传递请求特定的数据。
1func main() { 2	ctx := context.Background() // new empty context 3 4	ctx = context.WithValue(ctx, &amp;#34;org&amp;#34;, &amp;#34;ali&amp;#34;) 5	ctx, _ = context.WithCancel(ctx) 6	ctx, _ = context.WithDeadline(ctx, time.Now().Add(10*time.Second)) 7	ctx, _ = context.</description>
    </item>
    
    <item>
      <title>「Go」slice</title>
      <link>https://airren.github.io/note_go/5.3_go_slice/</link>
      <pubDate>Wed, 02 Sep 2020 11:40:22 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.3_go_slice/</guid>
      <description>Slice的坑 1numList := make([]int, 10) 2// 产生的numList会存入10个0， 如果继续append 数据会导致numList的数据超过10 Slice 扩容
1func TestSliceExtend(t *testing.T) { 2	capacity := 0 3	list := make([]int, 0) 4	for i := 0; i &amp;lt; 4096; i++ { 5	list = append(list, i) 6	if capacity != cap(list) { 7	times := float64(cap(list)) / float64(capacity) 8	differ := cap(list) - capacity 9	capacity = cap(list) 10	if times == 2.0 { 11	fmt.Printf(&amp;#34;capacity is: %d \t times: %.</description>
    </item>
    
    <item>
      <title>「Go」Go的安装以及介绍</title>
      <link>https://airren.github.io/note_go/1_go_basic_cmd/</link>
      <pubDate>Thu, 20 Aug 2020 01:40:04 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_go_basic_cmd/</guid>
      <description>1. Go语言介绍 1.1 Go 语言特点 静态类型、编译型的开源语言
静态类型是指要明确变量的类型，或者编译器可以推导出变量的类型。要么在变量类型旁边指定变量的那个类型，要么是可以推导出变量类型。
编译型是指要编译成机器语言。
1package main 2func main(){ 3 // Declare the type of the variable 4 var num1 int = 1; 5 // Deduce the type of the variable 6 num2 :=2 7} 脚本化的语法，支持多种范式编程
函数式&amp;amp;面向对象
原生、给力的并发编程支持
注意： 原生支持和函数库支持的区别
1.2 Go语言的优势和劣势 优势
脚本化的语法 静态类型+编译型，程序运行速度有保障 原生的支持并发编程 - 降低开发、维护成本；程序可以更好的执行 劣势
语法糖并没有Python和Ruby那么多- 1成是开发时间，9成维护时间 目前的程序运行速度还不及c，但是目前已经赶超了C++和Java 第三方库函数暂时不像绝对主流的编程语言那样多 1.3 Go开发环境 Linux 下的安装 FreeBSD Linux Windows 32bit - 64bit
Linux 下的设置方法
有四个环境变量需要设置： GOROOT、GOPATH、GOBIN以及PATH</description>
    </item>
    
    <item>
      <title>「Go」pprof</title>
      <link>https://airren.github.io/note_go/11_go_testprofile/</link>
      <pubDate>Thu, 06 Aug 2020 00:54:12 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/11_go_testprofile/</guid>
      <description>Test Test 1go test --bench ./ 5s Code coverage 1go test -cover Profile 引发性能问题的原因，=执行时间过长、内存占用过多，以及意外堵塞。
在测试时保存并输出相关数据，进行初次评估 在运行阶段通过web接口获得实时数据，分析一段时间内的健康状况 1go test -run NONE -bench . -memprofile mem.out -cpuprofile cpu.out net/http 服务开启debug 端口
1go tool pprof http://10.152.50.69:9452/debug/pprof/profile\?second\=60 -alloc_space
pprof 常用指令
Web</description>
    </item>
    
    <item>
      <title>「Go」时间</title>
      <link>https://airren.github.io/note_go/5.3go_time/</link>
      <pubDate>Thu, 06 Aug 2020 00:54:12 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.3go_time/</guid>
      <description>UNIX 时间戳 Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
类型 位数 Timestamp Time 秒级 10 1596646807 2020-08-06 01:00:07 毫秒级 13 1596646807000 2020-08-06 01:00:07 Unix时间戳（英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp）
是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/1st--/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1st--/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/2_%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/2_%E7%B1%BB%E5%9E%8B/</guid>
      <description>类型 2.1 变量 标识符与关键字 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。
关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。
Go语言中有25个关键字：
1 break default func interface select 2 case defer go map struct 3 chan else goto package switch 4 const fallthrough if range type 5 continue for import return var 此外，Go语言中还有37个保留字。
1 Constants: true false iota nil 2 3 Types: int int8 int16 int32 int64 4 uint uint8 uint16 uint32 uint64 uintptr 5 float32 float64 complex128 complex64 6 bool byte rune string error 7 8 Functions: make len cap new append copy close delete 9 complex real imag 10 panic recover go 语言中的变量必须先声明再使用。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/3_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/3_%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>流程控制 if&amp;hellip;else 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6 var number int = 5 7	if number += 4; 10 &amp;gt; number { 8	number :=0 9	number += 3 10	fmt.Print(number) 11	} else if 10 &amp;lt; number { 12	number -= 2 13	fmt.Print(number) 14	} 15	fmt.Println(number) 16} 17 18// 39 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/4_%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/4_%E5%87%BD%E6%95%B0/</guid>
      <description>函数 现代计算机的进程执行模型大部分是基于“堆栈”的，编译器不需要对函数做过多的转换就能让其在栈上运行
2.1 基本概念 2.1.1 函数定义 一个函数的定义包含如下几个部分： 函数声明关键字func、函数名、参数列表、返回列表和函数体。
首字母的大小写决定该函数在其他包的可见：大写时其他包可见，小写时只有相同的包可以访问。
函数可以没有输入参数、也可以没有返回值（默认返回0）
1func A(){ 2} 3 4func B() int{ 5 return 1 6} 多个相同类型的参数可以使用简写模式
1func add(a,b int) int{ // a int, b int 简写为 a,b int 2 return a+b 3} 支持有名的返回值，参数名相当于函数体最外层的局部变量，命名返回值变量会被初始化为类型零值最后的return可以不带参数名直接返回。
1func add(a,b int) (sum int){ // sum 相当于函数内部的局部变量，被初始化为0 2 sum = a+b 3 return // return sum 的简写模式 4 5 // sum := a+b 6 // return sum // 需要显式的调用return sum 7} 不支持默认值参数？？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/99_Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E8%A7%A3%E6%9E%90/</guid>
      <description>Go并发编程案例解析 nginx
influxdb 时序数据库 Prometheus
Grafana
实例代码
https://github.com/itsmikej/imooc_logprocess
常见的并发模型 进程&amp;amp;线程 Apache C10K 服务器要同时支持10K的并发连接 异步非阻塞 （Nginx，Libevent， NodeJs）epoll 复杂度高 协程 GoLang， Erlang， Lua Golang并发实现 程序并发执行 goroutine 多个goroutine间的数据同步通信channels 多个channel选择数据读取或者写入select Goroutines Goroutines 程序并发执行
1foo() // 执行函数foo, 程序等待函数foo返回 2go foo() // 执行函数foo 3bar（） // 不用等待foo返回 Channels Channels多个goroutine间的数据通信与同步
1c := make(chan string) // 创建一个channel 2go func(){ 3 time.Sleep(1*time.Second) 4 c &amp;lt;- &amp;#34;message from closure&amp;#34; // 发送数据到channel 中 5}() 6 7msg:=&amp;lt;- c // 阻塞直到接收到数据 Select Select 从多个Channel 中读取或写入数据</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/99_%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>软件开发的新挑战
多核硬件架构
超大规模分布式计算集群
web模式下导致的前所未有的规模和更新速度
区块链开发语言，
Kubernetes
Docker
只有25个关键字
有垃圾回收机制，但是仍然可以直接使用指针访问内存
CSP并发机制
关键字
c 37
c++ 11 84
go 25
go 垃圾回收，使用指针直接内存访问.
复合和继承
docker kubernetes
go 默认使用静态连接，编译完成是一个独立的二进制
1package main // package name 2 3import &amp;#34;fmt&amp;#34; // dependence 4 5// functionality 6func main() { 7	fmt.Print(&amp;#34;hello world \n&amp;#34;) 8} 应用程序入口，
必须是main包 package main 必须是main方法 func main() 文件名不一定是main.go package 的名字不需要与目录保持一致
退出返回值
与其他主要编程语言的差异
Go main函数不支持任何返回值 通过os.Exit 来返回状态 1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;os&amp;#34; 6) 7 8func main() { 9	fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://airren.github.io/note_go/base/string_operate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/base/string_operate/</guid>
      <description>1package dal 2 3import &amp;#34;testing&amp;#34; 4 5func Empty() { 6	str := &amp;#34;12312&amp;#34; 7	if str == &amp;#34;&amp;#34; { 8 9	} 10} 11func Lenzero() { 12	str := &amp;#34;&amp;#34; 13	if len(str) == 0 { 14 15	} 16} 17func BenchmarkEmpty(b *testing.B) { 18	for n := 0; n &amp;lt; b.N; n++ { 19	Empty() 20	} 21} 22 23func BenchmarkLenzero(b *testing.B) { 24	for n := 0; n &amp;lt; b.</description>
    </item>
    
    <item>
      <title>「Go」ioutil</title>
      <link>https://airren.github.io/note_go/5.4ioutil/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.4ioutil/</guid>
      <description>复用http.request.body
https://studygolang.com/articles/15641?fr=sideba</description>
    </item>
    
    <item>
      <title>「Go」pprof 性能分析</title>
      <link>https://airren.github.io/note_go/performance_analysis/pprof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/performance_analysis/pprof/</guid>
      <description>pprof
可以用于分析程序的性能，并找到瓶颈点。
程序中的 runtime/pprof 性能剖析工具 go tool pprof </description>
    </item>
    
    <item>
      <title>「Go」Struct</title>
      <link>https://airren.github.io/note_go/5.5Struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/5.5Struct/</guid>
      <description>匿名struct比较
1func main() { 2	sn1 := struct { 3	age int 4	name string 5	}{age: 11, name: &amp;#34;qq&amp;#34;} 6 7	sn2 := struct { 8	age int 9	name string 10	}{age: 11, name: &amp;#34;qq&amp;#34;} 11 12	if sn1 == sn2 { 13	fmt.Println(&amp;#34;sn1 == sn2&amp;#34;,sn1) 14	} 15 16	fmt.Printf(&amp;#34;sn1 addr %p\n&amp;#34;,&amp;amp;sn1) 17	fmt.Printf(&amp;#34;sn2 addr %p\n&amp;#34;,&amp;amp;sn2) 18} 1sn1 == sn2 {11 qq} 2sn1 addr 0xc0000a6020 3sn2 addr 0xc0000a6040 </description>
    </item>
    
    <item>
      <title>「Go」内存分配</title>
      <link>https://airren.github.io/note_go/source_code_profiling/mem_allocation/mem_allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/source_code_profiling/mem_allocation/mem_allocation/</guid>
      <description>重点剖析Go运行时的内部机制，深入了解Go运行期状态，规避GC潜在的问题，节约内存，提升运行性能
环境 Mac环境
(不建议使用，会有很多困扰，直接用Linux)
Debian环境 编译好的可执行文件真正的执行入口并不在main.go的mian()函数中。编译器总会插入一段引导代码，完成命令行参数、运行时初始化等工作才会进入用户逻辑。
编译&amp;amp;GDB调试 main.go
1package main 2 3func main() { 4	println(&amp;#34;hello world&amp;#34;) 5} -gcflags &amp;ldquo;-N -l&amp;rdquo; 关闭编译器代码优化和函数内联，避免断点和单步执行无法准确对应源码行，避免小函数和局部变量被优化掉
1go build -gcflags &amp;#34;-N -l&amp;#34; 2# go build -gcflags &amp;#34;-N -l&amp;#34; -o test main.go 通过info files可以找到程序真正的入口地址0x105a8c0 ,利用断点命令可以找到目标源文件信息。
Mac 下breakpoint 并未显示对应的文件信息，以下所有的操作均在Debian中查看。
不同的操作系统就使用不同的汇编文件
下面这这个汇编文件完成了初始化和运行时的启动动作。
调用初始化函数 创建main goroutine用于执行runtime.main 让当前线程开始执行main goroutine 至此，汇编语言针对特定平台的引导过程全部完成，后续的内容基本上都是由Go代码实现的。
go的汇编
Go ASM 和标准的汇编语法（ NASM 或 YASM ）不太一样，首先你会发现它是架构独立的，没有所谓的 32 或 64 位寄存器，如下图所示：
Tips:Mac 配置gdb环境 GDB Installation on Mac OS X</description>
    </item>
    
    <item>
      <title>「Go」逃逸分析</title>
      <link>https://airren.github.io/note_go/compile_optimize/escape_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/compile_optimize/escape_analysis/</guid>
      <description>堆内存与栈内存
Go程序会在两个地方为变量分配内存，一个是全局的堆空间用来动态分配内存，另一个是每个goroutine的栈空间。与Java、Python等语言类似，Go语言实现垃圾回收机制，所以Go语言的内存管理是自动的，通常开发者不用关心内存分配到栈上还是堆上。但是从性能的角度出发，在栈上和堆上分配内存，性能差异是非常大的。
在函数中申请一个对象，，如果分配在栈中，函数执行结束时自动回收；如果分配在堆中，则在函数结束后某个时间点进行垃圾回收。
在栈上分配和回收内存的开销很低，只需要2个cpu指令: PUSH和POP。一个是将数据push到栈空间以完成分配，pop则是释放空间。也就是说在栈上分配内存，消耗的仅是将数据copy到内存的时间。内存的I/O通常能达到30GB/s，因此在栈上分配内存的效率是非常高的。
在堆上分配内存，一个很大的额外开销则是垃圾回收。Go语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率。
参考资料：
https://geektutu.com/post/hpg-escape-analysis.html</description>
    </item>
    
    <item>
      <title>【慕课网】Go开发短地址服务</title>
      <link>https://airren.github.io/note_go/99_go_short_addr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_go_short_addr/</guid>
      <description>1 短地址服务 将长地址缩短到一个很短的地址，用户访问这个短地址可以重定向到原本的长地址。
如何设计HTTP Router 和handler 如何在HTTP 处理流程中加入Middleware 如何利用Go的Interface来实现可扩展的设计 如何使用redis的自增长序列生成短地址 2 主服务模块 API接口 POST /api/shorten GET /api/info?shortlink=shortlink GET /:shortlink - return 302 code 重定向 POST /api/shorten Params
Name Type Description url string Required. URL to shorten. e.g. https://www.example.com expiration_in_minutes int Required. Expiration of short link in minutes. e.g. value 0 represents permanent. Response
1{ 2 &amp;#34;shortlink&amp;#34;:&amp;#34;P&amp;#34; 3} GET /api/info?shortlink=shortlink Params
Name Type Description shortlink string Required. Id of shortened. e.g. P Response</description>
    </item>
    
    <item>
      <title>Go Assembly</title>
      <link>https://airren.github.io/note_go/0_go_assambely/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/0_go_assambely/</guid>
      <description>Golang的汇编是基于Plan9的的汇编，是一个中间汇编的方式，这样可以忽略底层CPU架构的差别。
汇编主要了解各种寄存器的使用以及寻址方式。根据Golang的汇编我们可以深入理解Golang的底层实现。比如内存如何分配，栈如何扩张，接口如何转变。
如何从go语言获取对应的汇编
1go build -gcflags &amp;#34;-N -l&amp;#34; -ldflags=-compressdwarf=false =o main.out main.g 2go tool objdump -s &amp;#34;main.main&amp;#34; main.out &amp;gt; main.S 3# or 4go tool compile -S main.go 5# or 6go build -gcflags -S main.go 汇编基础语法 通用寄存器 寄存器与物理机架构有关，不同的架构有不同的物理寄存器。
在amd64架构上提供了16个通用寄存器给用户使用。
Plan9汇编语言提供了如下映射，这样就可以在汇编语言中这几应用就可以使用物理寄存器了。
x64架构中所有的寄存器都是64位
amd64 Plan9 rax AX rbx BX rcx CX rdx DX rdi DI rsi SI rbp BP rsp SP r8 R8 r9 R9 r10 R10 r11 R11 r12 R12 r13 R13 r14 R14 rip PC 虚拟寄存器 伪寄存器不是真正的寄存器，而是由工具链维护的虚拟寄存器，例如帧指针。</description>
    </item>
    
    <item>
      <title>Go compile</title>
      <link>https://airren.github.io/note_go/0_go_compile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/0_go_compile/</guid>
      <description>n
https://zhuanlan.zhihu.com/p/343562661
https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sysmon/</description>
    </item>
    
    <item>
      <title>Go 设置Golang开发环境</title>
      <link>https://airren.github.io/note_go/1_SettingUpGoEnv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_SettingUpGoEnv/</guid>
      <description>安装Go 开始写Golang之前，你首先需要下载并且安装Golang开发工具。可以在Golang的官方网站下载最新的安装包。根据你的开发平台选择下载对应的版本。对于Mac用户(或者Windows用户)来说.pkg(或msi)安装包会自动把Golang安装到合适的位置，并将命令加入到环境变量，并且自动移除老版本。如果使用Mac更加推荐直接使用brew install go， 使用brew 可以方便的管理Go多个版本。
对于Linux或者FreeBSD用户可以直接下载对应的.tar.gz, 并解压到文件名为go的目录中。把这个文件Copy到/usr/local/下。然后把/usr/local/go/bin添加到$PATH中。
1tar -C /usr/local -xzvf go1.17.3.linux-amd64.tar.gz 2# change .profile to .bashrc or.zsh depend on you evnironment 3echo &amp;#34;export PATH=$PATH:/usr/local/go/bin&amp;#34; &amp;gt;&amp;gt;$HOME/.profile Go 程序编译完成后是一个独立的二进制文件，不需要依赖任何运行软件(例如，Python需要Python解释器，Java需要JVM)。仅在需要编译Go代码的环境上安装Go即可。
安装完成后，打开Terminal(Window 打开CMD)，验证Go是否安装成功。
1go version 在所有的配置都正确的情况下，可以看到输出的版本信息
1# mac intel cpu 64bit 2go version go1.17.3 darwin/amd64 从上述信息中可以看出，Go的版本是1.17.3,使用的开发机器是 Mac(Darwin 是MacOS的Kernel Name, amd64 是指64-bit的x86 CPU架构)。
如果你没有得到正确的版本信息，很有可能是你没有把go加入到环境变量，或者有其他的程序名称也为go。对于Mac或者Unix-like用户，可以使用which go查看当前环境下的go的是否正确关联到/usr/local/go/bin。如果路径正确，也有可能是下载错了安装包，检查下安装包的位数是否与当前操作系统匹配，有可能在64-bit的系统上下载了32-bit的安装包。另外，也有可能是芯片架构选错了。
Go 工作空间 从2009年Go开始使用，在开发者如果组织代码和管理依赖上经历了几次变化。在Go 1.11所有的代码必须保存在GOPATH之下，之后的版本用户可以在任意目录下存储自己的代码。但是Go依然希望有一个独立的工作空间可以存储通过go install安装额第三方包。默认的工作空间是$HOME/go, 下载的第三方包默认存储在$HOME/go/src,编译的二进制文件存储在$HOME/go/bin。你可以直接使用这个默认的工作空间，或者通过设置$GOPAHT指定一个工作空间。
无论你是否使用默认的wokespace，建议你把$GOPATH/bin加入到$PATH中。 通过指定$GOPATH可以清楚地描述当前环境的Go工作空间，把$GOPATH/bin加入到可执行路径中可以直接使用go install 安装的第三方包。
如果是Unix-like的开发环境可以把下面几行加入到$HOME/.profile中。
1# if use ubuntu you should add to .</description>
    </item>
    
    <item>
      <title>Reflect, Unsafe, and Cgo</title>
      <link>https://airren.github.io/note_go/14-golang_reflect_unsafe_cgo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/14-golang_reflect_unsafe_cgo/</guid>
      <description>Reflect
Reflection Let Us Work with Types at Runtime But sometimes, relying on only compilation-time information is a limitation. You might need to work with variables at runtime using information that didn&amp;rsquo;t exist when the program was written. Maybe you&amp;rsquo;re trying to map data from a file or network request into a variable, or you want to build a single function that works with different types. In those situations, you need to use reflection.</description>
    </item>
    
    <item>
      <title>基本语法梳理</title>
      <link>https://airren.github.io/note_go/1_Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%A2%B3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/1_Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%A2%B3%E7%90%86/</guid>
      <description>源文件 原文件使用UTF-8编码，对Unicode支持良好。每个源文件都属于包的一部分，在文件头部用package声明所属包的名称
1package main 2func main(){ 3 println(&amp;#34;hello world!!&amp;#34;) 4} 以.go作为文件扩展名，语句结束分号会被默认省略，支持C样式注释。入口函数main没有参数，且必须放在main包中
用import导入标准库或第三方包
1package main 2import{ 3 &amp;#34;fmt&amp;#34; 4} 5 6func main(){ 7 fmt.Println(&amp;#34;hello world!&amp;#34;) 8} 可以直接运行或者编译为可执行文件
变量 使用var定义变量，支持类型推断。基础数据类型划分清晰明确，有助于编写跨平台应用。编译器确保变量总是被初始化为0，避免出现意外状况。
1package main 2func main(){ 3 var x int32 4 var s=&amp;#34;hello world!&amp;#34; 5 // 两个数据之间默认使用空格隔开 6 println(x,s) 7} 在函数内部，还可以省略var关键字，使用更简单的定义模式。
1package main 2 3//y := 200 // 该声明方式仅在函数内部使用，不可用来声明全局变量 4func main() { 5	x := 100 6	println(x) 7} 编译器将未使用的局部变量定义当做错误
表达式 Go仅有三种流控制语句
if 1package main 2 3func main() { 4	x := 100 5	if x &amp;gt; 0 { 6	print(&amp;#34;x&amp;#34;) 7	} else if x &amp;lt; 0 { 8	print(&amp;#34;-x&amp;#34;) 9	} else { 10	print(&amp;#34;0&amp;#34;) 11	} 12} switch 1package main 2 3func main() { 4	x := 0 5	switch { 6	case x &amp;gt; 0: 7	print(&amp;#34;x&amp;#34;) 8	case x &amp;lt; 0: 9	print(&amp;#34;-x&amp;#34;) 10	default: 11	print(&amp;#34;0&amp;#34;) 12	} 13} for 1func main() { 2	for i := 0; i &amp;lt; 5; i++ { 3	println(i) 4	} 5	for i := 4; i &amp;gt;= 0; i-- { 6	println(i) 7	} 8} 1package main 2 3func main() { 4	x := 0 5 for x &amp;lt; 5 { // 相当于 while(x&amp;lt;5) 6	println(x) 7	x++ 8	} 9} 1package main 2 3func main() { 4	x := 4 5	for { // 相当于while(true) 6	println(x) 7	x-- 8	if x &amp;lt; 0 { 9	break 10	} 11	} 12} 在迭代遍历时，for&amp;hellip;range除了元素外，还可以返回索引</description>
    </item>
    
    <item>
      <title>极客时间 GO实践</title>
      <link>https://airren.github.io/note_go/99_Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://airren.github.io/note_go/99_Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/</guid>
      <description>微服务概览 康威定律
You build it. You fix it.
按照业务组织服务。
按照业务能力组织服务的意思是
去中心化 数据去中心化 隔离性： 每个服务要独享自己的存储设置。 治理去中心化 账号服务 服务发现 技术去中心化 收敛语言，go, C++ 基础设置自动化 CICD
Prometheus/ELK/Control Panle
可用性&amp;amp;兼容性设计 Design for Failure，所有的依赖都可能会炸，所有可能出现err的地方都可能出现panic。
隔离 超时控制 负载保护 限流 降级 重试 负载均衡 微服务设计 API Gateway API版本升级，强耦合
面向用户的业务场景的API，而不是面向资源的API&amp;ndash; 前轻后重
安全认证，限流
gRPC &amp;amp; 服务发现 第6课 评论系统架构设计 https://github.com/go-kratos
功能模块 理解整个背后的业务逻辑，理解业务的本质，事情的初衷。搞清楚系统背后的背景，才能做出最佳的抽象和设计。
在动手设计前反复思考，真正编码的时间只有5%？
不要在想的不清不楚的时候动手。
Mysql: OLTP 如果是group by等计算密集型查询的容易把数据库打垮。
Binlog ?
架构设计等同于数据设计，梳理清楚数据的走向和逻辑。
尽量避免环形依赖。
malloc 申请2G的内存，是否真正绑定了2G物理内存。
什么是缺页中断。
架构设计
存储设计
可用性设计</description>
    </item>
    
  </channel>
</rss>
